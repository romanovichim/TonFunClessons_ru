# Урок 1 Простой смарт-контракт
## Введение

В этом уроке мы напишем ваш первый смартконтракт в тестовой сети TON(Telegram Open Network) на языке FunC, задеплоим* его в тестовую сеть с помощью [toncli](https://github.com/disintar/toncli), а также протестируем его с помощью сообщения на языке Fift.

  > *Деплой  - процесс переноса в сеть (в данном случае смарт-контракта в блокчейн)
  
## Требования

Для прохождения данного урока вам необходимо установить интерфейс для командной строки [toncli](https://github.com/disintar/toncli/blob/master/INSTALLATION.md)

## Смарт-контракт

Смарт-контракт, который мы будем делать, должен обладать следующей функциональностью:
- хранить в своих данных целое число *total* - 64-битное целое число без знака;
- при получении внутреннего входящего сообщения контракт, должен взять 32-битное целое число без знака из тела сообщения, добавить его к *total* и сохранить в данных контракта;
- В смарт-контракте должен быть предусмотрен метод *get total* позволяющий вернуть значение *total* 
- Если тело входящего сообщения меньше 32 бит, то контракт должен выдать исключение

## Создадим проект с помощью toncli

В консоли выполните следующие команды:

    toncli start wallet
    cd wallet

Toncli создал простой проект кошелька, в нем вы можете увидеть 4 папки:
- build;
- func;
- fift;
- test;

На данном этапе нас интересуют папки func и fift, в которых мы будем писать код на FunС и Fift соответственно.

##### Что такое FunC и Fift

Высокоуровневый язык [FunC](https://ton.org/docs/#/smart-contracts/) используется для программирования смарт-контрактов на TON. Программы FunC компилируются в Fift ассемблерный код, который генерирует соответствующий байт-код для виртуальной машины TVM([TON Virtual Machine](https://ton-blockchain.github.io/docs/tvm.pdf)). 

Далее этот байт-код (на самом деле дерево ячеек, как и любые другие данные в TON Blockchain) может быть использован для создания смарт-контракта в блокчейне или может быть запущен на локальном экземпляре TVM.

##### Подготовим файл для нашего кода

Зайдите в папку func:

    cd func


и откройте файл `code.func`. На своем экране вы увидите смарт-контракт кошелька.
Удалите весь код.
Теперь мы готовы начать писать наш первый смарт контракт.

## Внешние методы

У смарт-контрактов в сети TON есть два зарезервированных метода, к которым можно обращаться.

Первый - `recv_external()`. Эта функция выполняется, когда запрос к контракту происходит из внешнего мира, то есть не из TON. Например когда мы сами формируем сообщение и отправляем его через lite-client* (Про установку [lite-client](https://ton.org/docs/#/compile?id=lite-client)).
Второй - `recv_internal()`. Эта функция выполняется, когда запрос к контракту происходит внутри самого TON. Например, когда какой-либо контракт обращается к нашему.
 
 > *Легкий клиент (англ. lite-client) — это программное обеспечение, которое подключается к полным узлам для взаимодействия с блокчейном. Они помогают пользователям получать доступ к блокчейну и взаимодействовать с ним без необходимости синхронизации всего блокчейна.
 
Под наши условия подходит `recv_internal()`.

В файле `code.fc` пропишем:

    () recv_internal(slice in_msg_body) impure {
    ;; здесь будет код
    }
 
 >  ;;  две точки с запятой синтаксис однострочного комментария
 
Мы передаем в функцию слайс `in_msg_body` и используем ключевое слово `impure`.

`impure` — ключевое слово, которое указывает на то, что функция изменяет данные смарт-контракта.

Мы должны указать `impure` спецификатор, если функция:
- может изменять хранилище контрактов 
- отправлять сообщения
- генерировать исключение, когда некоторые данные недействительны и функция предназначена для проверки этих данных

> **Важно:** Если не указано impure и результат вызова функции не используется, то компилятор FunC может удалить этот вызов функции.

А вот чтобы понять, что такое слайс, поговорим про типы в смарт-контрактах сети TON.

##### Типы cell, slice, builder, integer в FunC

В нашем просто смарт контракте мы будем использовать всего лишь четыре типа:

- Cell(ячейка) - Ячейка TVM, состоящая из 1023 бит данных и до 4 ссылки на другие ячейки
- Slice(слайс)- Частичное представление ячейки TVM, используемой для разбора данных из ячейки
- Builder - Частично построенная ячейка, содержащая до 1023 бит данных и до четырех ссылок; может использоваться для создания новых ячеек
- Integer - знаковое 257-разрядное целое число

Подробнее о типах в FunC:

- [кратко](https://ton.org/docs/#/smart-contracts/)
- [развернуто(в разделе 2.1)](https://ton-blockchain.github.io/docs/fiftbase.pdf)

> Говоря простым языком: 
> - cell - это запечатанная ячейка
> - slice - это, когда ячейку можно читать
> - builder - это, когда собираешь ячейку

## Преобразуем полученный слайс в Integer

Чтобы преобразовать полученный слайс в Integer  добавим следуюший код:
`int n = in_msg_body~load_uint(32);` 

Функция `recv_internal()` теперь выглядит так:

    () recv_internal(slice in_msg_body) impure {
        int n = in_msg_body~load_uint(32);
    }

`load_uint` функция из [стандартной библиотеки FunC ](https://ton.org/docs/#/func/stdlib) она загружает целое число n-бит без знака из слайса.

## Постоянные данные смарт-контракта

Чтобы добавить полученную переменную к `total` и сохранить значение в смарт-контракте, рассмотрим как реализован функционал хранения постоянных данных/хранилища в TON.

> **Примечание:** не путайте с TON Storage, хранилище в предыдущем предложении удобная аналогия.

Виртуальная машина TVM является стековой, соответственно хорошей практикой хранения данных в контракте будет использовать определенный регистр, а не хранить данный "сверху" стека.

Для хранения постоянных данных отведен регистр с4, тип данных Cell.

Подробнее с регистрами можно ознакомиться [с4](https://ton-blockchain.github.io/docs/tvm.pdf) в пункте 1.3.

##### Возьмем данные из с4

Для того чтобы "достать" данные из с4 нам понадобятся две функции из [стандартной библиотеки FunC ](https://ton.org/docs/#/func/stdlib):
- `get_data`   - берет ячейку из c4 регистра
- `begin_parse` -   ячейку преобразует в slice 

Передадим это значение в слайс ds

`slice ds = get_data().begin_parse();` 

А также преобразуем этот слайс в Integer 64-бит для суммирования в соответствии с нашей задачей. (С помощью уже знакомой нам функции `load_uint`)

`int total = ds~load_uint(64);` 

Теперь наша функция будет выглядеть так:

    () recv_internal(slice in_msg_body) impure {
		int n = in_msg_body~load_uint(32);

		slice ds = get_data().begin_parse();
		int total = ds~load_uint(64);
    }

##### Cуммируем

Для суммирования будем использовать бинарную операцию суммирования `+`  и присвоение `=` 

    () recv_internal(slice in_msg_body) impure {
		int n = in_msg_body~load_uint(32);

		slice ds = get_data().begin_parse();
		int total = ds~load_uint(64);

		total += n;
    }

##### Cохраняем значение

Для того чтобы сохранить постоянное значение, нам необходимо выполнить четыре действия с помощью функций [стандартной библиотеки FunC ](https://ton.org/docs/#/func/stdlib):

- `begin_cell()` - создать Builder для будущей ячейки
- `store_uint()`- записать значение total
- `end_cell()`- создать Cell (ячейку)  из Builder
- `set_data()` - записать ячейку в регистр с4

`set_data(begin_cell().store_uint(total, 64).end_cell());` 


**Итог:**

    () recv_internal(slice in_msg_body) impure {
		int n = in_msg_body~load_uint(32);

		slice ds = get_data().begin_parse();
		int total = ds~load_uint(64);

		total += n;

		set_data(begin_cell().store_uint(total, 64).end_cell());
    }

## Генерация исключений

Все, что осталось сделать в нашей internal функции, - это добавить вызов исключения, если полученна переменная не 32-битная.

Для этого будем использовать [встроенные](https://ton.org/docs/#/func/builtins) исключения. 

Исключения могут быть вызваны условными примитивами `throw_if` и `throw_unless` и безусловным `throw` .

Воспользуемся `throw_if` и передадим любой код ошибки. Для того, чтобы взять битность используем `slice_bits()`.

	throw_if(35,in_msg_body.slice_bits() < 32);
	
Кстати, в виртуальной машине TON TVM есть стандартные коды исключений, они нам очень понадобятся в тестах. Посмотреть можно [здесь](https://ton.org/docs/#/smart-contracts/tvm_exit_codes).

Вставим в начало функции:

    () recv_internal(slice in_msg_body) impure {
		throw_if(35,in_msg_body.slice_bits() < 32);

		int n = in_msg_body~load_uint(32);

		slice ds = get_data().begin_parse();
		int total = ds~load_uint(64);

		total += n;

		set_data(begin_cell().store_uint(total, 64).end_cell());
    }


## Пишем Get функцию

Любая функция в FunC  соответствует следующему паттерну:

`[<forall declarator>] <return_type><function_name(<comma_separated_function_args>) <specifiers>`

Напишем функцию get_total(), возвращающую Integer и имеющую спецификацию method_id (об этом чуть позже)
 
    int get_total() method_id {
  	;; здесь будет код
	}

##### Method_id

Спецификация method_id позволяет вызывать GET функцию по названию из lite-client or ton-explorer.
Грубо говоря, все фукнции в том имеют численный идентификатор, get методы нумеруются по crc16 хэшам их названий.

##### Берем данные из с4

Для того, что функция возвращала total хранящееся в контракте, нам надо взять данные из регистра, что мы уже делали:

 
    int get_total() method_id {
  		slice ds = get_data().begin_parse();
 	 	int total = ds~load_uint(64);
		
  		return total;
	}
	

## Весь код нашего смарт-контракта


    () recv_internal(slice in_msg_body) impure {
		throw_if(35,in_msg_body.slice_bits() < 32);

		int n = in_msg_body~load_uint(32);

		slice ds = get_data().begin_parse();
		int total = ds~load_uint(64);

		total += n;

		set_data(begin_cell().store_uint(total, 64).end_cell());
    }
	 
    int get_total() method_id {
  		slice ds = get_data().begin_parse();
 	 	int total = ds~load_uint(64);
		
  		return total;
	}
	
	
	
## Деплоим контракт в тестовую сеть

Для деплоя в тестовую сеть будем использовать интерфейса для командной строки [toncli](https://github.com/disintar/toncli/)

`toncli deploy -n testnet`

##### Что делать если пишет, что не хватает TON?

Необходимо получить их с тестового крана, бот для этого @testgiver_ton_bot.
Адрес кошелька вы можете увидеть прямо в консоли, после команды деплой, toncli отобразит его справа от строки INFO: Found existing deploy-wallet

Чтобы проверить пришли ли TON на ваш кошелек в тестовой сети, можете использовать вот этот explorer: https://testnet.tonscan.org/

> **Важно:** Речь идет только о тестовой сети

## Тестируем контракт

##### Вызов recv_internal()

Для вызова recv_internal() необходимо послать сообщение внутри сети TON. 
С помощью [toncli send](https://github.com/disintar/toncli/blob/master/docs/advanced/send_fift_internal.md)

Напишем небольшой скрипт на Fift, который будет отправлять 32-битное сообщение в наш контракт.

##### Скрипт сообщения

Для этого создадим в папке fift файл `try.fif` и напишем в нем следующий код:
 
    "Asm.fif" include
	
	<b
		11 32 u, // number
	b>
	

`"Asm.fif" include` - необходим для компиляции сообщения в байт код

Теперь рассмотрим сообщение:

`<b b>` - создают Builder ячейки, подробнее в пункте [5.2](https://ton-blockchain.github.io/docs/fiftbase.pdf)

`11 32 u` - кладем 32-битное unsigned integer 11

` // number` - однострочный комментарий

##### Деплоим получившееся сообщение

В командной строке:

`toncli send -n testnet -a 0.03 --address "адрес вашего контракта" --body ./fift/try.fif`

Теперь протестируем GET функцию:

` toncli get get_total`

Должно получиться следующее:

![toncli get send](./img/tonclisendget.png)

## Поздравляю вы дошли до конца

##### Задание

Как вы могли заметить мы не протестировали работу исключений, модифицируйте сообщение таким образом чтобы смарт-контракт вызывал исключение
