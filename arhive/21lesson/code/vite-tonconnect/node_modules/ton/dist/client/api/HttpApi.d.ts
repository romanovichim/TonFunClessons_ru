/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/// <reference types="node" />
import * as t from 'io-ts';
import { TonCache } from './TonCache';
import { AxiosAdapter } from 'axios';
import { Address, Cell, TupleItem } from 'ton-core';
declare const message: t.TypeC<{
    source: t.StringC;
    destination: t.StringC;
    value: t.StringC;
    fwd_fee: t.StringC;
    ihr_fee: t.StringC;
    created_lt: t.StringC;
    body_hash: t.StringC;
    msg_data: t.UnionC<[t.TypeC<{
        '@type': t.LiteralC<"msg.dataRaw">;
        body: t.StringC;
    }>, t.TypeC<{
        '@type': t.LiteralC<"msg.dataText">;
        text: t.StringC;
    }>, t.TypeC<{
        '@type': t.LiteralC<"msg.dataDecryptedText">;
        text: t.StringC;
    }>, t.TypeC<{
        '@type': t.LiteralC<"msg.dataEncryptedText">;
        text: t.StringC;
    }>]>;
}>;
declare const getTransactions: t.ArrayC<t.TypeC<{
    data: t.StringC;
    utime: t.NumberC;
    transaction_id: t.TypeC<{
        lt: t.StringC;
        hash: t.StringC;
    }>;
    fee: t.StringC;
    storage_fee: t.StringC;
    other_fee: t.StringC;
    in_msg: t.UnionC<[t.UndefinedC, t.TypeC<{
        source: t.StringC;
        destination: t.StringC;
        value: t.StringC;
        fwd_fee: t.StringC;
        ihr_fee: t.StringC;
        created_lt: t.StringC;
        body_hash: t.StringC;
        msg_data: t.UnionC<[t.TypeC<{
            '@type': t.LiteralC<"msg.dataRaw">;
            body: t.StringC;
        }>, t.TypeC<{
            '@type': t.LiteralC<"msg.dataText">;
            text: t.StringC;
        }>, t.TypeC<{
            '@type': t.LiteralC<"msg.dataDecryptedText">;
            text: t.StringC;
        }>, t.TypeC<{
            '@type': t.LiteralC<"msg.dataEncryptedText">;
            text: t.StringC;
        }>]>;
    }>]>;
    out_msgs: t.ArrayC<t.TypeC<{
        source: t.StringC;
        destination: t.StringC;
        value: t.StringC;
        fwd_fee: t.StringC;
        ihr_fee: t.StringC;
        created_lt: t.StringC;
        body_hash: t.StringC;
        msg_data: t.UnionC<[t.TypeC<{
            '@type': t.LiteralC<"msg.dataRaw">;
            body: t.StringC;
        }>, t.TypeC<{
            '@type': t.LiteralC<"msg.dataText">;
            text: t.StringC;
        }>, t.TypeC<{
            '@type': t.LiteralC<"msg.dataDecryptedText">;
            text: t.StringC;
        }>, t.TypeC<{
            '@type': t.LiteralC<"msg.dataEncryptedText">;
            text: t.StringC;
        }>]>;
    }>>;
}>>;
export declare type HTTPTransaction = t.TypeOf<typeof getTransactions>[number];
export declare type HTTPMessage = t.TypeOf<typeof message>;
export interface HttpApiParameters {
    /**
     * HTTP request timeout in milliseconds.
     */
    timeout?: number;
    /**
     * API Key
     */
    apiKey?: string;
    /**
     * Adapter for Axios
     */
    adapter?: AxiosAdapter;
}
export declare class HttpApi {
    readonly endpoint: string;
    readonly cache: TonCache;
    private readonly parameters;
    private shardCache;
    private shardLoader;
    private shardTransactionsCache;
    private shardTransactionsLoader;
    constructor(endpoint: string, parameters?: HttpApiParameters);
    getAddressInformation(address: Address): Promise<{
        balance: string | number;
        state: "active" | "uninitialized" | "frozen";
        data: string;
        code: string;
        last_transaction_id: {
            '@type': "internal.transactionId";
            lt: string;
            hash: string;
        };
        block_id: {
            '@type': "ton.blockIdExt";
            workchain: number;
            shard: string;
            seqno: number;
            root_hash: string;
            file_hash: string;
        };
        sync_utime: number;
    }>;
    getTransactions(address: Address, opts: {
        limit: number;
        lt?: string;
        hash?: string;
        to_lt?: string;
        inclusive?: boolean;
    }): Promise<{
        data: string;
        utime: number;
        transaction_id: {
            lt: string;
            hash: string;
        };
        fee: string;
        storage_fee: string;
        other_fee: string;
        in_msg: {
            source: string;
            destination: string;
            value: string;
            fwd_fee: string;
            ihr_fee: string;
            created_lt: string;
            body_hash: string;
            msg_data: {
                '@type': "msg.dataRaw";
                body: string;
            } | {
                '@type': "msg.dataText";
                text: string;
            } | {
                '@type': "msg.dataDecryptedText";
                text: string;
            } | {
                '@type': "msg.dataEncryptedText";
                text: string;
            };
        } | undefined;
        out_msgs: {
            source: string;
            destination: string;
            value: string;
            fwd_fee: string;
            ihr_fee: string;
            created_lt: string;
            body_hash: string;
            msg_data: {
                '@type': "msg.dataRaw";
                body: string;
            } | {
                '@type': "msg.dataText";
                text: string;
            } | {
                '@type': "msg.dataDecryptedText";
                text: string;
            } | {
                '@type': "msg.dataEncryptedText";
                text: string;
            };
        }[];
    }[]>;
    getMasterchainInfo(): Promise<{
        state_root_hash: string;
        last: {
            '@type': "ton.blockIdExt";
            workchain: number;
            shard: string;
            seqno: number;
            root_hash: string;
            file_hash: string;
        };
        init: {
            '@type': "ton.blockIdExt";
            workchain: number;
            shard: string;
            seqno: number;
            root_hash: string;
            file_hash: string;
        };
    }>;
    getShards(seqno: number): Promise<{
        '@type': "ton.blockIdExt";
        workchain: number;
        shard: string;
        seqno: number;
        root_hash: string;
        file_hash: string;
    }[]>;
    getBlockTransactions(workchain: number, seqno: number, shard: string): Promise<{
        id: {
            '@type': "ton.blockIdExt";
            workchain: number;
            shard: string;
            seqno: number;
            root_hash: string;
            file_hash: string;
        };
        req_count: number;
        incomplete: boolean;
        transactions: {
            '@type': "blocks.shortTxId";
            mode: number;
            account: string;
            lt: string;
            hash: string;
        }[];
    }>;
    getTransaction(address: Address, lt: string, hash: string): Promise<{
        data: string;
        utime: number;
        transaction_id: {
            lt: string;
            hash: string;
        };
        fee: string;
        storage_fee: string;
        other_fee: string;
        in_msg: {
            source: string;
            destination: string;
            value: string;
            fwd_fee: string;
            ihr_fee: string;
            created_lt: string;
            body_hash: string;
            msg_data: {
                '@type': "msg.dataRaw";
                body: string;
            } | {
                '@type': "msg.dataText";
                text: string;
            } | {
                '@type': "msg.dataDecryptedText";
                text: string;
            } | {
                '@type': "msg.dataEncryptedText";
                text: string;
            };
        } | undefined;
        out_msgs: {
            source: string;
            destination: string;
            value: string;
            fwd_fee: string;
            ihr_fee: string;
            created_lt: string;
            body_hash: string;
            msg_data: {
                '@type': "msg.dataRaw";
                body: string;
            } | {
                '@type': "msg.dataText";
                text: string;
            } | {
                '@type': "msg.dataDecryptedText";
                text: string;
            } | {
                '@type': "msg.dataEncryptedText";
                text: string;
            };
        }[];
    } | null>;
    callGetMethod(address: Address, method: string, stack: TupleItem[]): Promise<{
        gas_used: number;
        exit_code: number;
        stack: unknown[];
    }>;
    sendBoc(body: Buffer): Promise<void>;
    estimateFee(address: Address, args: {
        body: Cell;
        initCode: Cell | null;
        initData: Cell | null;
        ignoreSignature: boolean;
    }): Promise<{
        '@type': "query.fees";
        source_fees: {
            '@type': "fees";
            in_fwd_fee: number;
            storage_fee: number;
            gas_fee: number;
            fwd_fee: number;
        };
    }>;
    private doCall;
}
export {};
