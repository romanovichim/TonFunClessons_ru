import {
  require_nacl_fast
} from "./chunk-BNHCKJWG.js";
import {
  __commonJS,
  import_buffer,
  init_shim
} from "./chunk-67SBX2SA.js";

// node_modules/symbol.inspect/index.js
var require_symbol = __commonJS({
  "node_modules/symbol.inspect/index.js"(exports, module) {
    "use strict";
    init_shim();
    var SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
    module.exports = SymbolInspect;
  }
});

// node_modules/ton-core/dist/utils/crc16.js
var require_crc16 = __commonJS({
  "node_modules/ton-core/dist/utils/crc16.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc16 = void 0;
    function crc16(data) {
      const poly = 4129;
      let reg = 0;
      const message = import_buffer.Buffer.alloc(data.length + 2);
      message.set(data);
      for (let byte of message) {
        let mask = 128;
        while (mask > 0) {
          reg <<= 1;
          if (byte & mask) {
            reg += 1;
          }
          mask >>= 1;
          if (reg > 65535) {
            reg &= 65535;
            reg ^= poly;
          }
        }
      }
      return import_buffer.Buffer.from([Math.floor(reg / 256), reg % 256]);
    }
    exports.crc16 = crc16;
  }
});

// node_modules/ton-core/dist/address/Address.js
var require_Address = __commonJS({
  "node_modules/ton-core/dist/address/Address.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.address = exports.Address = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var crc16_1 = require_crc16();
    var bounceable_tag = 17;
    var non_bounceable_tag = 81;
    var test_flag = 128;
    function parseFriendlyAddress(src) {
      const data = import_buffer.Buffer.isBuffer(src) ? src : import_buffer.Buffer.from(src, "base64");
      if (data.length !== 36) {
        throw new Error("Unknown address type: byte length is not equal to 36");
      }
      const addr = data.subarray(0, 34);
      const crc = data.subarray(34, 36);
      const calcedCrc = (0, crc16_1.crc16)(addr);
      if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
        throw new Error("Invalid checksum: " + src);
      }
      let tag = addr[0];
      let isTestOnly = false;
      let isBounceable = false;
      if (tag & test_flag) {
        isTestOnly = true;
        tag = tag ^ test_flag;
      }
      if (tag !== bounceable_tag && tag !== non_bounceable_tag)
        throw "Unknown address tag";
      isBounceable = tag === bounceable_tag;
      let workchain = null;
      if (addr[1] === 255) {
        workchain = -1;
      } else {
        workchain = addr[1];
      }
      const hashPart = addr.subarray(2, 34);
      return { isTestOnly, isBounceable, workchain, hashPart };
    }
    var Address = class {
      static isAddress(src) {
        return src instanceof Address;
      }
      static isFriendly(source) {
        return source.indexOf(":") < 0;
      }
      static normalize(source) {
        if (typeof source === "string") {
          return Address.parse(source).toString();
        } else {
          return source.toString();
        }
      }
      static parse(source) {
        if (Address.isFriendly(source)) {
          return this.parseFriendly(source).address;
        } else {
          return this.parseRaw(source);
        }
      }
      static parseRaw(source) {
        let workChain = parseInt(source.split(":")[0]);
        let hash = import_buffer.Buffer.from(source.split(":")[1], "hex");
        return new Address(workChain, hash);
      }
      static parseFriendly(source) {
        if (import_buffer.Buffer.isBuffer(source)) {
          let r = parseFriendlyAddress(source);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new Address(r.workchain, r.hashPart)
          };
        } else {
          let addr = source.replace(/\-/g, "+").replace(/_/g, "/");
          let r = parseFriendlyAddress(addr);
          return {
            isBounceable: r.isBounceable,
            isTestOnly: r.isTestOnly,
            address: new Address(r.workchain, r.hashPart)
          };
        }
      }
      constructor(workChain, hash) {
        this.toRawString = () => {
          return this.workChain + ":" + this.hash.toString("hex");
        };
        this.toRaw = () => {
          const addressWithChecksum = import_buffer.Buffer.alloc(36);
          addressWithChecksum.set(this.hash);
          addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
          return addressWithChecksum;
        };
        this.toStringBuffer = (args) => {
          let testOnly = args && args.testOnly !== void 0 ? args.testOnly : false;
          let bounceable = args && args.bounceable !== void 0 ? args.bounceable : true;
          let tag = bounceable ? bounceable_tag : non_bounceable_tag;
          if (testOnly) {
            tag |= test_flag;
          }
          const addr = import_buffer.Buffer.alloc(34);
          addr[0] = tag;
          addr[1] = this.workChain;
          addr.set(this.hash, 2);
          const addressWithChecksum = import_buffer.Buffer.alloc(36);
          addressWithChecksum.set(addr);
          addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
          return addressWithChecksum;
        };
        this.toString = (args) => {
          let urlSafe = args && args.urlSafe !== void 0 ? args.urlSafe : true;
          let buffer = this.toStringBuffer(args);
          if (urlSafe) {
            return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
          } else {
            return buffer.toString("base64");
          }
        };
        this[_a] = () => this.toString();
        this.workChain = workChain;
        this.hash = hash;
        Object.freeze(this);
      }
      equals(src) {
        if (src.workChain !== this.workChain) {
          return false;
        }
        return src.hash.equals(this.hash);
      }
    };
    exports.Address = Address;
    _a = symbol_inspect_1.default;
    function address(src) {
      return Address.parse(src);
    }
    exports.address = address;
  }
});

// node_modules/ton-core/dist/address/ExternalAddress.js
var require_ExternalAddress = __commonJS({
  "node_modules/ton-core/dist/address/ExternalAddress.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalAddress = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var ExternalAddress = class {
      static isAddress(src) {
        return src instanceof ExternalAddress;
      }
      constructor(value, bits) {
        this[_a] = () => this.toString();
        this.value = value;
        this.bits = bits;
      }
      toString() {
        return `External<${this.bits}:${this.value}>`;
      }
    };
    exports.ExternalAddress = ExternalAddress;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton-core/dist/utils/base32.js
var require_base32 = __commonJS({
  "node_modules/ton-core/dist/utils/base32.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base32Decode = exports.base32Encode = void 0;
    var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
    function base32Encode(buffer) {
      const length = buffer.byteLength;
      let bits = 0;
      let value = 0;
      let output = "";
      for (let i = 0; i < length; i++) {
        value = value << 8 | buffer[i];
        bits += 8;
        while (bits >= 5) {
          output += alphabet[value >>> bits - 5 & 31];
          bits -= 5;
        }
      }
      if (bits > 0) {
        output += alphabet[value << 5 - bits & 31];
      }
      return output;
    }
    exports.base32Encode = base32Encode;
    function readChar(alphabet2, char) {
      const idx = alphabet2.indexOf(char);
      if (idx === -1) {
        throw new Error("Invalid character found: " + char);
      }
      return idx;
    }
    function base32Decode(input) {
      let cleanedInput;
      cleanedInput = input.toLowerCase();
      const { length } = cleanedInput;
      let bits = 0;
      let value = 0;
      let index = 0;
      const output = import_buffer.Buffer.alloc(length * 5 / 8 | 0);
      for (let i = 0; i < length; i++) {
        value = value << 5 | readChar(alphabet, cleanedInput[i]);
        bits += 5;
        if (bits >= 8) {
          output[index++] = value >>> bits - 8 & 255;
          bits -= 8;
        }
      }
      return output;
    }
    exports.base32Decode = base32Decode;
  }
});

// node_modules/ton-core/dist/address/ADNLAddress.js
var require_ADNLAddress = __commonJS({
  "node_modules/ton-core/dist/address/ADNLAddress.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADNLAddress = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var base32_1 = require_base32();
    var crc16_1 = require_crc16();
    var ADNLAddress = class {
      static parseFriendly(src) {
        if (src.length !== 55) {
          throw Error("Invalid address");
        }
        src = "f" + src;
        let decoded = (0, base32_1.base32Decode)(src);
        if (decoded[0] !== 45) {
          throw Error("Invalid address");
        }
        let gotHash = decoded.slice(33);
        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
        if (!hash.equals(gotHash)) {
          throw Error("Invalid address");
        }
        return new ADNLAddress(decoded.slice(1, 33));
      }
      static parseRaw(src) {
        const data = import_buffer.Buffer.from(src, "base64");
        return new ADNLAddress(data);
      }
      constructor(address) {
        this.toRaw = () => {
          return this.address.toString("hex").toUpperCase();
        };
        this.toString = () => {
          let data = import_buffer.Buffer.concat([import_buffer.Buffer.from([45]), this.address]);
          let hash = (0, crc16_1.crc16)(data);
          data = import_buffer.Buffer.concat([data, hash]);
          return (0, base32_1.base32Encode)(data).slice(1);
        };
        this[_a] = () => this.toString();
        if (address.length !== 32) {
          throw Error("Invalid address");
        }
        this.address = address;
      }
      equals(b) {
        return this.address.equals(b.address);
      }
    };
    exports.ADNLAddress = ADNLAddress;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton-core/dist/boc/utils/paddedBits.js
var require_paddedBits = __commonJS({
  "node_modules/ton-core/dist/boc/utils/paddedBits.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsToPaddedBuffer = void 0;
    var BitBuilder_1 = require_BitBuilder();
    function bitsToPaddedBuffer(bits) {
      let builder = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
      builder.writeBits(bits);
      let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
      for (let i = 0; i < padding; i++) {
        if (i === 0) {
          builder.writeBit(1);
        } else {
          builder.writeBit(0);
        }
      }
      return builder.buffer();
    }
    exports.bitsToPaddedBuffer = bitsToPaddedBuffer;
  }
});

// node_modules/ton-core/dist/boc/BitString.js
var require_BitString = __commonJS({
  "node_modules/ton-core/dist/boc/BitString.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitString = void 0;
    var paddedBits_1 = require_paddedBits();
    var symbol_inspect_1 = __importDefault(require_symbol());
    var BitString = class {
      /**
       * Constructing BitString from a buffer
       * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
       * @param offset offset in bits from the start of the buffer
       * @param length length of the bitstring in bits
       */
      constructor(data, offset, length) {
        this[_a] = () => this.toString();
        if (length < 0) {
          throw new Error(`Length ${length} is out of bounds`);
        }
        this._length = length;
        this._data = data;
        this._offset = offset;
      }
      /**
       * Returns the length of the bitstring
       */
      get length() {
        return this._length;
      }
      /**
       * Returns the bit at the specified index
       * @param index index of the bit
       * @throws Error if index is out of bounds
       * @returns true if the bit is set, false otherwise
       */
      at(index) {
        if (index >= this._length) {
          throw new Error(`Index ${index} > ${this._length} is out of bounds`);
        }
        if (index < 0) {
          throw new Error(`Index ${index} < 0 is out of bounds`);
        }
        let byteIndex = this._offset + index >> 3;
        let bitIndex = 7 - (this._offset + index) % 8;
        return (this._data[byteIndex] & 1 << bitIndex) !== 0;
      }
      /**
       * Get a subscring of the bitstring
       * @param offset
       * @param length
       * @returns
       */
      substring(offset, length) {
        if (offset >= this._length) {
          throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
        }
        if (offset < 0) {
          throw new Error(`Offset(${offset}) < 0 is out of bounds`);
        }
        if (length === 0) {
          return BitString.EMPTY;
        }
        if (offset + length > this._length) {
          throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
        }
        return new BitString(this._data, this._offset + offset, length);
      }
      /**
       * Try to get a buffer from the bitstring without allocations
       * @param offset offset in bits
       * @param length length in bits
       * @returns buffer if the bitstring is aligned to bytes, null otherwise
       */
      subbuffer(offset, length) {
        if (offset >= this._length) {
          throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset < 0) {
          throw new Error(`Offset ${offset} is out of bounds`);
        }
        if (offset + length > this._length) {
          throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
        }
        if (length % 8 !== 0) {
          return null;
        }
        if ((this._offset + offset) % 8 !== 0) {
          return null;
        }
        let start = this._offset + offset >> 3;
        let end = start + (length >> 3);
        return this._data.subarray(start, end);
      }
      /**
       * Checks for equality
       * @param b other bitstring
       * @returns true if the bitstrings are equal, false otherwise
       */
      equals(b) {
        if (this._length !== b._length) {
          return false;
        }
        for (let i = 0; i < this._length; i++) {
          if (this.at(i) !== b.at(i)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Format to canonical string
       * @returns formatted bits as a string
       */
      toString() {
        const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
        if (this._length % 4 === 0) {
          const s = padded.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
          if (this._length % 8 === 0) {
            return s;
          } else {
            return s.substring(0, s.length - 1);
          }
        } else {
          const hex = padded.toString("hex").toUpperCase();
          if (this._length % 8 <= 4) {
            return hex.substring(0, hex.length - 1) + "_";
          } else {
            return hex + "_";
          }
        }
      }
    };
    exports.BitString = BitString;
    _a = symbol_inspect_1.default;
    BitString.EMPTY = new BitString(import_buffer.Buffer.alloc(0), 0, 0);
  }
});

// node_modules/ton-core/dist/boc/BitBuilder.js
var require_BitBuilder = __commonJS({
  "node_modules/ton-core/dist/boc/BitBuilder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitBuilder = void 0;
    var Address_1 = require_Address();
    var ExternalAddress_1 = require_ExternalAddress();
    var BitString_1 = require_BitString();
    var BitBuilder = class {
      constructor(size = 1023) {
        this._buffer = import_buffer.Buffer.alloc(Math.ceil(size / 8));
        this._length = 0;
      }
      /**
       * Current number of bits written
       */
      get length() {
        return this._length;
      }
      /**
       * Write a single bit
       * @param value bit to write, true or positive number for 1, false or zero or negative for 0
       */
      writeBit(value) {
        let n = this._length;
        if (n > this._buffer.length * 8) {
          throw new Error("BitBuilder overflow");
        }
        if (value === true || value > 0) {
          this._buffer[n / 8 | 0] |= 1 << 7 - n % 8;
        }
        this._length++;
      }
      /**
       * Copy bits from BitString
       * @param src source bits
       */
      writeBits(src) {
        for (let i = 0; i < src.length; i++) {
          this.writeBit(src.at(i));
        }
      }
      /**
       * Write bits from buffer
       * @param src source buffer
       */
      writeBuffer(src) {
        if (this._length % 8 === 0) {
          if (this._length + src.length * 8 > this._buffer.length * 8) {
            throw new Error("BitBuilder overflow");
          }
          src.copy(this._buffer, this._length / 8);
          this._length += src.length * 8;
        } else {
          for (let i = 0; i < src.length; i++) {
            this.writeUint(src[i], 8);
          }
        }
      }
      /**
       * Write uint value
       * @param value value as bigint or number
       * @param bits number of bits to write
       */
      writeUint(value, bits) {
        if (bits === 8 && this._length % 8 === 0) {
          let v2 = Number(value);
          if (v2 < 0 || v2 > 255 || !Number.isSafeInteger(v2)) {
            throw Error(`value is out of range for ${bits} bits. Got ${value}`);
          }
          this._buffer[this._length / 8] = Number(value);
          this._length += 8;
          return;
        }
        if (bits === 16 && this._length % 8 === 0) {
          let v2 = Number(value);
          if (v2 < 0 || v2 > 65536 || !Number.isSafeInteger(v2)) {
            throw Error(`value is out of range for ${bits} bits. Got ${value}`);
          }
          this._buffer[this._length / 8] = v2 >> 8;
          this._buffer[this._length / 8 + 1] = v2 & 255;
          this._length += 16;
          return;
        }
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (bits === 0) {
          if (value !== 0n) {
            throw Error(`value is not zero for ${bits} bits. Got ${value}`);
          } else {
            return;
          }
        }
        let vBits = 1n << BigInt(bits);
        if (v < 0 || v >= vBits) {
          throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
        }
        let b = [];
        while (v > 0) {
          b.push(v % 2n === 1n);
          v /= 2n;
        }
        for (let i = 0; i < bits; i++) {
          let off = bits - i - 1;
          if (off < b.length) {
            this.writeBit(b[off]);
          } else {
            this.writeBit(false);
          }
        }
      }
      /**
       * Write int value
       * @param value value as bigint or number
       * @param bits number of bits to write
       */
      writeInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (bits === 0) {
          if (value !== 0n) {
            throw Error(`value is not zero for ${bits} bits. Got ${value}`);
          } else {
            return;
          }
        }
        if (bits === 1) {
          if (value !== -1n && value !== 0n) {
            throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
          } else {
            this.writeBit(value === -1n);
            return;
          }
        }
        let vBits = 1n << BigInt(bits) - 1n;
        if (v < -vBits || v >= vBits) {
          throw Error(`value is out of range for ${bits} bits. Got ${value}`);
        }
        if (v < 0) {
          this.writeBit(true);
          v = vBits + v;
        } else {
          this.writeBit(false);
        }
        this.writeUint(v, bits - 1);
      }
      /**
       * Wrtie var uint value, used for serializing coins
       * @param value value to write as bigint or number
       * @param bits header bits to write size
       */
      writeVarUint(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (v < 0) {
          throw Error(`value is negative. Got ${value}`);
        }
        if (v === 0n) {
          this.writeUint(0, bits);
          return;
        }
        const sizeBytes = Math.ceil(v.toString(2).length / 8);
        const sizeBits = sizeBytes * 8;
        this.writeUint(sizeBytes, bits);
        this.writeUint(v, sizeBits);
      }
      /**
       * Wrtie var int value, used for serializing coins
       * @param value value to write as bigint or number
       * @param bits header bits to write size
       */
      writeVarInt(value, bits) {
        let v = BigInt(value);
        if (bits < 0 || !Number.isSafeInteger(bits)) {
          throw Error(`invalid bit length. Got ${bits}`);
        }
        if (v === 0n) {
          this.writeUint(0, bits);
          return;
        }
        let v2 = v > 0 ? v : -v;
        const sizeBytes = 1 + Math.ceil(v2.toString(2).length / 8);
        const sizeBits = sizeBytes * 8;
        this.writeUint(sizeBytes, bits);
        this.writeInt(v, sizeBits);
      }
      /**
       * Write coins in var uint format
       * @param amount amount to write
       */
      writeCoins(amount) {
        this.writeVarUint(amount, 4);
      }
      /**
       * Write address
       * @param address write address or address external
       */
      writeAddress(address) {
        if (address === null || address === void 0) {
          this.writeUint(0, 2);
          return;
        }
        if (Address_1.Address.isAddress(address)) {
          this.writeUint(2, 2);
          this.writeUint(0, 1);
          this.writeInt(address.workChain, 8);
          this.writeBuffer(address.hash);
          return;
        }
        if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
          this.writeUint(1, 2);
          this.writeUint(address.bits, 9);
          this.writeUint(address.value, address.bits);
          return;
        }
        throw Error(`Invalid address. Got ${address}`);
      }
      /**
       * Build BitString
       * @returns result bit string
       */
      build() {
        return new BitString_1.BitString(this._buffer, 0, this._length);
      }
      /**
       * Build into Buffer
       * @returns result buffer
       */
      buffer() {
        if (this._length % 8 !== 0) {
          throw new Error("BitBuilder buffer is not byte aligned");
        }
        return this._buffer.subarray(0, this._length / 8);
      }
    };
    exports.BitBuilder = BitBuilder;
  }
});

// node_modules/ton-core/dist/boc/CellType.js
var require_CellType = __commonJS({
  "node_modules/ton-core/dist/boc/CellType.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CellType = void 0;
    var CellType;
    (function(CellType2) {
      CellType2[CellType2["Ordinary"] = -1] = "Ordinary";
      CellType2[CellType2["PrunedBranch"] = 1] = "PrunedBranch";
      CellType2[CellType2["Library"] = 2] = "Library";
      CellType2[CellType2["MerkleProof"] = 3] = "MerkleProof";
      CellType2[CellType2["MerkleUpdate"] = 4] = "MerkleUpdate";
    })(CellType = exports.CellType || (exports.CellType = {}));
  }
});

// node_modules/ton-core/dist/dict/parseDict.js
var require_parseDict = __commonJS({
  "node_modules/ton-core/dist/dict/parseDict.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseDict = void 0;
    function readUnaryLength(slice) {
      let res = 0;
      while (slice.loadBit()) {
        res++;
      }
      return res;
    }
    function doParse(prefix, slice, n, res, extractor) {
      let lb0 = slice.loadBit() ? 1 : 0;
      let prefixLength = 0;
      let pp = prefix;
      if (lb0 === 0) {
        prefixLength = readUnaryLength(slice);
        for (let i = 0; i < prefixLength; i++) {
          pp += slice.loadBit() ? "1" : "0";
        }
      } else {
        let lb1 = slice.loadBit() ? 1 : 0;
        if (lb1 === 0) {
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += slice.loadBit() ? "1" : "0";
          }
        } else {
          let bit = slice.loadBit() ? "1" : "0";
          prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
          for (let i = 0; i < prefixLength; i++) {
            pp += bit;
          }
        }
      }
      if (n - prefixLength === 0) {
        res.set(BigInt("0b" + pp), extractor(slice));
      } else {
        let left = slice.loadRef();
        let right = slice.loadRef();
        if (!left.isExotic) {
          doParse(pp + "0", left.beginParse(), n - prefixLength - 1, res, extractor);
        }
        if (!right.isExotic) {
          doParse(pp + "1", right.beginParse(), n - prefixLength - 1, res, extractor);
        }
      }
    }
    function parseDict(sc, keySize, extractor) {
      let res = /* @__PURE__ */ new Map();
      if (sc) {
        doParse("", sc, keySize, res, extractor);
      }
      return res;
    }
    exports.parseDict = parseDict;
  }
});

// node_modules/ton-core/dist/dict/utils/findCommonPrefix.js
var require_findCommonPrefix = __commonJS({
  "node_modules/ton-core/dist/dict/utils/findCommonPrefix.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findCommonPrefix = void 0;
    function findCommonPrefix(src) {
      if (src.length === 0) {
        return "";
      }
      if (src.length === 1) {
        return src[0];
      }
      const sorted = [...src].sort();
      let size = 0;
      for (let i = 0; i < sorted[0].length; i++) {
        if (sorted[0][i] !== sorted[sorted.length - 1][i]) {
          break;
        }
        size++;
      }
      return src[0].slice(0, size);
    }
    exports.findCommonPrefix = findCommonPrefix;
  }
});

// node_modules/ton-core/dist/dict/serializeDict.js
var require_serializeDict = __commonJS({
  "node_modules/ton-core/dist/dict/serializeDict.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeDict = exports.detectLabelType = exports.writeLabelSame = exports.writeLabelLong = exports.writeLabelShort = exports.buildTree = void 0;
    var Builder_1 = require_Builder();
    var findCommonPrefix_1 = require_findCommonPrefix();
    function pad(src, size) {
      while (src.length < size) {
        src = "0" + src;
      }
      return src;
    }
    function removePrefixMap(src, length) {
      if (length === 0) {
        return src;
      } else {
        let res = /* @__PURE__ */ new Map();
        for (let k of src.keys()) {
          let d = src.get(k);
          res.set(k.slice(length), d);
        }
        return res;
      }
    }
    function forkMap(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      let left = /* @__PURE__ */ new Map();
      let right = /* @__PURE__ */ new Map();
      for (let k of src.keys()) {
        let d = src.get(k);
        if (k.startsWith("0")) {
          left.set(k.substr(1), d);
        } else {
          right.set(k.substr(1), d);
        }
      }
      if (left.size === 0) {
        throw Error("Internal inconsistency. Left emtpy.");
      }
      if (right.size === 0) {
        throw Error("Internal inconsistency. Right emtpy.");
      }
      return { left, right };
    }
    function buildNode(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      if (src.size === 1) {
        return { type: "leaf", value: Array.from(src.values())[0] };
      }
      let { left, right } = forkMap(src);
      return {
        type: "fork",
        left: buildEdge(left),
        right: buildEdge(right)
      };
    }
    function buildEdge(src) {
      if (src.size === 0) {
        throw Error("Internal inconsistency");
      }
      const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()));
      return { label, node: buildNode(removePrefixMap(src, label.length)) };
    }
    function buildTree(src, keyLength) {
      let converted = /* @__PURE__ */ new Map();
      for (let k of Array.from(src.keys())) {
        const padded = pad(k.toString(2), keyLength);
        converted.set(padded, src.get(k));
      }
      return buildEdge(converted);
    }
    exports.buildTree = buildTree;
    function writeLabelShort(src, to) {
      to.storeBit(0);
      for (let i = 0; i < src.length; i++) {
        to.storeBit(1);
      }
      to.storeBit(0);
      for (let i = 0; i < src.length; i++) {
        to.storeBit(src[i] === "1");
      }
      return to;
    }
    exports.writeLabelShort = writeLabelShort;
    function labelShortLength(src) {
      return 1 + src.length + 1 + src.length;
    }
    function writeLabelLong(src, keyLength, to) {
      to.storeBit(1);
      to.storeBit(0);
      let length = Math.ceil(Math.log2(keyLength + 1));
      to.storeUint(src.length, length);
      for (let i = 0; i < src.length; i++) {
        to.storeBit(src[i] === "1");
      }
      return to;
    }
    exports.writeLabelLong = writeLabelLong;
    function labelLongLength(src, keyLength) {
      return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
    }
    function writeLabelSame(value, length, keyLength, to) {
      to.storeBit(1);
      to.storeBit(1);
      to.storeBit(value);
      let lenLen = Math.ceil(Math.log2(keyLength + 1));
      to.storeUint(length, lenLen);
    }
    exports.writeLabelSame = writeLabelSame;
    function labelSameLength(keyLength) {
      return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
    }
    function isSame(src) {
      if (src.length === 0 || src.length === 1) {
        return true;
      }
      for (let i = 1; i < src.length; i++) {
        if (src[i] !== src[0]) {
          return false;
        }
      }
      return true;
    }
    function detectLabelType(src, keyLength) {
      let kind = "short";
      let kindLength = labelShortLength(src);
      let longLength = labelLongLength(src, keyLength);
      if (longLength < kindLength) {
        kindLength = longLength;
        kind = "long";
      }
      if (isSame(src)) {
        let sameLength = labelSameLength(keyLength);
        if (sameLength < kindLength) {
          kindLength = sameLength;
          kind = "same";
        }
      }
      return kind;
    }
    exports.detectLabelType = detectLabelType;
    function writeLabel(src, keyLength, to) {
      let type = detectLabelType(src, keyLength);
      if (type === "short") {
        writeLabelShort(src, to);
      }
      if (type === "long") {
        writeLabelLong(src, keyLength, to);
      }
      if (type === "same") {
        writeLabelSame(src[0] === "1", src.length, keyLength, to);
      }
    }
    function writeNode(src, keyLength, serializer, to) {
      if (src.type === "leaf") {
        serializer(src.value, to);
      }
      if (src.type === "fork") {
        const leftCell = (0, Builder_1.beginCell)();
        const rightCell = (0, Builder_1.beginCell)();
        writeEdge(src.left, keyLength - 1, serializer, leftCell);
        writeEdge(src.right, keyLength - 1, serializer, rightCell);
        to.storeRef(leftCell);
        to.storeRef(rightCell);
      }
    }
    function writeEdge(src, keyLength, serializer, to) {
      writeLabel(src.label, keyLength, to);
      writeNode(src.node, keyLength - src.label.length, serializer, to);
    }
    function serializeDict(src, keyLength, serializer, to) {
      const tree = buildTree(src, keyLength);
      writeEdge(tree, keyLength, serializer, to);
    }
    exports.serializeDict = serializeDict;
  }
});

// node_modules/ton-core/dist/dict/utils/internalKeySerializer.js
var require_internalKeySerializer = __commonJS({
  "node_modules/ton-core/dist/dict/utils/internalKeySerializer.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeInternalKey = exports.serializeInternalKey = void 0;
    var Address_1 = require_Address();
    function serializeInternalKey(value) {
      if (typeof value === "number") {
        if (!Number.isSafeInteger(value)) {
          throw Error("Invalid key type: not a safe integer: " + value);
        }
        return "n:" + value.toString(10);
      } else if (typeof value === "bigint") {
        return "b:" + value.toString(10);
      } else if (Address_1.Address.isAddress(value)) {
        return "a:" + value.toString();
      } else if (import_buffer.Buffer.isBuffer(value)) {
        return "f:" + value.toString("hex");
      } else {
        throw Error("Invalid key type");
      }
    }
    exports.serializeInternalKey = serializeInternalKey;
    function deserializeInternalKey(value) {
      let k = value.slice(0, 2);
      let v = value.slice(2);
      if (k === "n:") {
        return parseInt(v, 10);
      } else if (k === "b:") {
        return BigInt(v);
      } else if (k === "a:") {
        return Address_1.Address.parse(v);
      } else if (k === "f:") {
        return import_buffer.Buffer.from(v, "hex");
      }
      throw Error("Invalid key type: " + k);
    }
    exports.deserializeInternalKey = deserializeInternalKey;
  }
});

// node_modules/ton-core/dist/dict/Dictionary.js
var require_Dictionary = __commonJS({
  "node_modules/ton-core/dist/dict/Dictionary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dictionary = void 0;
    var Address_1 = require_Address();
    var Builder_1 = require_Builder();
    var Cell_1 = require_Cell();
    var parseDict_1 = require_parseDict();
    var serializeDict_1 = require_serializeDict();
    var internalKeySerializer_1 = require_internalKeySerializer();
    var Dictionary = class {
      /**
       * Create an empty map
       * @param key key type
       * @param value value type
       * @returns Dictionary<K, V>
       */
      static empty(key, value) {
        if (key && value) {
          return new Dictionary(/* @__PURE__ */ new Map(), key, value);
        } else {
          return new Dictionary(/* @__PURE__ */ new Map(), null, null);
        }
      }
      /**
       * Load dictionary from slice
       * @param key key description
       * @param value value description
       * @param src slice
       * @returns Dictionary<K, V>
       */
      static load(key, value, sc) {
        let slice;
        if (sc instanceof Cell_1.Cell) {
          if (sc.isExotic) {
            return Dictionary.empty(key, value);
          }
          slice = sc.beginParse();
        } else {
          slice = sc;
        }
        let cell = slice.loadMaybeRef();
        if (cell && !cell.isExotic) {
          return Dictionary.loadDirect(key, value, cell.beginParse());
        } else {
          return Dictionary.empty(key, value);
        }
      }
      /**
       * Low level method for rare dictionaries from system contracts.
       * Loads dictionary from slice directly without going to the ref.
       *
       * @param key key description
       * @param value value description
       * @param sc slice
       * @returns Dictionary<K, V>
       */
      static loadDirect(key, value, sc) {
        if (!sc) {
          return Dictionary.empty(key, value);
        }
        let slice;
        if (sc instanceof Cell_1.Cell) {
          slice = sc.beginParse();
        } else {
          slice = sc;
        }
        let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
        let prepare = /* @__PURE__ */ new Map();
        for (let [k, v] of values) {
          prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);
        }
        return new Dictionary(prepare, key, value);
      }
      constructor(values, key, value) {
        this._key = key;
        this._value = value;
        this._map = values;
      }
      get size() {
        return this._map.size;
      }
      get(key) {
        return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
      }
      has(key) {
        return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
      }
      set(key, value) {
        this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
        return this;
      }
      delete(key) {
        const k = (0, internalKeySerializer_1.serializeInternalKey)(key);
        return this._map.delete(k);
      }
      clear() {
        this._map.clear();
      }
      *[Symbol.iterator]() {
        for (const [k, v] of this._map) {
          const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);
          yield [key, v];
        }
      }
      keys() {
        return Array.from(this._map.keys()).map((v) => (0, internalKeySerializer_1.deserializeInternalKey)(v));
      }
      values() {
        return Array.from(this._map.values());
      }
      store(builder, key, value) {
        if (this._map.size === 0) {
          builder.storeBit(0);
        } else {
          let resolvedKey = this._key;
          if (key !== null && key !== void 0) {
            resolvedKey = key;
          }
          let resolvedValue = this._value;
          if (value !== null && value !== void 0) {
            resolvedValue = value;
          }
          if (!resolvedKey) {
            throw Error("Key serializer is not defined");
          }
          if (!resolvedValue) {
            throw Error("Value serializer is not defined");
          }
          let prepared = /* @__PURE__ */ new Map();
          for (const [k, v] of this._map) {
            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
          }
          builder.storeBit(1);
          let dd = (0, Builder_1.beginCell)();
          (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
          builder.storeRef(dd.endCell());
        }
      }
      storeDirect(builder, key, value) {
        if (this._map.size === 0) {
          throw Error("Cannot store empty dictionary directly");
        }
        let resolvedKey = this._key;
        if (key !== null && key !== void 0) {
          resolvedKey = key;
        }
        let resolvedValue = this._value;
        if (value !== null && value !== void 0) {
          resolvedValue = value;
        }
        if (!resolvedKey) {
          throw Error("Key serializer is not defined");
        }
        if (!resolvedValue) {
          throw Error("Value serializer is not defined");
        }
        let prepared = /* @__PURE__ */ new Map();
        for (const [k, v] of this._map) {
          prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
        }
        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);
      }
    };
    exports.Dictionary = Dictionary;
    Dictionary.Keys = {
      /**
       * Standard address key
       * @returns DictionaryKey<Address>
       */
      Address: () => {
        return createAddressKey();
      },
      /**
       * Create standard big integer key
       * @param bits number of bits
       * @returns DictionaryKey<bigint>
       */
      BigInt: (bits) => {
        return createBigIntKey(bits);
      },
      /**
       * Create integer key
       * @param bits bits of integer
       * @returns DictionaryKey<number>
       */
      Int: (bits) => {
        return createIntKey(bits);
      },
      /**
       * Create standard unsigned big integer key
       * @param bits number of bits
       * @returns DictionaryKey<bigint>
       */
      BigUint: (bits) => {
        return createBigUintKey(bits);
      },
      /**
       * Create standard unsigned integer key
       * @param bits number of bits
       * @returns DictionaryKey<number>
       */
      Uint: (bits) => {
        return createUintKey(bits);
      },
      /**
       * Create standard buffer key
       * @param bytes number of bytes of a buffer
       * @returns DictionaryKey<Buffer>
       */
      Buffer: (bytes) => {
        return createBufferKey(bytes);
      }
    };
    Dictionary.Values = {
      /**
       * Create standard integer value
       * @returns DictionaryValue<bigint>
       */
      BigInt: (bits) => {
        return createBigIntValue(bits);
      },
      /**
       * Create standard integer value
       * @returns DictionaryValue<number>
       */
      Int: (bits) => {
        return createIntValue(bits);
      },
      /**
       * Create big var int
       * @param bits nubmer of header bits
       * @returns DictionaryValue<bigint>
       */
      BigVarInt: (bits) => {
        return createBigVarIntValue(bits);
      },
      /**
       * Create standard unsigned integer value
       * @param bits number of bits
       * @returns DictionaryValue<bigint>
       */
      BigUint: (bits) => {
        return createBigUintValue(bits);
      },
      /**
       * Create standard unsigned integer value
       * @param bits number of bits
       * @returns DictionaryValue<bigint>
       */
      Uint: (bits) => {
        return createUintValue(bits);
      },
      /**
       * Create big var int
       * @param bits nubmer of header bits
       * @returns DictionaryValue<bigint>
       */
      BigVarUint: (bits) => {
        return createBigVarUintValue(bits);
      },
      /**
       * Create standard boolean value
       * @returns DictionaryValue<boolean>
       */
      Bool: () => {
        return createBooleanValue();
      },
      /**
       * Create standard address value
       * @returns DictionaryValue<Address>
       */
      Address: () => {
        return createAddressValue();
      },
      /**
       * Create standard cell value
       * @returns DictionaryValue<Cell>
       */
      Cell: () => {
        return createCellValue();
      },
      /**
       * Create Builder value
       * @param bytes number of bytes of a buffer
       * @returns DictionaryValue<Builder>
       */
      Buffer: (bytes) => {
        return createBufferValue(bytes);
      },
      /**
       * Create dictionary value
       * @param key
       * @param value
       */
      Dictionary: (key, value) => {
        return createDictionaryValue(key, value);
      }
    };
    function createAddressKey() {
      return {
        bits: 267,
        serialize: (src) => {
          if (!Address_1.Address.isAddress(src)) {
            throw Error("Key is not an address");
          }
          return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
        }
      };
    }
    function createBigIntKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "bigint") {
            throw Error("Key is not a bigint");
          }
          return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
        }
      };
    }
    function createIntKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "number") {
            throw Error("Key is not a number");
          }
          if (!Number.isSafeInteger(src)) {
            throw Error("Key is not a safe integer: " + src);
          }
          return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
        }
      };
    }
    function createBigUintKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "bigint") {
            throw Error("Key is not a bigint");
          }
          if (src < 0) {
            throw Error("Key is negative: " + src);
          }
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        }
      };
    }
    function createUintKey(bits) {
      return {
        bits,
        serialize: (src) => {
          if (typeof src !== "number") {
            throw Error("Key is not a number");
          }
          if (!Number.isSafeInteger(src)) {
            throw Error("Key is not a safe integer: " + src);
          }
          if (src < 0) {
            throw Error("Key is negative: " + src);
          }
          return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
        },
        parse: (src) => {
          return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
        }
      };
    }
    function createBufferKey(bytes) {
      return {
        bits: bytes * 8,
        serialize: (src) => {
          if (!import_buffer.Buffer.isBuffer(src)) {
            throw Error("Key is not a buffer");
          }
          return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
        },
        parse: (src) => {
          return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
        }
      };
    }
    function createIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeInt(src, bits);
        },
        parse: (src) => {
          return src.loadInt(bits);
        }
      };
    }
    function createBigIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeInt(src, bits);
        },
        parse: (src) => {
          return src.loadIntBig(bits);
        }
      };
    }
    function createBigVarIntValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeVarInt(src, bits);
        },
        parse: (src) => {
          return src.loadVarIntBig(bits);
        }
      };
    }
    function createBigVarUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeVarUint(src, bits);
        },
        parse: (src) => {
          return src.loadVarUintBig(bits);
        }
      };
    }
    function createUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeUint(src, bits);
        },
        parse: (src) => {
          return src.loadUint(bits);
        }
      };
    }
    function createBigUintValue(bits) {
      return {
        serialize: (src, buidler) => {
          buidler.storeUint(src, bits);
        },
        parse: (src) => {
          return src.loadUintBig(bits);
        }
      };
    }
    function createBooleanValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeBit(src);
        },
        parse: (src) => {
          return src.loadBit();
        }
      };
    }
    function createAddressValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeAddress(src);
        },
        parse: (src) => {
          return src.loadAddress();
        }
      };
    }
    function createCellValue() {
      return {
        serialize: (src, buidler) => {
          buidler.storeRef(src);
        },
        parse: (src) => {
          return src.loadRef();
        }
      };
    }
    function createDictionaryValue(key, value) {
      return {
        serialize: (src, buidler) => {
          src.store(buidler);
        },
        parse: (src) => {
          return Dictionary.load(key, value, src);
        }
      };
    }
    function createBufferValue(size) {
      return {
        serialize: (src, buidler) => {
          if (src.length !== size) {
            throw Error("Invalid buffer size");
          }
          buidler.storeBuffer(src);
        },
        parse: (src) => {
          return src.loadBuffer(size);
        }
      };
    }
  }
});

// node_modules/ton-core/dist/boc/utils/strings.js
var require_strings = __commonJS({
  "node_modules/ton-core/dist/boc/utils/strings.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeString = exports.stringToCell = exports.readString = void 0;
    var Builder_1 = require_Builder();
    function readBuffer(slice) {
      if (slice.remainingBits % 8 !== 0) {
        throw new Error(`Invalid string length: ${slice.remainingBits}`);
      }
      if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
        throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
      }
      if (slice.remainingRefs === 1 && 1023 - slice.remainingBits > 7) {
        throw new Error(`invalid string length: ${slice.remainingBits / 8}`);
      }
      let res;
      if (slice.remainingBits === 0) {
        res = import_buffer.Buffer.alloc(0);
      } else {
        res = slice.loadBuffer(slice.remainingBits / 8);
      }
      if (slice.remainingRefs === 1) {
        res = import_buffer.Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
      }
      return res;
    }
    function readString(slice) {
      return readBuffer(slice).toString();
    }
    exports.readString = readString;
    function writeBuffer(src, builder) {
      if (src.length > 0) {
        let bytes = Math.floor(builder.availableBits / 8);
        if (src.length > bytes) {
          let a = src.subarray(0, bytes);
          let t = src.subarray(bytes);
          builder = builder.storeBuffer(a);
          let bb = (0, Builder_1.beginCell)();
          writeBuffer(t, bb);
          builder = builder.storeRef(bb.endCell());
        } else {
          builder = builder.storeBuffer(src);
        }
      }
    }
    function stringToCell(src) {
      let builder = (0, Builder_1.beginCell)();
      writeBuffer(import_buffer.Buffer.from(src), builder);
      return builder.endCell();
    }
    exports.stringToCell = stringToCell;
    function writeString(src, builder) {
      writeBuffer(import_buffer.Buffer.from(src), builder);
    }
    exports.writeString = writeString;
  }
});

// node_modules/ton-core/dist/boc/Slice.js
var require_Slice = __commonJS({
  "node_modules/ton-core/dist/boc/Slice.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slice = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var Dictionary_1 = require_Dictionary();
    var Builder_1 = require_Builder();
    var strings_1 = require_strings();
    var Slice = class {
      constructor(reader, refs) {
        this[_a] = () => this.toString();
        this._reader = reader.clone();
        this._refs = [...refs];
        this._refsOffset = 0;
      }
      /**
       * Get remaining bits
       */
      get remainingBits() {
        return this._reader.remaining;
      }
      /**
       * Get offset bits
       */
      get offsetBits() {
        return this._reader.offset;
      }
      /**
       * Get remaining refs
       */
      get remainingRefs() {
        return this._refs.length - this._refsOffset;
      }
      /**
       * Get offset refs
       */
      get offsetRefs() {
        return this._refsOffset;
      }
      /**
       * Skip bits
       * @param bits
       */
      skip(bits) {
        this._reader.skip(bits);
        return this;
      }
      /**
       * Load a single bit
       * @returns true or false depending on the bit value
       */
      loadBit() {
        return this._reader.loadBit();
      }
      /**
       * Preload a signle bit
       * @returns true or false depending on the bit value
       */
      preloadBit() {
        return this._reader.preloadBit();
      }
      /**
       * Load a boolean
       * @returns true or false depending on the bit value
       */
      loadBoolean() {
        return this.loadBit();
      }
      /**
       * Load maybe boolean
       * @returns true or false depending on the bit value or null
       */
      loadMaybeBoolean() {
        if (this.loadBit()) {
          return this.loadBoolean();
        } else {
          return null;
        }
      }
      /**
       * Load bits as a new BitString
       * @param bits number of bits to read
       * @returns new BitString
       */
      loadBits(bits) {
        return this._reader.loadBits(bits);
      }
      /**
       * Preload bits as a new BitString
       * @param bits number of bits to read
       * @returns new BitString
       */
      preloadBits(bits) {
        return this._reader.preloadBits(bits);
      }
      /**
       * Load uint
       * @param bits number of bits to read
       * @returns uint value
       */
      loadUint(bits) {
        return this._reader.loadUint(bits);
      }
      /**
       * Load uint
       * @param bits number of bits to read
       * @returns uint value
       */
      loadUintBig(bits) {
        return this._reader.loadUintBig(bits);
      }
      /**
       * Preload uint
       * @param bits number of bits to read
       * @returns uint value
       */
      preloadUint(bits) {
        return this._reader.preloadUint(bits);
      }
      /**
       * Preload uint
       * @param bits number of bits to read
       * @returns uint value
       */
      preloadUintBig(bits) {
        return this._reader.preloadUintBig(bits);
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeUint(bits) {
        if (this.loadBit()) {
          return this.loadUint(bits);
        } else {
          return null;
        }
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeUintBig(bits) {
        if (this.loadBit()) {
          return this.loadUintBig(bits);
        } else {
          return null;
        }
      }
      /**
       * Load int
       * @param bits number of bits to read
       * @returns int value
       */
      loadInt(bits) {
        return this._reader.loadInt(bits);
      }
      /**
       * Load int
       * @param bits number of bits to read
       * @returns int value
       */
      loadIntBig(bits) {
        return this._reader.loadIntBig(bits);
      }
      /**
       * Preload int
       * @param bits number of bits to read
       * @returns int value
       */
      preloadInt(bits) {
        return this._reader.preloadInt(bits);
      }
      /**
       * Preload int
       * @param bits number of bits to read
       * @returns int value
       */
      preloadIntBig(bits) {
        return this._reader.preloadIntBig(bits);
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeInt(bits) {
        if (this.loadBit()) {
          return this.loadInt(bits);
        } else {
          return null;
        }
      }
      /**
       * Load maybe uint
       * @param bits number of bits to read
       * @returns uint value or null
       */
      loadMaybeIntBig(bits) {
        if (this.loadBit()) {
          return this.loadIntBig(bits);
        } else {
          return null;
        }
      }
      /**
       * Load varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      loadVarUint(bits) {
        return this._reader.loadVarUint(bits);
      }
      /**
       * Load varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      loadVarUintBig(bits) {
        return this._reader.loadVarUintBig(bits);
      }
      /**
       * Preload varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      preloadVarUint(bits) {
        return this._reader.preloadVarUint(bits);
      }
      /**
       * Preload varuint
       * @param bits number of bits to read in header
       * @returns varuint value
       */
      preloadVarUintBig(bits) {
        return this._reader.preloadVarUintBig(bits);
      }
      /**
       * Load varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      loadVarInt(bits) {
        return this._reader.loadVarInt(bits);
      }
      /**
       * Load varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      loadVarIntBig(bits) {
        return this._reader.loadVarIntBig(bits);
      }
      /**
       * Preload varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      preloadVarInt(bits) {
        return this._reader.preloadVarInt(bits);
      }
      /**
       * Preload varint
       * @param bits number of bits to read in header
       * @returns varint value
       */
      preloadVarIntBig(bits) {
        return this._reader.preloadVarIntBig(bits);
      }
      /**
       * Load coins
       * @returns coins value
       */
      loadCoins() {
        return this._reader.loadCoins();
      }
      /**
       * Preload coins
       * @returns coins value
       */
      preloadCoins() {
        return this._reader.preloadCoins();
      }
      /**
       * Load maybe coins
       * @returns coins value or null
       */
      loadMaybeCoins() {
        if (this._reader.loadBit()) {
          return this._reader.loadCoins();
        } else {
          return null;
        }
      }
      /**
       * Load internal Address
       * @returns Address
       */
      loadAddress() {
        return this._reader.loadAddress();
      }
      /**
       * Load optional internal Address
       * @returns Address or null
       */
      loadMaybeAddress() {
        return this._reader.loadMaybeAddress();
      }
      /**
       * Load external address
       * @returns ExternalAddress
       */
      loadExternalAddress() {
        return this._reader.loadExternalAddress();
      }
      /**
       * Load optional external address
       * @returns ExternalAddress or null
       */
      loadMaybeExternalAddress() {
        return this._reader.loadMaybeExternalAddress();
      }
      /**
       * Load address
       * @returns Address, ExternalAddress or null
       */
      loadAddressAny() {
        return this._reader.loadAddressAny();
      }
      /**
       * Load reference
       * @returns Cell
       */
      loadRef() {
        if (this._refsOffset >= this._refs.length) {
          throw new Error("No more references");
        }
        return this._refs[this._refsOffset++];
      }
      /**
       * Preload reference
       * @returns Cell
       */
      preloadRef() {
        if (this._refsOffset >= this._refs.length) {
          throw new Error("No more references");
        }
        return this._refs[this._refsOffset];
      }
      /**
       * Load optional reference
       * @returns Cell or null
       */
      loadMaybeRef() {
        if (this.loadBit()) {
          return this.loadRef();
        } else {
          return null;
        }
      }
      /**
       * Preload optional reference
       * @returns Cell or null
       */
      preloadMaybeRef() {
        if (this.preloadBit()) {
          return this.preloadRef();
        } else {
          return null;
        }
      }
      /**
       * Load byte buffer
       * @param bytes number of bytes to load
       * @returns Buffer
       */
      loadBuffer(bytes) {
        return this._reader.loadBuffer(bytes);
      }
      /**
       * Load byte buffer
       * @param bytes number of bytes to load
       * @returns Buffer
       */
      preloadBuffer(bytes) {
        return this._reader.preloadBuffer(bytes);
      }
      /**
       * Load string tail
       */
      loadStringTail() {
        return (0, strings_1.readString)(this);
      }
      /**
       * Load maybe string tail
       * @returns string or null
       */
      loadMaybeStringTail() {
        if (this.loadBit()) {
          return (0, strings_1.readString)(this);
        } else {
          return null;
        }
      }
      /**
       * Load string tail from ref
       * @returns string
       */
      loadStringRefTail() {
        return (0, strings_1.readString)(this.loadRef().beginParse());
      }
      /**
       * Load maybe string tail from ref
       * @returns string or null
       */
      loadMaybeStringRefTail() {
        const ref = this.loadMaybeRef();
        if (ref) {
          return (0, strings_1.readString)(ref.beginParse());
        } else {
          return null;
        }
      }
      /**
       * Loads dictionary
       * @param key key description
       * @param value value description
       * @returns Dictionary<K, V>
       */
      loadDict(key, value) {
        return Dictionary_1.Dictionary.load(key, value, this);
      }
      /**
       * Loads dictionary directly from current slice
       * @param key key description
       * @param value value description
       * @returns Dictionary<K, V>
       */
      loadDictDirect(key, value) {
        return Dictionary_1.Dictionary.loadDirect(key, value, this);
      }
      /**
       * Checks if slice is empty
       */
      endParse() {
        if (this.remainingBits > 0 || this.remainingRefs > 0) {
          throw new Error("Slice is not empty");
        }
      }
      /**
       * Convert slice to cell
       */
      asCell() {
        return (0, Builder_1.beginCell)().storeSlice(this).endCell();
      }
      /**
       *
       * @returns
       */
      asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this);
      }
      /**
       * Clone slice
       * @returns cloned slice
       */
      clone(fromStart = false) {
        if (fromStart) {
          let reader = this._reader.clone();
          reader.reset();
          return new Slice(reader, this._refs);
        } else {
          let res = new Slice(this._reader, this._refs);
          res._refsOffset = this._refsOffset;
          return res;
        }
      }
      /**
       * Print slice as string by converting it to cell
       * @returns string
       */
      toString() {
        return this.asCell().toString();
      }
    };
    exports.Slice = Slice;
    _a = symbol_inspect_1.default;
  }
});

// node_modules/ton-core/dist/boc/BitReader.js
var require_BitReader = __commonJS({
  "node_modules/ton-core/dist/boc/BitReader.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BitReader = void 0;
    var Address_1 = require_Address();
    var ExternalAddress_1 = require_ExternalAddress();
    var BitReader = class {
      constructor(bits, offset = 0) {
        this._checkpoints = [];
        this._bits = bits;
        this._offset = offset;
      }
      /**
       * Offset in source bit string
       */
      get offset() {
        return this._offset;
      }
      /**
       * Number of bits remaining
       */
      get remaining() {
        return this._bits.length - this._offset;
      }
      /**
       * Skip bits
       * @param bits number of bits to skip
       */
      skip(bits) {
        if (bits < 0 || this._offset + bits > this._bits.length) {
          throw new Error(`Index ${this._offset + bits} is out of bounds`);
        }
        this._offset += bits;
      }
      /**
       * Reset to the beginning or latest checkpoint
       */
      reset() {
        if (this._checkpoints.length > 0) {
          this._offset = this._checkpoints.pop();
        } else {
          this._offset = 0;
        }
      }
      /**
       * Save checkpoint
       */
      save() {
        this._checkpoints.push(this._offset);
      }
      /**
       * Load a single bit
       * @returns true if the bit is set, false otherwise
       */
      loadBit() {
        let r = this._bits.at(this._offset);
        this._offset++;
        return r;
      }
      /**
       * Preload bit
       * @returns true if the bit is set, false otherwise
       */
      preloadBit() {
        return this._bits.at(this._offset);
      }
      /**
       * Load bit string
       * @param bits number of bits to read
       * @returns new bitstring
       */
      loadBits(bits) {
        let r = this._bits.substring(this._offset, bits);
        this._offset += bits;
        return r;
      }
      /**
       * Preload bit string
       * @param bits number of bits to read
       * @returns new bitstring
       */
      preloadBits(bits) {
        return this._bits.substring(this._offset, bits);
      }
      /**
       * Load buffer
       * @param bytes number of bytes
       * @returns new buffer
       */
      loadBuffer(bytes) {
        let buf = this._preloadBuffer(bytes, this._offset);
        this._offset += bytes * 8;
        return buf;
      }
      /**
       * Preload buffer
       * @param bytes number of bytes
       * @returns new buffer
       */
      preloadBuffer(bytes) {
        return this._preloadBuffer(bytes, this._offset);
      }
      /**
       * Load uint value
       * @param bits uint bits
       * @returns read value as number
       */
      loadUint(bits) {
        return Number(this.loadUintBig(bits));
      }
      /**
       * Load uint value as bigint
       * @param bits uint bits
       * @returns read value as bigint
       */
      loadUintBig(bits) {
        let loaded = this.preloadUintBig(bits);
        this._offset += bits;
        return loaded;
      }
      /**
       * Preload uint value
       * @param bits uint bits
       * @returns read value as number
       */
      preloadUint(bits) {
        return Number(this._preloadUint(bits, this._offset));
      }
      /**
       * Preload uint value as bigint
       * @param bits uint bits
       * @returns read value as bigint
       */
      preloadUintBig(bits) {
        return this._preloadUint(bits, this._offset);
      }
      /**
       * Load int value
       * @param bits int bits
       * @returns read value as bigint
       */
      loadInt(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return Number(res);
      }
      /**
       * Load int value as bigint
       * @param bits int bits
       * @returns read value as bigint
       */
      loadIntBig(bits) {
        let res = this._preloadInt(bits, this._offset);
        this._offset += bits;
        return res;
      }
      /**
       * Preload int value
       * @param bits int bits
       * @returns read value as bigint
       */
      preloadInt(bits) {
        return Number(this._preloadInt(bits, this._offset));
      }
      /**
       * Preload int value
       * @param bits int bits
       * @returns read value as bigint
       */
      preloadIntBig(bits) {
        return this._preloadInt(bits, this._offset);
      }
      /**
       * Load varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarUint(bits) {
        let size = Number(this.loadUint(bits));
        return Number(this.loadUintBig(size * 8));
      }
      /**
       * Load varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarUintBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadUintBig(size * 8);
      }
      /**
       * Preload varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarUint(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadUint(size * 8, this._offset + bits));
      }
      /**
       * Preload varuint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarUintBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadUint(size * 8, this._offset + bits);
      }
      /**
       * Load varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarInt(bits) {
        let size = Number(this.loadUint(bits));
        return Number(this.loadIntBig(size * 8));
      }
      /**
       * Load varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      loadVarIntBig(bits) {
        let size = Number(this.loadUint(bits));
        return this.loadIntBig(size * 8);
      }
      /**
       * Preload varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarInt(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return Number(this._preloadInt(size * 8, this._offset + bits));
      }
      /**
       * Preload varint value
       * @param bits number of bits to read the size
       * @returns read value as bigint
       */
      preloadVarIntBig(bits) {
        let size = Number(this._preloadUint(bits, this._offset));
        return this._preloadInt(size * 8, this._offset + bits);
      }
      /**
       * Load coins value
       * @returns read value as bigint
       */
      loadCoins() {
        return this.loadVarUintBig(4);
      }
      /**
       * Preload coins value
       * @returns read value as bigint
       */
      preloadCoins() {
        return this.preloadVarUintBig(4);
      }
      /**
       * Load Address
       * @returns Address
       */
      loadAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 2) {
          return this._loadInternalAddress();
        } else {
          throw new Error("Invalid address: " + type);
        }
      }
      /**
       * Load internal address
       * @returns Address or null
       */
      loadMaybeAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
          this._offset += 2;
          return null;
        } else if (type === 2) {
          return this._loadInternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Load external address
       * @returns ExternalAddress
       */
      loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 1) {
          return this._loadExternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Load external address
       * @returns ExternalAddress or null
       */
      loadMaybeExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
          this._offset += 2;
          return null;
        } else if (type === 1) {
          return this._loadExternalAddress();
        } else {
          throw new Error("Invalid address");
        }
      }
      /**
       * Read address of any type
       * @returns Address or ExternalAddress or null
       */
      loadAddressAny() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type === 0) {
          this._offset += 2;
          return null;
        } else if (type === 2) {
          return this._loadInternalAddress();
        } else if (type === 1) {
          return this._loadExternalAddress();
        } else if (type === 3) {
          throw Error("Unsupported");
        } else {
          throw Error("Unreachable");
        }
      }
      /**
       * Load bit string that was padded to make it byte alligned. Used in BOC serialization
       * @param bytes number of bytes to read
       */
      loadPaddedBits(bits) {
        if (bits % 8 !== 0) {
          throw new Error("Invalid number of bits");
        }
        let length = bits;
        while (true) {
          if (this._bits.at(this._offset + length - 1)) {
            length--;
            break;
          } else {
            length--;
          }
        }
        let r = this._bits.substring(this._offset, length);
        this._offset += bits;
        return r;
      }
      /**
       * Clone BitReader
       */
      clone() {
        return new BitReader(this._bits, this._offset);
      }
      /**
       * Preload int from specific offset
       * @param bits bits to preload
       * @param offset offset to start from
       * @returns read value as bigint
       */
      _preloadInt(bits, offset) {
        if (bits == 0) {
          return 0n;
        }
        let sign = this._bits.at(offset);
        let res = 0n;
        for (let i = 0; i < bits - 1; i++) {
          if (this._bits.at(offset + 1 + i)) {
            res += 1n << BigInt(bits - i - 1 - 1);
          }
        }
        if (sign) {
          res = res - (1n << BigInt(bits - 1));
        }
        return res;
      }
      /**
       * Preload uint from specific offset
       * @param bits bits to preload
       * @param offset offset to start from
       * @returns read value as bigint
       */
      _preloadUint(bits, offset) {
        if (bits == 0) {
          return 0n;
        }
        let res = 0n;
        for (let i = 0; i < bits; i++) {
          if (this._bits.at(offset + i)) {
            res += 1n << BigInt(bits - i - 1);
          }
        }
        return res;
      }
      _preloadBuffer(bytes, offset) {
        let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
        if (fastBuffer) {
          return fastBuffer;
        }
        let buf = import_buffer.Buffer.alloc(bytes);
        for (let i = 0; i < bytes; i++) {
          buf[i] = Number(this._preloadUint(8, offset + i * 8));
        }
        return buf;
      }
      _loadInternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 2) {
          throw Error("Invalid address");
        }
        if (this._preloadUint(1, this._offset + 2) !== 0n) {
          throw Error("Invalid address");
        }
        let wc = Number(this._preloadInt(8, this._offset + 3));
        let hash = this._preloadBuffer(32, this._offset + 11);
        this._offset += 267;
        return new Address_1.Address(wc, hash);
      }
      _loadExternalAddress() {
        let type = Number(this._preloadUint(2, this._offset));
        if (type !== 1) {
          throw Error("Invalid address");
        }
        let bits = Number(this._preloadUint(9, this._offset + 2));
        let value = this._preloadUint(bits, this._offset + 11);
        this._offset += 11 + bits;
        return new ExternalAddress_1.ExternalAddress(value, bits);
      }
    };
    exports.BitReader = BitReader;
  }
});

// node_modules/ton-core/dist/boc/cell/exoticLibrary.js
var require_exoticLibrary = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticLibrary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticLibrary = void 0;
    var BitReader_1 = require_BitReader();
    function exoticLibrary(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size = 8 + 256;
      if (bits.length !== size) {
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
      }
      let type = reader.loadUint(8);
      if (type !== 2) {
        throw new Error(`Library cell must have type 2, got "${type}"`);
      }
      return {};
    }
    exports.exoticLibrary = exoticLibrary;
  }
});

// node_modules/ton-core/dist/boc/cell/exoticMerkleProof.js
var require_exoticMerkleProof = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticMerkleProof.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticMerkleProof = void 0;
    var BitReader_1 = require_BitReader();
    function exoticMerkleProof(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size = 8 + 256 + 16;
      if (bits.length !== size) {
        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
      }
      if (refs.length !== 1) {
        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
      }
      let type = reader.loadUint(8);
      if (type !== 3) {
        throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
      }
      const proofHash = reader.loadBuffer(32);
      const proofDepth = reader.loadUint(16);
      const refHash = refs[0].hash(0);
      const refDepth = refs[0].depth(0);
      if (proofDepth !== refDepth) {
        throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
      }
      if (!proofHash.equals(refHash)) {
        throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString("hex")}", got "${refHash.toString("hex")}"`);
      }
      return {
        proofDepth,
        proofHash
      };
    }
    exports.exoticMerkleProof = exoticMerkleProof;
  }
});

// node_modules/ton-core/dist/boc/cell/exoticMerkleUpdate.js
var require_exoticMerkleUpdate = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticMerkleUpdate.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticMerkleUpdate = void 0;
    var BitReader_1 = require_BitReader();
    function exoticMerkleUpdate(bits, refs) {
      const reader = new BitReader_1.BitReader(bits);
      const size = 8 + 2 * (256 + 16);
      if (bits.length !== size) {
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
      }
      if (refs.length !== 2) {
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
      }
      let type = reader.loadUint(8);
      if (type !== 4) {
        throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
      }
      const proofHash1 = reader.loadBuffer(32);
      const proofHash2 = reader.loadBuffer(32);
      const proofDepth1 = reader.loadUint(16);
      const proofDepth2 = reader.loadUint(16);
      if (proofDepth1 !== refs[0].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
      }
      if (!proofHash1.equals(refs[0].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString("hex")}", got "${refs[0].hash(0).toString("hex")}"`);
      }
      if (proofDepth2 !== refs[1].depth(0)) {
        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
      }
      if (!proofHash2.equals(refs[1].hash(0))) {
        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString("hex")}", got "${refs[1].hash(0).toString("hex")}"`);
      }
      return {
        proofDepth1,
        proofDepth2,
        proofHash1,
        proofHash2
      };
    }
    exports.exoticMerkleUpdate = exoticMerkleUpdate;
  }
});

// node_modules/ton-core/dist/boc/cell/LevelMask.js
var require_LevelMask = __commonJS({
  "node_modules/ton-core/dist/boc/cell/LevelMask.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LevelMask = void 0;
    var LevelMask = class {
      constructor(mask = 0) {
        this._mask = 0;
        this._mask = mask;
        this._hashIndex = countSetBits(this._mask);
        this._hashCount = this._hashIndex + 1;
      }
      get value() {
        return this._mask;
      }
      get level() {
        return 32 - Math.clz32(this._mask);
      }
      get hashIndex() {
        return this._hashIndex;
      }
      get hashCount() {
        return this._hashCount;
      }
      apply(level) {
        return new LevelMask(this._mask & (1 << level) - 1);
      }
      isSignificant(level) {
        let res = level === 0 || (this._mask >> level - 1) % 2 !== 0;
        return res;
      }
    };
    exports.LevelMask = LevelMask;
    function countSetBits(n) {
      n = n - (n >> 1 & 1431655765);
      n = (n & 858993459) + (n >> 2 & 858993459);
      return (n + (n >> 4) & 252645135) * 16843009 >> 24;
    }
  }
});

// node_modules/ton-core/dist/boc/cell/exoticPruned.js
var require_exoticPruned = __commonJS({
  "node_modules/ton-core/dist/boc/cell/exoticPruned.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exoticPruned = void 0;
    var BitReader_1 = require_BitReader();
    var LevelMask_1 = require_LevelMask();
    function exoticPruned(bits, refs) {
      let reader = new BitReader_1.BitReader(bits);
      let type = reader.loadUint(8);
      if (type !== 1) {
        throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
      }
      if (refs.length !== 0) {
        throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
      }
      let mask;
      if (bits.length === 280) {
        mask = new LevelMask_1.LevelMask(1);
      } else {
        mask = new LevelMask_1.LevelMask(reader.loadUint(8));
        if (mask.level < 1 || mask.level > 3) {
          throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
        }
        const size = 8 + 8 + mask.apply(mask.level - 1).hashCount * (256 + 16);
        if (bits.length !== size) {
          throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
        }
      }
      let pruned = [];
      let hashes = [];
      let depths = [];
      for (let i = 0; i < mask.level; i++) {
        hashes.push(reader.loadBuffer(32));
      }
      for (let i = 0; i < mask.level; i++) {
        depths.push(reader.loadUint(16));
      }
      for (let i = 0; i < mask.level; i++) {
        pruned.push({
          depth: depths[i],
          hash: hashes[i]
        });
      }
      return {
        mask: mask.value,
        pruned
      };
    }
    exports.exoticPruned = exoticPruned;
  }
});

// node_modules/ton-core/dist/boc/cell/resolveExotic.js
var require_resolveExotic = __commonJS({
  "node_modules/ton-core/dist/boc/cell/resolveExotic.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveExotic = void 0;
    var BitReader_1 = require_BitReader();
    var CellType_1 = require_CellType();
    var exoticLibrary_1 = require_exoticLibrary();
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    var exoticPruned_1 = require_exoticPruned();
    var LevelMask_1 = require_LevelMask();
    function resolvePruned(bits, refs) {
      let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask(pruned.mask);
      for (let i = 0; i < pruned.pruned.length; i++) {
        depths.push(pruned.pruned[i].depth);
        hashes.push(pruned.pruned[i].hash);
      }
      return {
        type: CellType_1.CellType.PrunedBranch,
        depths,
        hashes,
        mask
      };
    }
    function resolveLibrary(bits, refs) {
      let pruned = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask();
      return {
        type: CellType_1.CellType.Library,
        depths,
        hashes,
        mask
      };
    }
    function resolveMerkleProof(bits, refs) {
      let merkleProof = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
      return {
        type: CellType_1.CellType.MerkleProof,
        depths,
        hashes,
        mask
      };
    }
    function resolveMerkleUpdate(bits, refs) {
      let merkleUpdate = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
      let depths = [];
      let hashes = [];
      let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
      return {
        type: CellType_1.CellType.MerkleUpdate,
        depths,
        hashes,
        mask
      };
    }
    function resolveExotic(bits, refs) {
      let reader = new BitReader_1.BitReader(bits);
      let type = reader.preloadUint(8);
      if (type === 1) {
        return resolvePruned(bits, refs);
      }
      if (type === 2) {
        return resolveLibrary(bits, refs);
      }
      if (type === 3) {
        return resolveMerkleProof(bits, refs);
      }
      if (type === 4) {
        return resolveMerkleUpdate(bits, refs);
      }
      throw Error("Invalid exotic cell type: " + type);
    }
    exports.resolveExotic = resolveExotic;
  }
});

// node_modules/ton-core/dist/boc/cell/descriptor.js
var require_descriptor = __commonJS({
  "node_modules/ton-core/dist/boc/cell/descriptor.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRepr = exports.getBitsDescriptor = exports.getRefsDescriptor = void 0;
    var CellType_1 = require_CellType();
    var paddedBits_1 = require_paddedBits();
    function getRefsDescriptor(refs, level, type) {
      return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + level * 32;
    }
    exports.getRefsDescriptor = getRefsDescriptor;
    function getBitsDescriptor(bits) {
      let len = bits.length;
      return Math.ceil(len / 8) + Math.floor(len / 8);
    }
    exports.getBitsDescriptor = getBitsDescriptor;
    function getRepr(originalBits, bits, refs, level, type) {
      const bitsLen = Math.ceil(bits.length / 8);
      const repr = import_buffer.Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
      let reprCursor = 0;
      repr[reprCursor++] = getRefsDescriptor(refs, level, type);
      repr[reprCursor++] = getBitsDescriptor(originalBits);
      (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
      reprCursor += bitsLen;
      for (const c of refs) {
        let childDepth;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childDepth = c.depth(level + 1);
        } else {
          childDepth = c.depth(level);
        }
        repr[reprCursor++] = Math.floor(childDepth / 256);
        repr[reprCursor++] = childDepth % 256;
      }
      for (const c of refs) {
        let childHash;
        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
          childHash = c.hash(level + 1);
        } else {
          childHash = c.hash(level);
        }
        childHash.copy(repr, reprCursor);
        reprCursor += 32;
      }
      return repr;
    }
    exports.getRepr = getRepr;
  }
});

// node_modules/jssha/dist/sha.js
var require_sha = __commonJS({
  "node_modules/jssha/dist/sha.js"(exports, module) {
    init_shim();
    !function(n, r) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define(r) : (n = "undefined" != typeof globalThis ? globalThis : n || self).jsSHA = r();
    }(exports, function() {
      "use strict";
      var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      function r(n2, r2, t2, e2) {
        var i2, o2, u2, f2 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s2 = -1 === e2 ? 3 : 0;
        for (i2 = 0; i2 < n2.length; i2 += 1)
          o2 = (u2 = i2 + w2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (s2 + e2 * (u2 % 4));
        return { value: f2, binLen: 8 * n2.length + t2 };
      }
      function t(t2, e2, i2) {
        switch (e2) {
          case "UTF8":
          case "UTF16BE":
          case "UTF16LE":
            break;
          default:
            throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
        }
        switch (t2) {
          case "HEX":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3) {
                var i3, o2, u2, f2;
                if (0 != n3.length % 2)
                  throw new Error("String of HEX type must be in byte increments");
                var w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (i3 = 0; i3 < n3.length; i3 += 2) {
                  if (o2 = parseInt(n3.substr(i3, 2), 16), isNaN(o2))
                    throw new Error("String of HEX type contains invalid characters");
                  for (u2 = (f2 = (i3 >>> 1) + s2) >>> 2; w2.length <= u2; )
                    w2.push(0);
                  w2[u2] |= o2 << 8 * (a2 + e3 * (f2 % 4));
                }
                return { value: w2, binLen: 4 * n3.length + t4 };
              }(n2, r2, t3, i2);
            };
          case "TEXT":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3, i3) {
                var o2, u2, f2, w2, s2, a2, h2, c2, v2 = 0, A2 = t4 || [0], E2 = (e3 = e3 || 0) >>> 3;
                if ("UTF8" === r3)
                  for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1)
                    for (u2 = [], 128 > (o2 = n3.charCodeAt(f2)) ? u2.push(o2) : 2048 > o2 ? (u2.push(192 | o2 >>> 6), u2.push(128 | 63 & o2)) : 55296 > o2 || 57344 <= o2 ? u2.push(224 | o2 >>> 12, 128 | o2 >>> 6 & 63, 128 | 63 & o2) : (f2 += 1, o2 = 65536 + ((1023 & o2) << 10 | 1023 & n3.charCodeAt(f2)), u2.push(240 | o2 >>> 18, 128 | o2 >>> 12 & 63, 128 | o2 >>> 6 & 63, 128 | 63 & o2)), w2 = 0; w2 < u2.length; w2 += 1) {
                      for (s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                        A2.push(0);
                      A2[s2] |= u2[w2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
                    }
                else
                  for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
                    for (o2 = n3.charCodeAt(f2), true === c2 && (o2 = (w2 = 255 & o2) << 8 | o2 >>> 8), s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; )
                      A2.push(0);
                    A2[s2] |= o2 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
                  }
                return { value: A2, binLen: 8 * v2 + e3 };
              }(n2, e2, r2, t3, i2);
            };
          case "B64":
            return function(r2, t3, e3) {
              return function(r3, t4, e4, i3) {
                var o2, u2, f2, w2, s2, a2, h2 = 0, c2 = t4 || [0], v2 = (e4 = e4 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
                if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/))
                  throw new Error("Invalid character in base-64 string");
                if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length)
                  throw new Error("Invalid '=' found in base-64 string");
                for (o2 = 0; o2 < r3.length; o2 += 4) {
                  for (w2 = r3.substr(o2, 4), f2 = 0, u2 = 0; u2 < w2.length; u2 += 1)
                    f2 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
                  for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
                    for (s2 = (a2 = h2 + v2) >>> 2; c2.length <= s2; )
                      c2.push(0);
                    c2[s2] |= (f2 >>> 16 - 8 * u2 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
                  }
                }
                return { value: c2, binLen: 8 * h2 + e4 };
              }(r2, t3, e3, i2);
            };
          case "BYTES":
            return function(n2, r2, t3) {
              return function(n3, r3, t4, e3) {
                var i3, o2, u2, f2, w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < n3.length; o2 += 1)
                  i3 = n3.charCodeAt(o2), u2 = (f2 = o2 + s2) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a2 + e3 * (f2 % 4));
                return { value: w2, binLen: 8 * n3.length + t4 };
              }(n2, r2, t3, i2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2, t3, e3) {
              return function(n3, t4, e4, i3) {
                return r(new Uint8Array(n3), t4, e4, i3);
              }(n2, t3, e3, i2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2, t3, e3) {
              return r(n2, t3, e3, i2);
            };
          default:
            throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      function e(r2, t2, e2, i2) {
        switch (r2) {
          case "HEX":
            return function(n2) {
              return function(n3, r3, t3, e3) {
                var i3, o2, u2 = "", f2 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
                for (i3 = 0; i3 < f2; i3 += 1)
                  o2 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o2);
                return e3.outputUpper ? u2.toUpperCase() : u2;
              }(n2, t2, e2, i2);
            };
          case "B64":
            return function(r3) {
              return function(r4, t3, e3, i3) {
                var o2, u2, f2, w2, s2, a2 = "", h2 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
                for (o2 = 0; o2 < h2; o2 += 3)
                  for (w2 = o2 + 1 < h2 ? r4[o2 + 1 >>> 2] : 0, s2 = o2 + 2 < h2 ? r4[o2 + 2 >>> 2] : 0, f2 = (r4[o2 >>> 2] >>> 8 * (c2 + e3 * (o2 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o2 + 1) % 4)) & 255) << 8 | s2 >>> 8 * (c2 + e3 * ((o2 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1)
                    a2 += 8 * o2 + 6 * u2 <= t3 ? n.charAt(f2 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
                return a2;
              }(r3, t2, e2, i2);
            };
          case "BYTES":
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3, o2 = "", u2 = r3 / 8, f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < u2; e3 += 1)
                  i3 = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255, o2 += String.fromCharCode(i3);
                return o2;
              }(n2, t2, e2);
            };
          case "ARRAYBUFFER":
            try {
              new ArrayBuffer(0);
            } catch (n2) {
              throw new Error("ARRAYBUFFER not supported by this environment");
            }
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = new ArrayBuffer(i3), u2 = new Uint8Array(o2), f2 = -1 === t3 ? 3 : 0;
                for (e3 = 0; e3 < i3; e3 += 1)
                  u2[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255;
                return o2;
              }(n2, t2, e2);
            };
          case "UINT8ARRAY":
            try {
              new Uint8Array(0);
            } catch (n2) {
              throw new Error("UINT8ARRAY not supported by this environment");
            }
            return function(n2) {
              return function(n3, r3, t3) {
                var e3, i3 = r3 / 8, o2 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
                for (e3 = 0; e3 < i3; e3 += 1)
                  u2[e3] = n3[e3 >>> 2] >>> 8 * (o2 + t3 * (e3 % 4)) & 255;
                return u2;
              }(n2, t2, e2);
            };
          default:
            throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
        }
      }
      var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f = "Chosen SHA variant is not supported";
      function w(n2, r2) {
        var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
        if (i2 % 4 != 0) {
          for (t2 = 0; t2 < o2; t2 += 4)
            e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
          return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
        }
        return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
      }
      function s(n2) {
        var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
        if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
          if (t2.outputLen % 8 != 0)
            throw new Error(e2);
          r2.outputLen = t2.outputLen;
        } else if (t2.shakeLen) {
          if (t2.shakeLen % 8 != 0)
            throw new Error(e2);
          r2.outputLen = t2.shakeLen;
        }
        if ("boolean" != typeof r2.outputUpper)
          throw new Error("Invalid outputUpper formatting option");
        if ("string" != typeof r2.b64Pad)
          throw new Error("Invalid b64Pad formatting option");
        return r2;
      }
      function a(n2, r2, e2, i2) {
        var o2 = n2 + " must include a value and format";
        if (!r2) {
          if (!i2)
            throw new Error(o2);
          return i2;
        }
        if (void 0 === r2.value || !r2.format)
          throw new Error(o2);
        return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
      }
      var h = function() {
        function n2(n3, r2, t2) {
          var e2 = t2 || {};
          if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
            throw new Error("numRounds must a integer >= 1");
          this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
        }
        return n2.prototype.update = function(n3) {
          var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
          for (r2 = 0; r2 < f2; r2 += e2)
            t2 + this.S <= o2 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
          this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o2 % this.S, this.h = true;
        }, n2.prototype.getHash = function(n3, r2) {
          var t2, i2, o2 = this.U, u2 = s(r2);
          if (this.T) {
            if (-1 === u2.outputLen)
              throw new Error("Output length must be specified in options");
            o2 = u2.outputLen;
          }
          var f2 = e(n3, o2, this.C, u2);
          if (this.A && this.F)
            return f2(this.F(u2));
          for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o2), t2 = 1; t2 < this.numRounds; t2 += 1)
            this.T && o2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o2 % 32), i2 = this.K(i2, o2, 0, this.L(this.o), o2);
          return f2(i2);
        }, n2.prototype.setHMACKey = function(n3, r2, e2) {
          if (!this.g)
            throw new Error("Variant does not support HMAC");
          if (this.h)
            throw new Error("Cannot set MAC key after calling update");
          var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
          this.k(i2(n3));
        }, n2.prototype.k = function(n3) {
          var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
          if (1 !== this.numRounds)
            throw new Error("Cannot set numRounds with MAC");
          if (this.A)
            throw new Error("MAC key already set");
          for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; )
            n3.value.push(0);
          for (r2 = 0; r2 <= e2; r2 += 1)
            this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
          this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
        }, n2.prototype.getHMAC = function(n3, r2) {
          var t2 = s(r2);
          return e(n3, this.U, this.C, t2)(this.Y());
        }, n2.prototype.Y = function() {
          var n3;
          if (!this.A)
            throw new Error("Cannot call getHMAC without first setting MAC key");
          var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
          return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
        }, n2;
      }(), c = function(n2, r2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
          n3.__proto__ = r3;
        } || function(n3, r3) {
          for (var t2 in r3)
            Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
        })(n2, r2);
      };
      function v(n2, r2) {
        function t2() {
          this.constructor = n2;
        }
        c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
      }
      function A(n2, r2) {
        return n2 << r2 | n2 >>> 32 - r2;
      }
      function E(n2, r2) {
        return n2 >>> r2 | n2 << 32 - r2;
      }
      function l(n2, r2) {
        return n2 >>> r2;
      }
      function b(n2, r2, t2) {
        return n2 ^ r2 ^ t2;
      }
      function H(n2, r2, t2) {
        return n2 & r2 ^ ~n2 & t2;
      }
      function d(n2, r2, t2) {
        return n2 & r2 ^ n2 & t2 ^ r2 & t2;
      }
      function S(n2) {
        return E(n2, 2) ^ E(n2, 13) ^ E(n2, 22);
      }
      function p(n2, r2) {
        var t2 = (65535 & n2) + (65535 & r2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
      }
      function m(n2, r2, t2, e2) {
        var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
      }
      function y(n2, r2, t2, e2, i2) {
        var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
        return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
      }
      function R(n2) {
        return E(n2, 7) ^ E(n2, 18) ^ l(n2, 3);
      }
      function U(n2) {
        return E(n2, 6) ^ E(n2, 11) ^ E(n2, 25);
      }
      function T(n2) {
        return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      }
      function C(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1)
          s2[w2] = w2 < 16 ? n2[w2] : A(s2[w2 - 3] ^ s2[w2 - 8] ^ s2[w2 - 14] ^ s2[w2 - 16], 1), f2 = w2 < 20 ? y(A(t2, 5), H(e2, i2, o2), u2, 1518500249, s2[w2]) : w2 < 40 ? y(A(t2, 5), b(e2, i2, o2), u2, 1859775393, s2[w2]) : w2 < 60 ? y(A(t2, 5), d(e2, i2, o2), u2, 2400959708, s2[w2]) : y(A(t2, 5), b(e2, i2, o2), u2, 3395469782, s2[w2]), u2 = o2, o2 = i2, i2 = A(e2, 30), e2 = t2, t2 = f2;
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(i2, r2[2]), r2[3] = p(o2, r2[3]), r2[4] = p(u2, r2[4]), r2;
      }
      function F(n2, r2, t2, e2) {
        for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o2; )
          n2.push(0);
        for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & u2, n2[o2 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16)
          e2 = C(n2.slice(i2, i2 + 16), e2);
        return e2;
      }
      var K = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-1" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).g = true, o2.F = o2.Y, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = C, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = T, o2.K = F, o2.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.S = 512, o2.U = 160, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h);
      function B(n2) {
        return "SHA-224" == n2 ? o.slice() : u.slice();
      }
      function L(n2, r2) {
        var t2, e2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, b2 = [];
        for (t2 = r2[0], e2 = r2[1], o2 = r2[2], u2 = r2[3], f2 = r2[4], w2 = r2[5], s2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1)
          b2[v2] = v2 < 16 ? n2[v2] : m(E(A2 = b2[v2 - 2], 17) ^ E(A2, 19) ^ l(A2, 10), b2[v2 - 7], R(b2[v2 - 15]), b2[v2 - 16]), h2 = y(a2, U(f2), H(f2, w2, s2), i[v2], b2[v2]), c2 = p(S(t2), d(t2, e2, o2)), a2 = s2, s2 = w2, w2 = f2, f2 = p(u2, h2), u2 = o2, o2 = e2, e2 = t2, t2 = p(h2, c2);
        return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(o2, r2[2]), r2[3] = p(u2, r2[3]), r2[4] = p(f2, r2[4]), r2[5] = p(w2, r2[5]), r2[6] = p(s2, r2[6]), r2[7] = p(a2, r2[7]), r2;
      }
      var g = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-224" !== r3 && "SHA-256" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = L, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = B, o2.K = function(n3, t2, e3, i3) {
            return function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 15 + (r4 + 65 >>> 9 << 4), f2 = r4 + t3; n4.length <= u3; )
                n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 16)
                e4 = L(n4.slice(o3, o3 + 16), e4);
              return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
            }(n3, t2, e3, i3, r3);
          }, o2.m = B(r3), o2.S = 512, o2.U = "SHA-224" === r3 ? 224 : 256, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h), k = function(n2, r2) {
        this.N = n2, this.I = r2;
      };
      function Y(n2, r2) {
        var t2;
        return r2 > 32 ? (t2 = 64 - r2, new k(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
      }
      function N(n2, r2) {
        var t2;
        return r2 < 32 ? (t2 = 32 - r2, new k(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
      }
      function I(n2, r2) {
        return new k(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
      }
      function M(n2, r2, t2) {
        return new k(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
      }
      function X(n2, r2, t2) {
        return new k(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
      }
      function z(n2) {
        var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function O(n2, r2) {
        var t2, e2;
        t2 = (65535 & n2.I) + (65535 & r2.I);
        var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
        return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k((65535 & e2) << 16 | 65535 & t2, i2);
      }
      function j(n2, r2, t2, e2) {
        var i2, o2;
        i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
        var u2 = (65535 & (o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
        return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o2 >>> 16), o2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k((65535 & o2) << 16 | 65535 & i2, u2);
      }
      function _(n2, r2, t2, e2, i2) {
        var o2, u2;
        o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
        var f2 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
        return o2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o2 >>> 16), new k((65535 & u2) << 16 | 65535 & o2, f2);
      }
      function P(n2, r2) {
        return new k(n2.N ^ r2.N, n2.I ^ r2.I);
      }
      function x(n2) {
        var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I(n2, 7);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      function V(n2) {
        var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
        return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
      }
      var Z = [new k(i[0], 3609767458), new k(i[1], 602891725), new k(i[2], 3964484399), new k(i[3], 2173295548), new k(i[4], 4081628472), new k(i[5], 3053834265), new k(i[6], 2937671579), new k(i[7], 3664609560), new k(i[8], 2734883394), new k(i[9], 1164996542), new k(i[10], 1323610764), new k(i[11], 3590304994), new k(i[12], 4068182383), new k(i[13], 991336113), new k(i[14], 633803317), new k(i[15], 3479774868), new k(i[16], 2666613458), new k(i[17], 944711139), new k(i[18], 2341262773), new k(i[19], 2007800933), new k(i[20], 1495990901), new k(i[21], 1856431235), new k(i[22], 3175218132), new k(i[23], 2198950837), new k(i[24], 3999719339), new k(i[25], 766784016), new k(i[26], 2566594879), new k(i[27], 3203337956), new k(i[28], 1034457026), new k(i[29], 2466948901), new k(i[30], 3758326383), new k(i[31], 168717936), new k(i[32], 1188179964), new k(i[33], 1546045734), new k(i[34], 1522805485), new k(i[35], 2643833823), new k(i[36], 2343527390), new k(i[37], 1014477480), new k(i[38], 1206759142), new k(i[39], 344077627), new k(i[40], 1290863460), new k(i[41], 3158454273), new k(i[42], 3505952657), new k(i[43], 106217008), new k(i[44], 3606008344), new k(i[45], 1432725776), new k(i[46], 1467031594), new k(i[47], 851169720), new k(i[48], 3100823752), new k(i[49], 1363258195), new k(i[50], 3750685593), new k(i[51], 3785050280), new k(i[52], 3318307427), new k(i[53], 3812723403), new k(i[54], 2003034995), new k(i[55], 3602036899), new k(i[56], 1575990012), new k(i[57], 1125592928), new k(i[58], 2716904306), new k(i[59], 442776044), new k(i[60], 593698344), new k(i[61], 3733110249), new k(i[62], 2999351573), new k(i[63], 3815920427), new k(3391569614, 3928383900), new k(3515267271, 566280711), new k(3940187606, 3454069534), new k(4118630271, 4000239992), new k(116418474, 1914138554), new k(174292421, 2731055270), new k(289380356, 3203993006), new k(460393269, 320620315), new k(685471733, 587496836), new k(852142971, 1086792851), new k(1017036298, 365543100), new k(1126000580, 2618297676), new k(1288033470, 3409855158), new k(1501505948, 4234509866), new k(1607167915, 987167468), new k(1816402316, 1246189591)];
      function q(n2) {
        return "SHA-384" === n2 ? [new k(3418070365, o[0]), new k(1654270250, o[1]), new k(2438529370, o[2]), new k(355462360, o[3]), new k(1731405415, o[4]), new k(41048885895, o[5]), new k(3675008525, o[6]), new k(1203062813, o[7])] : [new k(u[0], 4089235720), new k(u[1], 2227873595), new k(u[2], 4271175723), new k(u[3], 1595750129), new k(u[4], 2917565137), new k(u[5], 725511199), new k(u[6], 4215389547), new k(u[7], 327033209)];
      }
      function D(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, E2, l2, b2, H2 = [];
        for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], w2 = r2[6], s2 = r2[7], c2 = 0; c2 < 80; c2 += 1)
          c2 < 16 ? (v2 = 2 * c2, H2[c2] = new k(n2[v2], n2[v2 + 1])) : H2[c2] = j((A2 = H2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = N(A2, 19), l2 = N(A2, 61), b2 = I(A2, 6), new k(E2.N ^ l2.N ^ b2.N, E2.I ^ l2.I ^ b2.I)), H2[c2 - 7], x(H2[c2 - 15]), H2[c2 - 16]), a2 = _(s2, V(u2), M(u2, f2, w2), Z[c2], H2[c2]), h2 = O(z(t2), X(t2, e2, i2)), s2 = w2, w2 = f2, f2 = u2, u2 = O(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = O(a2, h2);
        return r2[0] = O(t2, r2[0]), r2[1] = O(e2, r2[1]), r2[2] = O(i2, r2[2]), r2[3] = O(o2, r2[3]), r2[4] = O(u2, r2[4]), r2[5] = O(f2, r2[5]), r2[6] = O(w2, r2[6]), r2[7] = O(s2, r2[7]), r2;
      }
      var G = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this;
          if ("SHA-384" !== r3 && "SHA-512" !== r3)
            throw new Error(f);
          var u2 = i2 || {};
          return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = D, o2.B = function(n3) {
            return n3.slice();
          }, o2.L = q, o2.K = function(n3, t2, e3, i3) {
            return function(n4, r4, t3, e4, i4) {
              for (var o3, u3 = 31 + (r4 + 129 >>> 10 << 5), f2 = r4 + t3; n4.length <= u3; )
                n4.push(0);
              for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 32)
                e4 = D(n4.slice(o3, o3 + 32), e4);
              return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
            }(n3, t2, e3, i3, r3);
          }, o2.m = q(r3), o2.S = 1024, o2.U = "SHA-384" === r3 ? 384 : 512, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2;
      }(h), J = [new k(0, 1), new k(0, 32898), new k(2147483648, 32906), new k(2147483648, 2147516416), new k(0, 32907), new k(0, 2147483649), new k(2147483648, 2147516545), new k(2147483648, 32777), new k(0, 138), new k(0, 136), new k(0, 2147516425), new k(0, 2147483658), new k(0, 2147516555), new k(2147483648, 139), new k(2147483648, 32905), new k(2147483648, 32771), new k(2147483648, 32770), new k(2147483648, 128), new k(0, 32778), new k(2147483648, 2147483658), new k(2147483648, 2147516545), new k(2147483648, 32896), new k(0, 2147483649), new k(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
      function W(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1)
          t2[r2] = [new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0)];
        return t2;
      }
      function $(n2) {
        var r2, t2 = [];
        for (r2 = 0; r2 < 5; r2 += 1)
          t2[r2] = n2[r2].slice();
        return t2;
      }
      function nn(n2, r2) {
        var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2 = [], c2 = [];
        if (null !== n2)
          for (e2 = 0; e2 < n2.length; e2 += 2)
            r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k(n2[e2 + 1], n2[e2]));
        for (t2 = 0; t2 < 24; t2 += 1) {
          for (o2 = W(), e2 = 0; e2 < 5; e2 += 1)
            h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], w2 = r2[e2][2], s2 = r2[e2][3], a2 = r2[e2][4], new k(u2.N ^ f2.N ^ w2.N ^ s2.N ^ a2.N, u2.I ^ f2.I ^ w2.I ^ s2.I ^ a2.I));
          for (e2 = 0; e2 < 5; e2 += 1)
            c2[e2] = P(h2[(e2 + 4) % 5], Y(h2[(e2 + 1) % 5], 1));
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              r2[e2][i2] = P(r2[e2][i2], c2[e2]);
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              o2[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
          for (e2 = 0; e2 < 5; e2 += 1)
            for (i2 = 0; i2 < 5; i2 += 1)
              r2[e2][i2] = P(o2[e2][i2], new k(~o2[(e2 + 1) % 5][i2].N & o2[(e2 + 2) % 5][i2].N, ~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I));
          r2[0][0] = P(r2[0][0], J[t2]);
        }
        return r2;
      }
      function rn(n2) {
        var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / 4294967296 & 2097151];
        for (r2 = 6; r2 >= 0; r2--)
          0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
        return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
      }
      function tn(n2) {
        return w(rn(n2.binLen), n2);
      }
      function en(n2, r2) {
        var t2, e2 = rn(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
        for (t2 = 0; t2 < o2; t2++)
          e2.value.push(0);
        return e2.value;
      }
      var on = function(n2) {
        function r2(r3, e2, i2) {
          var o2 = this, u2 = 6, w2 = 0, s2 = i2 || {};
          if (1 !== (o2 = n2.call(this, r3, e2, i2) || this).numRounds) {
            if (s2.kmacKey || s2.hmacKey)
              throw new Error("Cannot set numRounds with MAC");
            if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o)
              throw new Error("Cannot set numRounds for CSHAKE variants");
          }
          switch (o2.C = 1, o2.p = t(o2.t, o2.i, o2.C), o2.R = nn, o2.B = $, o2.L = W, o2.m = W(), o2.T = false, r3) {
            case "SHA3-224":
              o2.S = w2 = 1152, o2.U = 224, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-256":
              o2.S = w2 = 1088, o2.U = 256, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-384":
              o2.S = w2 = 832, o2.U = 384, o2.g = true, o2.F = o2.Y;
              break;
            case "SHA3-512":
              o2.S = w2 = 576, o2.U = 512, o2.g = true, o2.F = o2.Y;
              break;
            case "SHAKE128":
              u2 = 31, o2.S = w2 = 1344, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "SHAKE256":
              u2 = 31, o2.S = w2 = 1088, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "KMAC128":
              u2 = 4, o2.S = w2 = 1344, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "KMAC256":
              u2 = 4, o2.S = w2 = 1088, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
              break;
            case "CSHAKE128":
              o2.S = w2 = 1344, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            case "CSHAKE256":
              o2.S = w2 = 1088, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
              break;
            default:
              throw new Error(f);
          }
          return o2.K = function(n3, r4, t2, e3, i3) {
            return function(n4, r5, t3, e4, i4, o3, u3) {
              var f2, w3, s3 = 0, a2 = [], h2 = i4 >>> 5, c2 = r5 >>> 5;
              for (f2 = 0; f2 < c2 && r5 >= i4; f2 += h2)
                e4 = nn(n4.slice(f2, f2 + h2), e4), r5 -= i4;
              for (n4 = n4.slice(f2), r5 %= i4; n4.length < h2; )
                n4.push(0);
              for (n4[(f2 = r5 >>> 3) >> 2] ^= o3 << f2 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a2.length < u3 && (w3 = e4[s3 % 5][s3 / 5 | 0], a2.push(w3.I), !(32 * a2.length >= u3)); )
                a2.push(w3.N), 0 == 64 * (s3 += 1) % i4 && (nn(null, e4), s3 = 0);
              return a2;
            }(n3, r4, 0, e3, w2, u2, i3);
          }, s2.hmacKey && o2.k(a("hmacKey", s2.hmacKey, o2.C)), o2;
        }
        return v(r2, n2), r2.prototype.O = function(n3, r3) {
          var t2 = function(n4) {
            var r4 = n4 || {};
            return { funcName: a("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          r3 && (t2.funcName = r3);
          var e2 = w(tn(t2.funcName), tn(t2.customization));
          if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
            for (var i2 = en(e2, this.S >>> 3), o2 = 0; o2 < i2.length; o2 += this.S >>> 5)
              this.m = this.R(i2.slice(o2, o2 + (this.S >>> 5)), this.m), this.v += this.S;
            return 4;
          }
          return 31;
        }, r2.prototype.M = function(n3) {
          var r3 = function(n4) {
            var r4 = n4 || {};
            return { kmacKey: a("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
          }(n3 || {});
          this.O(n3, r3.funcName);
          for (var t2 = en(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5)
            this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
          this.A = true;
        }, r2.prototype.X = function(n3) {
          var r3 = w({ value: this.u.slice(), binLen: this.s }, function(n4) {
            var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / 4294967296 & 2097151];
            for (r4 = 6; r4 >= 0; r4--)
              0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
            return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
          }(n3.outputLen));
          return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
        }, r2;
      }(h);
      return function() {
        function n2(n3, r2, t2) {
          if ("SHA-1" == n3)
            this.j = new K(n3, r2, t2);
          else if ("SHA-224" == n3 || "SHA-256" == n3)
            this.j = new g(n3, r2, t2);
          else if ("SHA-384" == n3 || "SHA-512" == n3)
            this.j = new G(n3, r2, t2);
          else {
            if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3)
              throw new Error(f);
            this.j = new on(n3, r2, t2);
          }
        }
        return n2.prototype.update = function(n3) {
          this.j.update(n3);
        }, n2.prototype.getHash = function(n3, r2) {
          return this.j.getHash(n3, r2);
        }, n2.prototype.setHMACKey = function(n3, r2, t2) {
          this.j.setHMACKey(n3, r2, t2);
        }, n2.prototype.getHMAC = function(n3, r2) {
          return this.j.getHMAC(n3, r2);
        }, n2;
      }();
    });
  }
});

// node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js
var require_getSecureRandom = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/getSecureRandom.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    function getSecureRandomBytes(size) {
      return import_buffer.Buffer.from(window.crypto.getRandomValues(new Uint8Array(size)));
    }
    exports.getSecureRandomBytes = getSecureRandomBytes;
    function getSecureRandomWords(size) {
      return window.crypto.getRandomValues(new Uint16Array(size));
    }
    exports.getSecureRandomWords = getSecureRandomWords;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js
var require_hmac_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/hmac_sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha512 = void 0;
    async function hmac_sha512(key, data) {
      let keyBuffer = typeof key === "string" ? import_buffer.Buffer.from(key, "utf-8") : key;
      let dataBuffer = typeof data === "string" ? import_buffer.Buffer.from(data, "utf-8") : data;
      const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
      const hmacKey = await window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
      return import_buffer.Buffer.from(await crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
    }
    exports.hmac_sha512 = hmac_sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js
var require_pbkdf2_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/pbkdf2_sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2_sha512 = void 0;
    async function pbkdf2_sha512(key, salt, iterations, keyLen) {
      const keyBuffer = typeof key === "string" ? import_buffer.Buffer.from(key, "utf-8") : key;
      const saltBuffer = typeof salt === "string" ? import_buffer.Buffer.from(salt, "utf-8") : salt;
      const pbkdf2_key = await window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
      const derivedBits = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations }, pbkdf2_key, keyLen * 8);
      return import_buffer.Buffer.from(derivedBits);
    }
    exports.pbkdf2_sha512 = pbkdf2_sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/sha256.js
var require_sha256 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/sha256.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    async function sha256(source) {
      if (typeof source === "string") {
        return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-256", import_buffer.Buffer.from(source, "utf-8")));
      }
      return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-256", source));
    }
    exports.sha256 = sha256;
  }
});

// node_modules/ton-crypto-primitives/dist/browser/sha512.js
var require_sha512 = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser/sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = void 0;
    async function sha512(source) {
      if (typeof source === "string") {
        return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-512", import_buffer.Buffer.from(source, "utf-8")));
      }
      return import_buffer.Buffer.from(await crypto.subtle.digest("SHA-512", source));
    }
    exports.sha512 = sha512;
  }
});

// node_modules/ton-crypto-primitives/dist/browser.js
var require_browser = __commonJS({
  "node_modules/ton-crypto-primitives/dist/browser.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var getSecureRandom_1 = require_getSecureRandom();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    var hmac_sha512_1 = require_hmac_sha512();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var pbkdf2_sha512_1 = require_pbkdf2_sha512();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var sha256_1 = require_sha256();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    var sha512_1 = require_sha512();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
  }
});

// node_modules/ton-crypto/dist/primitives/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/sha256.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = exports.sha256_fallback = exports.sha256_sync = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    function sha256_sync(source) {
      let src;
      if (typeof source === "string") {
        src = import_buffer.Buffer.from(source, "utf-8").toString("hex");
      } else {
        src = source.toString("hex");
      }
      let hasher = new jssha_1.default("SHA-256", "HEX");
      hasher.update(src);
      let res = hasher.getHash("HEX");
      return import_buffer.Buffer.from(res, "hex");
    }
    exports.sha256_sync = sha256_sync;
    async function sha256_fallback(source) {
      return sha256_sync(source);
    }
    exports.sha256_fallback = sha256_fallback;
    function sha256(source) {
      return (0, ton_crypto_primitives_1.sha256)(source);
    }
    exports.sha256 = sha256;
  }
});

// node_modules/ton-crypto/dist/primitives/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/sha512.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha512_fallback = exports.sha512_sync = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    function sha512_sync(source) {
      let src;
      if (typeof source === "string") {
        src = import_buffer.Buffer.from(source, "utf-8").toString("hex");
      } else {
        src = source.toString("hex");
      }
      let hasher = new jssha_1.default("SHA-512", "HEX");
      hasher.update(src);
      let res = hasher.getHash("HEX");
      return import_buffer.Buffer.from(res, "hex");
    }
    exports.sha512_sync = sha512_sync;
    async function sha512_fallback(source) {
      return sha512_sync(source);
    }
    exports.sha512_fallback = sha512_fallback;
    async function sha512(source) {
      return (0, ton_crypto_primitives_1.sha512)(source);
    }
    exports.sha512 = sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js
var require_pbkdf2_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/pbkdf2_sha512.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2_sha512 = void 0;
    var ton_crypto_primitives_1 = require_browser();
    function pbkdf2_sha512(key, salt, iterations, keyLen) {
      return (0, ton_crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
    }
    exports.pbkdf2_sha512 = pbkdf2_sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/hmac_sha512.js
var require_hmac_sha5122 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/hmac_sha512.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac_sha512 = exports.hmac_sha512_fallback = void 0;
    var jssha_1 = __importDefault(require_sha());
    var ton_crypto_primitives_1 = require_browser();
    async function hmac_sha512_fallback(key, data) {
      let keyBuffer = typeof key === "string" ? import_buffer.Buffer.from(key, "utf-8") : key;
      let dataBuffer = typeof data === "string" ? import_buffer.Buffer.from(data, "utf-8") : data;
      const shaObj = new jssha_1.default("SHA-512", "HEX", {
        hmacKey: { value: keyBuffer.toString("hex"), format: "HEX" }
      });
      shaObj.update(dataBuffer.toString("hex"));
      const hmac = shaObj.getHash("HEX");
      return import_buffer.Buffer.from(hmac, "hex");
    }
    exports.hmac_sha512_fallback = hmac_sha512_fallback;
    function hmac_sha512(key, data) {
      return (0, ton_crypto_primitives_1.hmac_sha512)(key, data);
    }
    exports.hmac_sha512 = hmac_sha512;
  }
});

// node_modules/ton-crypto/dist/primitives/getSecureRandom.js
var require_getSecureRandom2 = __commonJS({
  "node_modules/ton-crypto/dist/primitives/getSecureRandom.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
    var ton_crypto_primitives_1 = require_browser();
    async function getSecureRandomBytes(size) {
      return (0, ton_crypto_primitives_1.getSecureRandomBytes)(size);
    }
    exports.getSecureRandomBytes = getSecureRandomBytes;
    async function getSecureRandomWords(size) {
      return getSecureRandomWords(size);
    }
    exports.getSecureRandomWords = getSecureRandomWords;
    async function getSecureRandomNumber(min, max) {
      let range = max - min;
      var bitsNeeded = Math.ceil(Math.log2(range));
      if (bitsNeeded > 53) {
        throw new Error("Range is too large");
      }
      var bytesNeeded = Math.ceil(bitsNeeded / 8);
      var mask = Math.pow(2, bitsNeeded) - 1;
      while (true) {
        let res = await getSecureRandomBytes(bitsNeeded);
        let power = (bytesNeeded - 1) * 8;
        let numberValue = 0;
        for (var i = 0; i < bytesNeeded; i++) {
          numberValue += res[i] * Math.pow(2, power);
          power -= 8;
        }
        numberValue = numberValue & mask;
        if (numberValue >= range) {
          continue;
        }
        return min + numberValue;
      }
    }
    exports.getSecureRandomNumber = getSecureRandomNumber;
  }
});

// node_modules/ton-crypto/dist/passwords/wordlist.js
var require_wordlist = __commonJS({
  "node_modules/ton-crypto/dist/passwords/wordlist.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    exports.wordlist = [
      "abacus",
      "abdomen",
      "abdominal",
      "abide",
      "abiding",
      "ability",
      "ablaze",
      "able",
      "abnormal",
      "abrasion",
      "abrasive",
      "abreast",
      "abridge",
      "abroad",
      "abruptly",
      "absence",
      "absentee",
      "absently",
      "absinthe",
      "absolute",
      "absolve",
      "abstain",
      "abstract",
      "absurd",
      "accent",
      "acclaim",
      "acclimate",
      "accompany",
      "account",
      "accuracy",
      "accurate",
      "accustom",
      "acetone",
      "achiness",
      "aching",
      "acid",
      "acorn",
      "acquaint",
      "acquire",
      "acre",
      "acrobat",
      "acronym",
      "acting",
      "action",
      "activate",
      "activator",
      "active",
      "activism",
      "activist",
      "activity",
      "actress",
      "acts",
      "acutely",
      "acuteness",
      "aeration",
      "aerobics",
      "aerosol",
      "aerospace",
      "afar",
      "affair",
      "affected",
      "affecting",
      "affection",
      "affidavit",
      "affiliate",
      "affirm",
      "affix",
      "afflicted",
      "affluent",
      "afford",
      "affront",
      "aflame",
      "afloat",
      "aflutter",
      "afoot",
      "afraid",
      "afterglow",
      "afterlife",
      "aftermath",
      "aftermost",
      "afternoon",
      "aged",
      "ageless",
      "agency",
      "agenda",
      "agent",
      "aggregate",
      "aghast",
      "agile",
      "agility",
      "aging",
      "agnostic",
      "agonize",
      "agonizing",
      "agony",
      "agreeable",
      "agreeably",
      "agreed",
      "agreeing",
      "agreement",
      "aground",
      "ahead",
      "ahoy",
      "aide",
      "aids",
      "aim",
      "ajar",
      "alabaster",
      "alarm",
      "albatross",
      "album",
      "alfalfa",
      "algebra",
      "algorithm",
      "alias",
      "alibi",
      "alienable",
      "alienate",
      "aliens",
      "alike",
      "alive",
      "alkaline",
      "alkalize",
      "almanac",
      "almighty",
      "almost",
      "aloe",
      "aloft",
      "aloha",
      "alone",
      "alongside",
      "aloof",
      "alphabet",
      "alright",
      "although",
      "altitude",
      "alto",
      "aluminum",
      "alumni",
      "always",
      "amaretto",
      "amaze",
      "amazingly",
      "amber",
      "ambiance",
      "ambiguity",
      "ambiguous",
      "ambition",
      "ambitious",
      "ambulance",
      "ambush",
      "amendable",
      "amendment",
      "amends",
      "amenity",
      "amiable",
      "amicably",
      "amid",
      "amigo",
      "amino",
      "amiss",
      "ammonia",
      "ammonium",
      "amnesty",
      "amniotic",
      "among",
      "amount",
      "amperage",
      "ample",
      "amplifier",
      "amplify",
      "amply",
      "amuck",
      "amulet",
      "amusable",
      "amused",
      "amusement",
      "amuser",
      "amusing",
      "anaconda",
      "anaerobic",
      "anagram",
      "anatomist",
      "anatomy",
      "anchor",
      "anchovy",
      "ancient",
      "android",
      "anemia",
      "anemic",
      "aneurism",
      "anew",
      "angelfish",
      "angelic",
      "anger",
      "angled",
      "angler",
      "angles",
      "angling",
      "angrily",
      "angriness",
      "anguished",
      "angular",
      "animal",
      "animate",
      "animating",
      "animation",
      "animator",
      "anime",
      "animosity",
      "ankle",
      "annex",
      "annotate",
      "announcer",
      "annoying",
      "annually",
      "annuity",
      "anointer",
      "another",
      "answering",
      "antacid",
      "antarctic",
      "anteater",
      "antelope",
      "antennae",
      "anthem",
      "anthill",
      "anthology",
      "antibody",
      "antics",
      "antidote",
      "antihero",
      "antiquely",
      "antiques",
      "antiquity",
      "antirust",
      "antitoxic",
      "antitrust",
      "antiviral",
      "antivirus",
      "antler",
      "antonym",
      "antsy",
      "anvil",
      "anybody",
      "anyhow",
      "anymore",
      "anyone",
      "anyplace",
      "anything",
      "anytime",
      "anyway",
      "anywhere",
      "aorta",
      "apache",
      "apostle",
      "appealing",
      "appear",
      "appease",
      "appeasing",
      "appendage",
      "appendix",
      "appetite",
      "appetizer",
      "applaud",
      "applause",
      "apple",
      "appliance",
      "applicant",
      "applied",
      "apply",
      "appointee",
      "appraisal",
      "appraiser",
      "apprehend",
      "approach",
      "approval",
      "approve",
      "apricot",
      "april",
      "apron",
      "aptitude",
      "aptly",
      "aqua",
      "aqueduct",
      "arbitrary",
      "arbitrate",
      "ardently",
      "area",
      "arena",
      "arguable",
      "arguably",
      "argue",
      "arise",
      "armadillo",
      "armband",
      "armchair",
      "armed",
      "armful",
      "armhole",
      "arming",
      "armless",
      "armoire",
      "armored",
      "armory",
      "armrest",
      "army",
      "aroma",
      "arose",
      "around",
      "arousal",
      "arrange",
      "array",
      "arrest",
      "arrival",
      "arrive",
      "arrogance",
      "arrogant",
      "arson",
      "art",
      "ascend",
      "ascension",
      "ascent",
      "ascertain",
      "ashamed",
      "ashen",
      "ashes",
      "ashy",
      "aside",
      "askew",
      "asleep",
      "asparagus",
      "aspect",
      "aspirate",
      "aspire",
      "aspirin",
      "astonish",
      "astound",
      "astride",
      "astrology",
      "astronaut",
      "astronomy",
      "astute",
      "atlantic",
      "atlas",
      "atom",
      "atonable",
      "atop",
      "atrium",
      "atrocious",
      "atrophy",
      "attach",
      "attain",
      "attempt",
      "attendant",
      "attendee",
      "attention",
      "attentive",
      "attest",
      "attic",
      "attire",
      "attitude",
      "attractor",
      "attribute",
      "atypical",
      "auction",
      "audacious",
      "audacity",
      "audible",
      "audibly",
      "audience",
      "audio",
      "audition",
      "augmented",
      "august",
      "authentic",
      "author",
      "autism",
      "autistic",
      "autograph",
      "automaker",
      "automated",
      "automatic",
      "autopilot",
      "available",
      "avalanche",
      "avatar",
      "avenge",
      "avenging",
      "avenue",
      "average",
      "aversion",
      "avert",
      "aviation",
      "aviator",
      "avid",
      "avoid",
      "await",
      "awaken",
      "award",
      "aware",
      "awhile",
      "awkward",
      "awning",
      "awoke",
      "awry",
      "axis",
      "babble",
      "babbling",
      "babied",
      "baboon",
      "backache",
      "backboard",
      "backboned",
      "backdrop",
      "backed",
      "backer",
      "backfield",
      "backfire",
      "backhand",
      "backing",
      "backlands",
      "backlash",
      "backless",
      "backlight",
      "backlit",
      "backlog",
      "backpack",
      "backpedal",
      "backrest",
      "backroom",
      "backshift",
      "backside",
      "backslid",
      "backspace",
      "backspin",
      "backstab",
      "backstage",
      "backtalk",
      "backtrack",
      "backup",
      "backward",
      "backwash",
      "backwater",
      "backyard",
      "bacon",
      "bacteria",
      "bacterium",
      "badass",
      "badge",
      "badland",
      "badly",
      "badness",
      "baffle",
      "baffling",
      "bagel",
      "bagful",
      "baggage",
      "bagged",
      "baggie",
      "bagginess",
      "bagging",
      "baggy",
      "bagpipe",
      "baguette",
      "baked",
      "bakery",
      "bakeshop",
      "baking",
      "balance",
      "balancing",
      "balcony",
      "balmy",
      "balsamic",
      "bamboo",
      "banana",
      "banish",
      "banister",
      "banjo",
      "bankable",
      "bankbook",
      "banked",
      "banker",
      "banking",
      "banknote",
      "bankroll",
      "banner",
      "bannister",
      "banshee",
      "banter",
      "barbecue",
      "barbed",
      "barbell",
      "barber",
      "barcode",
      "barge",
      "bargraph",
      "barista",
      "baritone",
      "barley",
      "barmaid",
      "barman",
      "barn",
      "barometer",
      "barrack",
      "barracuda",
      "barrel",
      "barrette",
      "barricade",
      "barrier",
      "barstool",
      "bartender",
      "barterer",
      "bash",
      "basically",
      "basics",
      "basil",
      "basin",
      "basis",
      "basket",
      "batboy",
      "batch",
      "bath",
      "baton",
      "bats",
      "battalion",
      "battered",
      "battering",
      "battery",
      "batting",
      "battle",
      "bauble",
      "bazooka",
      "blabber",
      "bladder",
      "blade",
      "blah",
      "blame",
      "blaming",
      "blanching",
      "blandness",
      "blank",
      "blaspheme",
      "blasphemy",
      "blast",
      "blatancy",
      "blatantly",
      "blazer",
      "blazing",
      "bleach",
      "bleak",
      "bleep",
      "blemish",
      "blend",
      "bless",
      "blighted",
      "blimp",
      "bling",
      "blinked",
      "blinker",
      "blinking",
      "blinks",
      "blip",
      "blissful",
      "blitz",
      "blizzard",
      "bloated",
      "bloating",
      "blob",
      "blog",
      "bloomers",
      "blooming",
      "blooper",
      "blot",
      "blouse",
      "blubber",
      "bluff",
      "bluish",
      "blunderer",
      "blunt",
      "blurb",
      "blurred",
      "blurry",
      "blurt",
      "blush",
      "blustery",
      "boaster",
      "boastful",
      "boasting",
      "boat",
      "bobbed",
      "bobbing",
      "bobble",
      "bobcat",
      "bobsled",
      "bobtail",
      "bodacious",
      "body",
      "bogged",
      "boggle",
      "bogus",
      "boil",
      "bok",
      "bolster",
      "bolt",
      "bonanza",
      "bonded",
      "bonding",
      "bondless",
      "boned",
      "bonehead",
      "boneless",
      "bonelike",
      "boney",
      "bonfire",
      "bonnet",
      "bonsai",
      "bonus",
      "bony",
      "boogeyman",
      "boogieman",
      "book",
      "boondocks",
      "booted",
      "booth",
      "bootie",
      "booting",
      "bootlace",
      "bootleg",
      "boots",
      "boozy",
      "borax",
      "boring",
      "borough",
      "borrower",
      "borrowing",
      "boss",
      "botanical",
      "botanist",
      "botany",
      "botch",
      "both",
      "bottle",
      "bottling",
      "bottom",
      "bounce",
      "bouncing",
      "bouncy",
      "bounding",
      "boundless",
      "bountiful",
      "bovine",
      "boxcar",
      "boxer",
      "boxing",
      "boxlike",
      "boxy",
      "breach",
      "breath",
      "breeches",
      "breeching",
      "breeder",
      "breeding",
      "breeze",
      "breezy",
      "brethren",
      "brewery",
      "brewing",
      "briar",
      "bribe",
      "brick",
      "bride",
      "bridged",
      "brigade",
      "bright",
      "brilliant",
      "brim",
      "bring",
      "brink",
      "brisket",
      "briskly",
      "briskness",
      "bristle",
      "brittle",
      "broadband",
      "broadcast",
      "broaden",
      "broadly",
      "broadness",
      "broadside",
      "broadways",
      "broiler",
      "broiling",
      "broken",
      "broker",
      "bronchial",
      "bronco",
      "bronze",
      "bronzing",
      "brook",
      "broom",
      "brought",
      "browbeat",
      "brownnose",
      "browse",
      "browsing",
      "bruising",
      "brunch",
      "brunette",
      "brunt",
      "brush",
      "brussels",
      "brute",
      "brutishly",
      "bubble",
      "bubbling",
      "bubbly",
      "buccaneer",
      "bucked",
      "bucket",
      "buckle",
      "buckshot",
      "buckskin",
      "bucktooth",
      "buckwheat",
      "buddhism",
      "buddhist",
      "budding",
      "buddy",
      "budget",
      "buffalo",
      "buffed",
      "buffer",
      "buffing",
      "buffoon",
      "buggy",
      "bulb",
      "bulge",
      "bulginess",
      "bulgur",
      "bulk",
      "bulldog",
      "bulldozer",
      "bullfight",
      "bullfrog",
      "bullhorn",
      "bullion",
      "bullish",
      "bullpen",
      "bullring",
      "bullseye",
      "bullwhip",
      "bully",
      "bunch",
      "bundle",
      "bungee",
      "bunion",
      "bunkbed",
      "bunkhouse",
      "bunkmate",
      "bunny",
      "bunt",
      "busboy",
      "bush",
      "busily",
      "busload",
      "bust",
      "busybody",
      "buzz",
      "cabana",
      "cabbage",
      "cabbie",
      "cabdriver",
      "cable",
      "caboose",
      "cache",
      "cackle",
      "cacti",
      "cactus",
      "caddie",
      "caddy",
      "cadet",
      "cadillac",
      "cadmium",
      "cage",
      "cahoots",
      "cake",
      "calamari",
      "calamity",
      "calcium",
      "calculate",
      "calculus",
      "caliber",
      "calibrate",
      "calm",
      "caloric",
      "calorie",
      "calzone",
      "camcorder",
      "cameo",
      "camera",
      "camisole",
      "camper",
      "campfire",
      "camping",
      "campsite",
      "campus",
      "canal",
      "canary",
      "cancel",
      "candied",
      "candle",
      "candy",
      "cane",
      "canine",
      "canister",
      "cannabis",
      "canned",
      "canning",
      "cannon",
      "cannot",
      "canola",
      "canon",
      "canopener",
      "canopy",
      "canteen",
      "canyon",
      "capable",
      "capably",
      "capacity",
      "cape",
      "capillary",
      "capital",
      "capitol",
      "capped",
      "capricorn",
      "capsize",
      "capsule",
      "caption",
      "captivate",
      "captive",
      "captivity",
      "capture",
      "caramel",
      "carat",
      "caravan",
      "carbon",
      "cardboard",
      "carded",
      "cardiac",
      "cardigan",
      "cardinal",
      "cardstock",
      "carefully",
      "caregiver",
      "careless",
      "caress",
      "caretaker",
      "cargo",
      "caring",
      "carless",
      "carload",
      "carmaker",
      "carnage",
      "carnation",
      "carnival",
      "carnivore",
      "carol",
      "carpenter",
      "carpentry",
      "carpool",
      "carport",
      "carried",
      "carrot",
      "carrousel",
      "carry",
      "cartel",
      "cartload",
      "carton",
      "cartoon",
      "cartridge",
      "cartwheel",
      "carve",
      "carving",
      "carwash",
      "cascade",
      "case",
      "cash",
      "casing",
      "casino",
      "casket",
      "cassette",
      "casually",
      "casualty",
      "catacomb",
      "catalog",
      "catalyst",
      "catalyze",
      "catapult",
      "cataract",
      "catatonic",
      "catcall",
      "catchable",
      "catcher",
      "catching",
      "catchy",
      "caterer",
      "catering",
      "catfight",
      "catfish",
      "cathedral",
      "cathouse",
      "catlike",
      "catnap",
      "catnip",
      "catsup",
      "cattail",
      "cattishly",
      "cattle",
      "catty",
      "catwalk",
      "caucasian",
      "caucus",
      "causal",
      "causation",
      "cause",
      "causing",
      "cauterize",
      "caution",
      "cautious",
      "cavalier",
      "cavalry",
      "caviar",
      "cavity",
      "cedar",
      "celery",
      "celestial",
      "celibacy",
      "celibate",
      "celtic",
      "cement",
      "census",
      "ceramics",
      "ceremony",
      "certainly",
      "certainty",
      "certified",
      "certify",
      "cesarean",
      "cesspool",
      "chafe",
      "chaffing",
      "chain",
      "chair",
      "chalice",
      "challenge",
      "chamber",
      "chamomile",
      "champion",
      "chance",
      "change",
      "channel",
      "chant",
      "chaos",
      "chaperone",
      "chaplain",
      "chapped",
      "chaps",
      "chapter",
      "character",
      "charbroil",
      "charcoal",
      "charger",
      "charging",
      "chariot",
      "charity",
      "charm",
      "charred",
      "charter",
      "charting",
      "chase",
      "chasing",
      "chaste",
      "chastise",
      "chastity",
      "chatroom",
      "chatter",
      "chatting",
      "chatty",
      "cheating",
      "cheddar",
      "cheek",
      "cheer",
      "cheese",
      "cheesy",
      "chef",
      "chemicals",
      "chemist",
      "chemo",
      "cherisher",
      "cherub",
      "chess",
      "chest",
      "chevron",
      "chevy",
      "chewable",
      "chewer",
      "chewing",
      "chewy",
      "chief",
      "chihuahua",
      "childcare",
      "childhood",
      "childish",
      "childless",
      "childlike",
      "chili",
      "chill",
      "chimp",
      "chip",
      "chirping",
      "chirpy",
      "chitchat",
      "chivalry",
      "chive",
      "chloride",
      "chlorine",
      "choice",
      "chokehold",
      "choking",
      "chomp",
      "chooser",
      "choosing",
      "choosy",
      "chop",
      "chosen",
      "chowder",
      "chowtime",
      "chrome",
      "chubby",
      "chuck",
      "chug",
      "chummy",
      "chump",
      "chunk",
      "churn",
      "chute",
      "cider",
      "cilantro",
      "cinch",
      "cinema",
      "cinnamon",
      "circle",
      "circling",
      "circular",
      "circulate",
      "circus",
      "citable",
      "citadel",
      "citation",
      "citizen",
      "citric",
      "citrus",
      "city",
      "civic",
      "civil",
      "clad",
      "claim",
      "clambake",
      "clammy",
      "clamor",
      "clamp",
      "clamshell",
      "clang",
      "clanking",
      "clapped",
      "clapper",
      "clapping",
      "clarify",
      "clarinet",
      "clarity",
      "clash",
      "clasp",
      "class",
      "clatter",
      "clause",
      "clavicle",
      "claw",
      "clay",
      "clean",
      "clear",
      "cleat",
      "cleaver",
      "cleft",
      "clench",
      "clergyman",
      "clerical",
      "clerk",
      "clever",
      "clicker",
      "client",
      "climate",
      "climatic",
      "cling",
      "clinic",
      "clinking",
      "clip",
      "clique",
      "cloak",
      "clobber",
      "clock",
      "clone",
      "cloning",
      "closable",
      "closure",
      "clothes",
      "clothing",
      "cloud",
      "clover",
      "clubbed",
      "clubbing",
      "clubhouse",
      "clump",
      "clumsily",
      "clumsy",
      "clunky",
      "clustered",
      "clutch",
      "clutter",
      "coach",
      "coagulant",
      "coastal",
      "coaster",
      "coasting",
      "coastland",
      "coastline",
      "coat",
      "coauthor",
      "cobalt",
      "cobbler",
      "cobweb",
      "cocoa",
      "coconut",
      "cod",
      "coeditor",
      "coerce",
      "coexist",
      "coffee",
      "cofounder",
      "cognition",
      "cognitive",
      "cogwheel",
      "coherence",
      "coherent",
      "cohesive",
      "coil",
      "coke",
      "cola",
      "cold",
      "coleslaw",
      "coliseum",
      "collage",
      "collapse",
      "collar",
      "collected",
      "collector",
      "collide",
      "collie",
      "collision",
      "colonial",
      "colonist",
      "colonize",
      "colony",
      "colossal",
      "colt",
      "coma",
      "come",
      "comfort",
      "comfy",
      "comic",
      "coming",
      "comma",
      "commence",
      "commend",
      "comment",
      "commerce",
      "commode",
      "commodity",
      "commodore",
      "common",
      "commotion",
      "commute",
      "commuting",
      "compacted",
      "compacter",
      "compactly",
      "compactor",
      "companion",
      "company",
      "compare",
      "compel",
      "compile",
      "comply",
      "component",
      "composed",
      "composer",
      "composite",
      "compost",
      "composure",
      "compound",
      "compress",
      "comprised",
      "computer",
      "computing",
      "comrade",
      "concave",
      "conceal",
      "conceded",
      "concept",
      "concerned",
      "concert",
      "conch",
      "concierge",
      "concise",
      "conclude",
      "concrete",
      "concur",
      "condense",
      "condiment",
      "condition",
      "condone",
      "conducive",
      "conductor",
      "conduit",
      "cone",
      "confess",
      "confetti",
      "confidant",
      "confident",
      "confider",
      "confiding",
      "configure",
      "confined",
      "confining",
      "confirm",
      "conflict",
      "conform",
      "confound",
      "confront",
      "confused",
      "confusing",
      "confusion",
      "congenial",
      "congested",
      "congrats",
      "congress",
      "conical",
      "conjoined",
      "conjure",
      "conjuror",
      "connected",
      "connector",
      "consensus",
      "consent",
      "console",
      "consoling",
      "consonant",
      "constable",
      "constant",
      "constrain",
      "constrict",
      "construct",
      "consult",
      "consumer",
      "consuming",
      "contact",
      "container",
      "contempt",
      "contend",
      "contented",
      "contently",
      "contents",
      "contest",
      "context",
      "contort",
      "contour",
      "contrite",
      "control",
      "contusion",
      "convene",
      "convent",
      "copartner",
      "cope",
      "copied",
      "copier",
      "copilot",
      "coping",
      "copious",
      "copper",
      "copy",
      "coral",
      "cork",
      "cornball",
      "cornbread",
      "corncob",
      "cornea",
      "corned",
      "corner",
      "cornfield",
      "cornflake",
      "cornhusk",
      "cornmeal",
      "cornstalk",
      "corny",
      "coronary",
      "coroner",
      "corporal",
      "corporate",
      "corral",
      "correct",
      "corridor",
      "corrode",
      "corroding",
      "corrosive",
      "corsage",
      "corset",
      "cortex",
      "cosigner",
      "cosmetics",
      "cosmic",
      "cosmos",
      "cosponsor",
      "cost",
      "cottage",
      "cotton",
      "couch",
      "cough",
      "could",
      "countable",
      "countdown",
      "counting",
      "countless",
      "country",
      "county",
      "courier",
      "covenant",
      "cover",
      "coveted",
      "coveting",
      "coyness",
      "cozily",
      "coziness",
      "cozy",
      "crabbing",
      "crabgrass",
      "crablike",
      "crabmeat",
      "cradle",
      "cradling",
      "crafter",
      "craftily",
      "craftsman",
      "craftwork",
      "crafty",
      "cramp",
      "cranberry",
      "crane",
      "cranial",
      "cranium",
      "crank",
      "crate",
      "crave",
      "craving",
      "crawfish",
      "crawlers",
      "crawling",
      "crayfish",
      "crayon",
      "crazed",
      "crazily",
      "craziness",
      "crazy",
      "creamed",
      "creamer",
      "creamlike",
      "crease",
      "creasing",
      "creatable",
      "create",
      "creation",
      "creative",
      "creature",
      "credible",
      "credibly",
      "credit",
      "creed",
      "creme",
      "creole",
      "crepe",
      "crept",
      "crescent",
      "crested",
      "cresting",
      "crestless",
      "crevice",
      "crewless",
      "crewman",
      "crewmate",
      "crib",
      "cricket",
      "cried",
      "crier",
      "crimp",
      "crimson",
      "cringe",
      "cringing",
      "crinkle",
      "crinkly",
      "crisped",
      "crisping",
      "crisply",
      "crispness",
      "crispy",
      "criteria",
      "critter",
      "croak",
      "crock",
      "crook",
      "croon",
      "crop",
      "cross",
      "crouch",
      "crouton",
      "crowbar",
      "crowd",
      "crown",
      "crucial",
      "crudely",
      "crudeness",
      "cruelly",
      "cruelness",
      "cruelty",
      "crumb",
      "crummiest",
      "crummy",
      "crumpet",
      "crumpled",
      "cruncher",
      "crunching",
      "crunchy",
      "crusader",
      "crushable",
      "crushed",
      "crusher",
      "crushing",
      "crust",
      "crux",
      "crying",
      "cryptic",
      "crystal",
      "cubbyhole",
      "cube",
      "cubical",
      "cubicle",
      "cucumber",
      "cuddle",
      "cuddly",
      "cufflink",
      "culinary",
      "culminate",
      "culpable",
      "culprit",
      "cultivate",
      "cultural",
      "culture",
      "cupbearer",
      "cupcake",
      "cupid",
      "cupped",
      "cupping",
      "curable",
      "curator",
      "curdle",
      "cure",
      "curfew",
      "curing",
      "curled",
      "curler",
      "curliness",
      "curling",
      "curly",
      "curry",
      "curse",
      "cursive",
      "cursor",
      "curtain",
      "curtly",
      "curtsy",
      "curvature",
      "curve",
      "curvy",
      "cushy",
      "cusp",
      "cussed",
      "custard",
      "custodian",
      "custody",
      "customary",
      "customer",
      "customize",
      "customs",
      "cut",
      "cycle",
      "cyclic",
      "cycling",
      "cyclist",
      "cylinder",
      "cymbal",
      "cytoplasm",
      "cytoplast",
      "dab",
      "dad",
      "daffodil",
      "dagger",
      "daily",
      "daintily",
      "dainty",
      "dairy",
      "daisy",
      "dallying",
      "dance",
      "dancing",
      "dandelion",
      "dander",
      "dandruff",
      "dandy",
      "danger",
      "dangle",
      "dangling",
      "daredevil",
      "dares",
      "daringly",
      "darkened",
      "darkening",
      "darkish",
      "darkness",
      "darkroom",
      "darling",
      "darn",
      "dart",
      "darwinism",
      "dash",
      "dastardly",
      "data",
      "datebook",
      "dating",
      "daughter",
      "daunting",
      "dawdler",
      "dawn",
      "daybed",
      "daybreak",
      "daycare",
      "daydream",
      "daylight",
      "daylong",
      "dayroom",
      "daytime",
      "dazzler",
      "dazzling",
      "deacon",
      "deafening",
      "deafness",
      "dealer",
      "dealing",
      "dealmaker",
      "dealt",
      "dean",
      "debatable",
      "debate",
      "debating",
      "debit",
      "debrief",
      "debtless",
      "debtor",
      "debug",
      "debunk",
      "decade",
      "decaf",
      "decal",
      "decathlon",
      "decay",
      "deceased",
      "deceit",
      "deceiver",
      "deceiving",
      "december",
      "decency",
      "decent",
      "deception",
      "deceptive",
      "decibel",
      "decidable",
      "decimal",
      "decimeter",
      "decipher",
      "deck",
      "declared",
      "decline",
      "decode",
      "decompose",
      "decorated",
      "decorator",
      "decoy",
      "decrease",
      "decree",
      "dedicate",
      "dedicator",
      "deduce",
      "deduct",
      "deed",
      "deem",
      "deepen",
      "deeply",
      "deepness",
      "deface",
      "defacing",
      "defame",
      "default",
      "defeat",
      "defection",
      "defective",
      "defendant",
      "defender",
      "defense",
      "defensive",
      "deferral",
      "deferred",
      "defiance",
      "defiant",
      "defile",
      "defiling",
      "define",
      "definite",
      "deflate",
      "deflation",
      "deflator",
      "deflected",
      "deflector",
      "defog",
      "deforest",
      "defraud",
      "defrost",
      "deftly",
      "defuse",
      "defy",
      "degraded",
      "degrading",
      "degrease",
      "degree",
      "dehydrate",
      "deity",
      "dejected",
      "delay",
      "delegate",
      "delegator",
      "delete",
      "deletion",
      "delicacy",
      "delicate",
      "delicious",
      "delighted",
      "delirious",
      "delirium",
      "deliverer",
      "delivery",
      "delouse",
      "delta",
      "deluge",
      "delusion",
      "deluxe",
      "demanding",
      "demeaning",
      "demeanor",
      "demise",
      "democracy",
      "democrat",
      "demote",
      "demotion",
      "demystify",
      "denatured",
      "deniable",
      "denial",
      "denim",
      "denote",
      "dense",
      "density",
      "dental",
      "dentist",
      "denture",
      "deny",
      "deodorant",
      "deodorize",
      "departed",
      "departure",
      "depict",
      "deplete",
      "depletion",
      "deplored",
      "deploy",
      "deport",
      "depose",
      "depraved",
      "depravity",
      "deprecate",
      "depress",
      "deprive",
      "depth",
      "deputize",
      "deputy",
      "derail",
      "deranged",
      "derby",
      "derived",
      "desecrate",
      "deserve",
      "deserving",
      "designate",
      "designed",
      "designer",
      "designing",
      "deskbound",
      "desktop",
      "deskwork",
      "desolate",
      "despair",
      "despise",
      "despite",
      "destiny",
      "destitute",
      "destruct",
      "detached",
      "detail",
      "detection",
      "detective",
      "detector",
      "detention",
      "detergent",
      "detest",
      "detonate",
      "detonator",
      "detoxify",
      "detract",
      "deuce",
      "devalue",
      "deviancy",
      "deviant",
      "deviate",
      "deviation",
      "deviator",
      "device",
      "devious",
      "devotedly",
      "devotee",
      "devotion",
      "devourer",
      "devouring",
      "devoutly",
      "dexterity",
      "dexterous",
      "diabetes",
      "diabetic",
      "diabolic",
      "diagnoses",
      "diagnosis",
      "diagram",
      "dial",
      "diameter",
      "diaper",
      "diaphragm",
      "diary",
      "dice",
      "dicing",
      "dictate",
      "dictation",
      "dictator",
      "difficult",
      "diffused",
      "diffuser",
      "diffusion",
      "diffusive",
      "dig",
      "dilation",
      "diligence",
      "diligent",
      "dill",
      "dilute",
      "dime",
      "diminish",
      "dimly",
      "dimmed",
      "dimmer",
      "dimness",
      "dimple",
      "diner",
      "dingbat",
      "dinghy",
      "dinginess",
      "dingo",
      "dingy",
      "dining",
      "dinner",
      "diocese",
      "dioxide",
      "diploma",
      "dipped",
      "dipper",
      "dipping",
      "directed",
      "direction",
      "directive",
      "directly",
      "directory",
      "direness",
      "dirtiness",
      "disabled",
      "disagree",
      "disallow",
      "disarm",
      "disarray",
      "disaster",
      "disband",
      "disbelief",
      "disburse",
      "discard",
      "discern",
      "discharge",
      "disclose",
      "discolor",
      "discount",
      "discourse",
      "discover",
      "discuss",
      "disdain",
      "disengage",
      "disfigure",
      "disgrace",
      "dish",
      "disinfect",
      "disjoin",
      "disk",
      "dislike",
      "disliking",
      "dislocate",
      "dislodge",
      "disloyal",
      "dismantle",
      "dismay",
      "dismiss",
      "dismount",
      "disobey",
      "disorder",
      "disown",
      "disparate",
      "disparity",
      "dispatch",
      "dispense",
      "dispersal",
      "dispersed",
      "disperser",
      "displace",
      "display",
      "displease",
      "disposal",
      "dispose",
      "disprove",
      "dispute",
      "disregard",
      "disrupt",
      "dissuade",
      "distance",
      "distant",
      "distaste",
      "distill",
      "distinct",
      "distort",
      "distract",
      "distress",
      "district",
      "distrust",
      "ditch",
      "ditto",
      "ditzy",
      "dividable",
      "divided",
      "dividend",
      "dividers",
      "dividing",
      "divinely",
      "diving",
      "divinity",
      "divisible",
      "divisibly",
      "division",
      "divisive",
      "divorcee",
      "dizziness",
      "dizzy",
      "doable",
      "docile",
      "dock",
      "doctrine",
      "document",
      "dodge",
      "dodgy",
      "doily",
      "doing",
      "dole",
      "dollar",
      "dollhouse",
      "dollop",
      "dolly",
      "dolphin",
      "domain",
      "domelike",
      "domestic",
      "dominion",
      "dominoes",
      "donated",
      "donation",
      "donator",
      "donor",
      "donut",
      "doodle",
      "doorbell",
      "doorframe",
      "doorknob",
      "doorman",
      "doormat",
      "doornail",
      "doorpost",
      "doorstep",
      "doorstop",
      "doorway",
      "doozy",
      "dork",
      "dormitory",
      "dorsal",
      "dosage",
      "dose",
      "dotted",
      "doubling",
      "douche",
      "dove",
      "down",
      "dowry",
      "doze",
      "drab",
      "dragging",
      "dragonfly",
      "dragonish",
      "dragster",
      "drainable",
      "drainage",
      "drained",
      "drainer",
      "drainpipe",
      "dramatic",
      "dramatize",
      "drank",
      "drapery",
      "drastic",
      "draw",
      "dreaded",
      "dreadful",
      "dreadlock",
      "dreamboat",
      "dreamily",
      "dreamland",
      "dreamless",
      "dreamlike",
      "dreamt",
      "dreamy",
      "drearily",
      "dreary",
      "drench",
      "dress",
      "drew",
      "dribble",
      "dried",
      "drier",
      "drift",
      "driller",
      "drilling",
      "drinkable",
      "drinking",
      "dripping",
      "drippy",
      "drivable",
      "driven",
      "driver",
      "driveway",
      "driving",
      "drizzle",
      "drizzly",
      "drone",
      "drool",
      "droop",
      "drop-down",
      "dropbox",
      "dropkick",
      "droplet",
      "dropout",
      "dropper",
      "drove",
      "drown",
      "drowsily",
      "drudge",
      "drum",
      "dry",
      "dubbed",
      "dubiously",
      "duchess",
      "duckbill",
      "ducking",
      "duckling",
      "ducktail",
      "ducky",
      "duct",
      "dude",
      "duffel",
      "dugout",
      "duh",
      "duke",
      "duller",
      "dullness",
      "duly",
      "dumping",
      "dumpling",
      "dumpster",
      "duo",
      "dupe",
      "duplex",
      "duplicate",
      "duplicity",
      "durable",
      "durably",
      "duration",
      "duress",
      "during",
      "dusk",
      "dust",
      "dutiful",
      "duty",
      "duvet",
      "dwarf",
      "dweeb",
      "dwelled",
      "dweller",
      "dwelling",
      "dwindle",
      "dwindling",
      "dynamic",
      "dynamite",
      "dynasty",
      "dyslexia",
      "dyslexic",
      "each",
      "eagle",
      "earache",
      "eardrum",
      "earflap",
      "earful",
      "earlobe",
      "early",
      "earmark",
      "earmuff",
      "earphone",
      "earpiece",
      "earplugs",
      "earring",
      "earshot",
      "earthen",
      "earthlike",
      "earthling",
      "earthly",
      "earthworm",
      "earthy",
      "earwig",
      "easeful",
      "easel",
      "easiest",
      "easily",
      "easiness",
      "easing",
      "eastbound",
      "eastcoast",
      "easter",
      "eastward",
      "eatable",
      "eaten",
      "eatery",
      "eating",
      "eats",
      "ebay",
      "ebony",
      "ebook",
      "ecard",
      "eccentric",
      "echo",
      "eclair",
      "eclipse",
      "ecologist",
      "ecology",
      "economic",
      "economist",
      "economy",
      "ecosphere",
      "ecosystem",
      "edge",
      "edginess",
      "edging",
      "edgy",
      "edition",
      "editor",
      "educated",
      "education",
      "educator",
      "eel",
      "effective",
      "effects",
      "efficient",
      "effort",
      "eggbeater",
      "egging",
      "eggnog",
      "eggplant",
      "eggshell",
      "egomaniac",
      "egotism",
      "egotistic",
      "either",
      "eject",
      "elaborate",
      "elastic",
      "elated",
      "elbow",
      "eldercare",
      "elderly",
      "eldest",
      "electable",
      "election",
      "elective",
      "elephant",
      "elevate",
      "elevating",
      "elevation",
      "elevator",
      "eleven",
      "elf",
      "eligible",
      "eligibly",
      "eliminate",
      "elite",
      "elitism",
      "elixir",
      "elk",
      "ellipse",
      "elliptic",
      "elm",
      "elongated",
      "elope",
      "eloquence",
      "eloquent",
      "elsewhere",
      "elude",
      "elusive",
      "elves",
      "email",
      "embargo",
      "embark",
      "embassy",
      "embattled",
      "embellish",
      "ember",
      "embezzle",
      "emblaze",
      "emblem",
      "embody",
      "embolism",
      "emboss",
      "embroider",
      "emcee",
      "emerald",
      "emergency",
      "emission",
      "emit",
      "emote",
      "emoticon",
      "emotion",
      "empathic",
      "empathy",
      "emperor",
      "emphases",
      "emphasis",
      "emphasize",
      "emphatic",
      "empirical",
      "employed",
      "employee",
      "employer",
      "emporium",
      "empower",
      "emptier",
      "emptiness",
      "empty",
      "emu",
      "enable",
      "enactment",
      "enamel",
      "enchanted",
      "enchilada",
      "encircle",
      "enclose",
      "enclosure",
      "encode",
      "encore",
      "encounter",
      "encourage",
      "encroach",
      "encrust",
      "encrypt",
      "endanger",
      "endeared",
      "endearing",
      "ended",
      "ending",
      "endless",
      "endnote",
      "endocrine",
      "endorphin",
      "endorse",
      "endowment",
      "endpoint",
      "endurable",
      "endurance",
      "enduring",
      "energetic",
      "energize",
      "energy",
      "enforced",
      "enforcer",
      "engaged",
      "engaging",
      "engine",
      "engorge",
      "engraved",
      "engraver",
      "engraving",
      "engross",
      "engulf",
      "enhance",
      "enigmatic",
      "enjoyable",
      "enjoyably",
      "enjoyer",
      "enjoying",
      "enjoyment",
      "enlarged",
      "enlarging",
      "enlighten",
      "enlisted",
      "enquirer",
      "enrage",
      "enrich",
      "enroll",
      "enslave",
      "ensnare",
      "ensure",
      "entail",
      "entangled",
      "entering",
      "entertain",
      "enticing",
      "entire",
      "entitle",
      "entity",
      "entomb",
      "entourage",
      "entrap",
      "entree",
      "entrench",
      "entrust",
      "entryway",
      "entwine",
      "enunciate",
      "envelope",
      "enviable",
      "enviably",
      "envious",
      "envision",
      "envoy",
      "envy",
      "enzyme",
      "epic",
      "epidemic",
      "epidermal",
      "epidermis",
      "epidural",
      "epilepsy",
      "epileptic",
      "epilogue",
      "epiphany",
      "episode",
      "equal",
      "equate",
      "equation",
      "equator",
      "equinox",
      "equipment",
      "equity",
      "equivocal",
      "eradicate",
      "erasable",
      "erased",
      "eraser",
      "erasure",
      "ergonomic",
      "errand",
      "errant",
      "erratic",
      "error",
      "erupt",
      "escalate",
      "escalator",
      "escapable",
      "escapade",
      "escapist",
      "escargot",
      "eskimo",
      "esophagus",
      "espionage",
      "espresso",
      "esquire",
      "essay",
      "essence",
      "essential",
      "establish",
      "estate",
      "esteemed",
      "estimate",
      "estimator",
      "estranged",
      "estrogen",
      "etching",
      "eternal",
      "eternity",
      "ethanol",
      "ether",
      "ethically",
      "ethics",
      "euphemism",
      "evacuate",
      "evacuee",
      "evade",
      "evaluate",
      "evaluator",
      "evaporate",
      "evasion",
      "evasive",
      "even",
      "everglade",
      "evergreen",
      "everybody",
      "everyday",
      "everyone",
      "evict",
      "evidence",
      "evident",
      "evil",
      "evoke",
      "evolution",
      "evolve",
      "exact",
      "exalted",
      "example",
      "excavate",
      "excavator",
      "exceeding",
      "exception",
      "excess",
      "exchange",
      "excitable",
      "exciting",
      "exclaim",
      "exclude",
      "excluding",
      "exclusion",
      "exclusive",
      "excretion",
      "excretory",
      "excursion",
      "excusable",
      "excusably",
      "excuse",
      "exemplary",
      "exemplify",
      "exemption",
      "exerciser",
      "exert",
      "exes",
      "exfoliate",
      "exhale",
      "exhaust",
      "exhume",
      "exile",
      "existing",
      "exit",
      "exodus",
      "exonerate",
      "exorcism",
      "exorcist",
      "expand",
      "expanse",
      "expansion",
      "expansive",
      "expectant",
      "expedited",
      "expediter",
      "expel",
      "expend",
      "expenses",
      "expensive",
      "expert",
      "expire",
      "expiring",
      "explain",
      "expletive",
      "explicit",
      "explode",
      "exploit",
      "explore",
      "exploring",
      "exponent",
      "exporter",
      "exposable",
      "expose",
      "exposure",
      "express",
      "expulsion",
      "exquisite",
      "extended",
      "extending",
      "extent",
      "extenuate",
      "exterior",
      "external",
      "extinct",
      "extortion",
      "extradite",
      "extras",
      "extrovert",
      "extrude",
      "extruding",
      "exuberant",
      "fable",
      "fabric",
      "fabulous",
      "facebook",
      "facecloth",
      "facedown",
      "faceless",
      "facelift",
      "faceplate",
      "faceted",
      "facial",
      "facility",
      "facing",
      "facsimile",
      "faction",
      "factoid",
      "factor",
      "factsheet",
      "factual",
      "faculty",
      "fade",
      "fading",
      "failing",
      "falcon",
      "fall",
      "false",
      "falsify",
      "fame",
      "familiar",
      "family",
      "famine",
      "famished",
      "fanatic",
      "fancied",
      "fanciness",
      "fancy",
      "fanfare",
      "fang",
      "fanning",
      "fantasize",
      "fantastic",
      "fantasy",
      "fascism",
      "fastball",
      "faster",
      "fasting",
      "fastness",
      "faucet",
      "favorable",
      "favorably",
      "favored",
      "favoring",
      "favorite",
      "fax",
      "feast",
      "federal",
      "fedora",
      "feeble",
      "feed",
      "feel",
      "feisty",
      "feline",
      "felt-tip",
      "feminine",
      "feminism",
      "feminist",
      "feminize",
      "femur",
      "fence",
      "fencing",
      "fender",
      "ferment",
      "fernlike",
      "ferocious",
      "ferocity",
      "ferret",
      "ferris",
      "ferry",
      "fervor",
      "fester",
      "festival",
      "festive",
      "festivity",
      "fetal",
      "fetch",
      "fever",
      "fiber",
      "fiction",
      "fiddle",
      "fiddling",
      "fidelity",
      "fidgeting",
      "fidgety",
      "fifteen",
      "fifth",
      "fiftieth",
      "fifty",
      "figment",
      "figure",
      "figurine",
      "filing",
      "filled",
      "filler",
      "filling",
      "film",
      "filter",
      "filth",
      "filtrate",
      "finale",
      "finalist",
      "finalize",
      "finally",
      "finance",
      "financial",
      "finch",
      "fineness",
      "finer",
      "finicky",
      "finished",
      "finisher",
      "finishing",
      "finite",
      "finless",
      "finlike",
      "fiscally",
      "fit",
      "five",
      "flaccid",
      "flagman",
      "flagpole",
      "flagship",
      "flagstick",
      "flagstone",
      "flail",
      "flakily",
      "flaky",
      "flame",
      "flammable",
      "flanked",
      "flanking",
      "flannels",
      "flap",
      "flaring",
      "flashback",
      "flashbulb",
      "flashcard",
      "flashily",
      "flashing",
      "flashy",
      "flask",
      "flatbed",
      "flatfoot",
      "flatly",
      "flatness",
      "flatten",
      "flattered",
      "flatterer",
      "flattery",
      "flattop",
      "flatware",
      "flatworm",
      "flavored",
      "flavorful",
      "flavoring",
      "flaxseed",
      "fled",
      "fleshed",
      "fleshy",
      "flick",
      "flier",
      "flight",
      "flinch",
      "fling",
      "flint",
      "flip",
      "flirt",
      "float",
      "flock",
      "flogging",
      "flop",
      "floral",
      "florist",
      "floss",
      "flounder",
      "flyable",
      "flyaway",
      "flyer",
      "flying",
      "flyover",
      "flypaper",
      "foam",
      "foe",
      "fog",
      "foil",
      "folic",
      "folk",
      "follicle",
      "follow",
      "fondling",
      "fondly",
      "fondness",
      "fondue",
      "font",
      "food",
      "fool",
      "footage",
      "football",
      "footbath",
      "footboard",
      "footer",
      "footgear",
      "foothill",
      "foothold",
      "footing",
      "footless",
      "footman",
      "footnote",
      "footpad",
      "footpath",
      "footprint",
      "footrest",
      "footsie",
      "footsore",
      "footwear",
      "footwork",
      "fossil",
      "foster",
      "founder",
      "founding",
      "fountain",
      "fox",
      "foyer",
      "fraction",
      "fracture",
      "fragile",
      "fragility",
      "fragment",
      "fragrance",
      "fragrant",
      "frail",
      "frame",
      "framing",
      "frantic",
      "fraternal",
      "frayed",
      "fraying",
      "frays",
      "freckled",
      "freckles",
      "freebase",
      "freebee",
      "freebie",
      "freedom",
      "freefall",
      "freehand",
      "freeing",
      "freeload",
      "freely",
      "freemason",
      "freeness",
      "freestyle",
      "freeware",
      "freeway",
      "freewill",
      "freezable",
      "freezing",
      "freight",
      "french",
      "frenzied",
      "frenzy",
      "frequency",
      "frequent",
      "fresh",
      "fretful",
      "fretted",
      "friction",
      "friday",
      "fridge",
      "fried",
      "friend",
      "frighten",
      "frightful",
      "frigidity",
      "frigidly",
      "frill",
      "fringe",
      "frisbee",
      "frisk",
      "fritter",
      "frivolous",
      "frolic",
      "from",
      "front",
      "frostbite",
      "frosted",
      "frostily",
      "frosting",
      "frostlike",
      "frosty",
      "froth",
      "frown",
      "frozen",
      "fructose",
      "frugality",
      "frugally",
      "fruit",
      "frustrate",
      "frying",
      "gab",
      "gaffe",
      "gag",
      "gainfully",
      "gaining",
      "gains",
      "gala",
      "gallantly",
      "galleria",
      "gallery",
      "galley",
      "gallon",
      "gallows",
      "gallstone",
      "galore",
      "galvanize",
      "gambling",
      "game",
      "gaming",
      "gamma",
      "gander",
      "gangly",
      "gangrene",
      "gangway",
      "gap",
      "garage",
      "garbage",
      "garden",
      "gargle",
      "garland",
      "garlic",
      "garment",
      "garnet",
      "garnish",
      "garter",
      "gas",
      "gatherer",
      "gathering",
      "gating",
      "gauging",
      "gauntlet",
      "gauze",
      "gave",
      "gawk",
      "gazing",
      "gear",
      "gecko",
      "geek",
      "geiger",
      "gem",
      "gender",
      "generic",
      "generous",
      "genetics",
      "genre",
      "gentile",
      "gentleman",
      "gently",
      "gents",
      "geography",
      "geologic",
      "geologist",
      "geology",
      "geometric",
      "geometry",
      "geranium",
      "gerbil",
      "geriatric",
      "germicide",
      "germinate",
      "germless",
      "germproof",
      "gestate",
      "gestation",
      "gesture",
      "getaway",
      "getting",
      "getup",
      "giant",
      "gibberish",
      "giblet",
      "giddily",
      "giddiness",
      "giddy",
      "gift",
      "gigabyte",
      "gigahertz",
      "gigantic",
      "giggle",
      "giggling",
      "giggly",
      "gigolo",
      "gilled",
      "gills",
      "gimmick",
      "girdle",
      "giveaway",
      "given",
      "giver",
      "giving",
      "gizmo",
      "gizzard",
      "glacial",
      "glacier",
      "glade",
      "gladiator",
      "gladly",
      "glamorous",
      "glamour",
      "glance",
      "glancing",
      "glandular",
      "glare",
      "glaring",
      "glass",
      "glaucoma",
      "glazing",
      "gleaming",
      "gleeful",
      "glider",
      "gliding",
      "glimmer",
      "glimpse",
      "glisten",
      "glitch",
      "glitter",
      "glitzy",
      "gloater",
      "gloating",
      "gloomily",
      "gloomy",
      "glorified",
      "glorifier",
      "glorify",
      "glorious",
      "glory",
      "gloss",
      "glove",
      "glowing",
      "glowworm",
      "glucose",
      "glue",
      "gluten",
      "glutinous",
      "glutton",
      "gnarly",
      "gnat",
      "goal",
      "goatskin",
      "goes",
      "goggles",
      "going",
      "goldfish",
      "goldmine",
      "goldsmith",
      "golf",
      "goliath",
      "gonad",
      "gondola",
      "gone",
      "gong",
      "good",
      "gooey",
      "goofball",
      "goofiness",
      "goofy",
      "google",
      "goon",
      "gopher",
      "gore",
      "gorged",
      "gorgeous",
      "gory",
      "gosling",
      "gossip",
      "gothic",
      "gotten",
      "gout",
      "gown",
      "grab",
      "graceful",
      "graceless",
      "gracious",
      "gradation",
      "graded",
      "grader",
      "gradient",
      "grading",
      "gradually",
      "graduate",
      "graffiti",
      "grafted",
      "grafting",
      "grain",
      "granddad",
      "grandkid",
      "grandly",
      "grandma",
      "grandpa",
      "grandson",
      "granite",
      "granny",
      "granola",
      "grant",
      "granular",
      "grape",
      "graph",
      "grapple",
      "grappling",
      "grasp",
      "grass",
      "gratified",
      "gratify",
      "grating",
      "gratitude",
      "gratuity",
      "gravel",
      "graveness",
      "graves",
      "graveyard",
      "gravitate",
      "gravity",
      "gravy",
      "gray",
      "grazing",
      "greasily",
      "greedily",
      "greedless",
      "greedy",
      "green",
      "greeter",
      "greeting",
      "grew",
      "greyhound",
      "grid",
      "grief",
      "grievance",
      "grieving",
      "grievous",
      "grill",
      "grimace",
      "grimacing",
      "grime",
      "griminess",
      "grimy",
      "grinch",
      "grinning",
      "grip",
      "gristle",
      "grit",
      "groggily",
      "groggy",
      "groin",
      "groom",
      "groove",
      "grooving",
      "groovy",
      "grope",
      "ground",
      "grouped",
      "grout",
      "grove",
      "grower",
      "growing",
      "growl",
      "grub",
      "grudge",
      "grudging",
      "grueling",
      "gruffly",
      "grumble",
      "grumbling",
      "grumbly",
      "grumpily",
      "grunge",
      "grunt",
      "guacamole",
      "guidable",
      "guidance",
      "guide",
      "guiding",
      "guileless",
      "guise",
      "gulf",
      "gullible",
      "gully",
      "gulp",
      "gumball",
      "gumdrop",
      "gumminess",
      "gumming",
      "gummy",
      "gurgle",
      "gurgling",
      "guru",
      "gush",
      "gusto",
      "gusty",
      "gutless",
      "guts",
      "gutter",
      "guy",
      "guzzler",
      "gyration",
      "habitable",
      "habitant",
      "habitat",
      "habitual",
      "hacked",
      "hacker",
      "hacking",
      "hacksaw",
      "had",
      "haggler",
      "haiku",
      "half",
      "halogen",
      "halt",
      "halved",
      "halves",
      "hamburger",
      "hamlet",
      "hammock",
      "hamper",
      "hamster",
      "hamstring",
      "handbag",
      "handball",
      "handbook",
      "handbrake",
      "handcart",
      "handclap",
      "handclasp",
      "handcraft",
      "handcuff",
      "handed",
      "handful",
      "handgrip",
      "handgun",
      "handheld",
      "handiness",
      "handiwork",
      "handlebar",
      "handled",
      "handler",
      "handling",
      "handmade",
      "handoff",
      "handpick",
      "handprint",
      "handrail",
      "handsaw",
      "handset",
      "handsfree",
      "handshake",
      "handstand",
      "handwash",
      "handwork",
      "handwoven",
      "handwrite",
      "handyman",
      "hangnail",
      "hangout",
      "hangover",
      "hangup",
      "hankering",
      "hankie",
      "hanky",
      "haphazard",
      "happening",
      "happier",
      "happiest",
      "happily",
      "happiness",
      "happy",
      "harbor",
      "hardcopy",
      "hardcore",
      "hardcover",
      "harddisk",
      "hardened",
      "hardener",
      "hardening",
      "hardhat",
      "hardhead",
      "hardiness",
      "hardly",
      "hardness",
      "hardship",
      "hardware",
      "hardwired",
      "hardwood",
      "hardy",
      "harmful",
      "harmless",
      "harmonica",
      "harmonics",
      "harmonize",
      "harmony",
      "harness",
      "harpist",
      "harsh",
      "harvest",
      "hash",
      "hassle",
      "haste",
      "hastily",
      "hastiness",
      "hasty",
      "hatbox",
      "hatchback",
      "hatchery",
      "hatchet",
      "hatching",
      "hatchling",
      "hate",
      "hatless",
      "hatred",
      "haunt",
      "haven",
      "hazard",
      "hazelnut",
      "hazily",
      "haziness",
      "hazing",
      "hazy",
      "headache",
      "headband",
      "headboard",
      "headcount",
      "headdress",
      "headed",
      "header",
      "headfirst",
      "headgear",
      "heading",
      "headlamp",
      "headless",
      "headlock",
      "headphone",
      "headpiece",
      "headrest",
      "headroom",
      "headscarf",
      "headset",
      "headsman",
      "headstand",
      "headstone",
      "headway",
      "headwear",
      "heap",
      "heat",
      "heave",
      "heavily",
      "heaviness",
      "heaving",
      "hedge",
      "hedging",
      "heftiness",
      "hefty",
      "helium",
      "helmet",
      "helper",
      "helpful",
      "helping",
      "helpless",
      "helpline",
      "hemlock",
      "hemstitch",
      "hence",
      "henchman",
      "henna",
      "herald",
      "herbal",
      "herbicide",
      "herbs",
      "heritage",
      "hermit",
      "heroics",
      "heroism",
      "herring",
      "herself",
      "hertz",
      "hesitancy",
      "hesitant",
      "hesitate",
      "hexagon",
      "hexagram",
      "hubcap",
      "huddle",
      "huddling",
      "huff",
      "hug",
      "hula",
      "hulk",
      "hull",
      "human",
      "humble",
      "humbling",
      "humbly",
      "humid",
      "humiliate",
      "humility",
      "humming",
      "hummus",
      "humongous",
      "humorist",
      "humorless",
      "humorous",
      "humpback",
      "humped",
      "humvee",
      "hunchback",
      "hundredth",
      "hunger",
      "hungrily",
      "hungry",
      "hunk",
      "hunter",
      "hunting",
      "huntress",
      "huntsman",
      "hurdle",
      "hurled",
      "hurler",
      "hurling",
      "hurray",
      "hurricane",
      "hurried",
      "hurry",
      "hurt",
      "husband",
      "hush",
      "husked",
      "huskiness",
      "hut",
      "hybrid",
      "hydrant",
      "hydrated",
      "hydration",
      "hydrogen",
      "hydroxide",
      "hyperlink",
      "hypertext",
      "hyphen",
      "hypnoses",
      "hypnosis",
      "hypnotic",
      "hypnotism",
      "hypnotist",
      "hypnotize",
      "hypocrisy",
      "hypocrite",
      "ibuprofen",
      "ice",
      "iciness",
      "icing",
      "icky",
      "icon",
      "icy",
      "idealism",
      "idealist",
      "idealize",
      "ideally",
      "idealness",
      "identical",
      "identify",
      "identity",
      "ideology",
      "idiocy",
      "idiom",
      "idly",
      "igloo",
      "ignition",
      "ignore",
      "iguana",
      "illicitly",
      "illusion",
      "illusive",
      "image",
      "imaginary",
      "imagines",
      "imaging",
      "imbecile",
      "imitate",
      "imitation",
      "immature",
      "immerse",
      "immersion",
      "imminent",
      "immobile",
      "immodest",
      "immorally",
      "immortal",
      "immovable",
      "immovably",
      "immunity",
      "immunize",
      "impaired",
      "impale",
      "impart",
      "impatient",
      "impeach",
      "impeding",
      "impending",
      "imperfect",
      "imperial",
      "impish",
      "implant",
      "implement",
      "implicate",
      "implicit",
      "implode",
      "implosion",
      "implosive",
      "imply",
      "impolite",
      "important",
      "importer",
      "impose",
      "imposing",
      "impotence",
      "impotency",
      "impotent",
      "impound",
      "imprecise",
      "imprint",
      "imprison",
      "impromptu",
      "improper",
      "improve",
      "improving",
      "improvise",
      "imprudent",
      "impulse",
      "impulsive",
      "impure",
      "impurity",
      "iodine",
      "iodize",
      "ion",
      "ipad",
      "iphone",
      "ipod",
      "irate",
      "irk",
      "iron",
      "irregular",
      "irrigate",
      "irritable",
      "irritably",
      "irritant",
      "irritate",
      "islamic",
      "islamist",
      "isolated",
      "isolating",
      "isolation",
      "isotope",
      "issue",
      "issuing",
      "italicize",
      "italics",
      "item",
      "itinerary",
      "itunes",
      "ivory",
      "ivy",
      "jab",
      "jackal",
      "jacket",
      "jackknife",
      "jackpot",
      "jailbird",
      "jailbreak",
      "jailer",
      "jailhouse",
      "jalapeno",
      "jam",
      "janitor",
      "january",
      "jargon",
      "jarring",
      "jasmine",
      "jaundice",
      "jaunt",
      "java",
      "jawed",
      "jawless",
      "jawline",
      "jaws",
      "jaybird",
      "jaywalker",
      "jazz",
      "jeep",
      "jeeringly",
      "jellied",
      "jelly",
      "jersey",
      "jester",
      "jet",
      "jiffy",
      "jigsaw",
      "jimmy",
      "jingle",
      "jingling",
      "jinx",
      "jitters",
      "jittery",
      "job",
      "jockey",
      "jockstrap",
      "jogger",
      "jogging",
      "john",
      "joining",
      "jokester",
      "jokingly",
      "jolliness",
      "jolly",
      "jolt",
      "jot",
      "jovial",
      "joyfully",
      "joylessly",
      "joyous",
      "joyride",
      "joystick",
      "jubilance",
      "jubilant",
      "judge",
      "judgingly",
      "judicial",
      "judiciary",
      "judo",
      "juggle",
      "juggling",
      "jugular",
      "juice",
      "juiciness",
      "juicy",
      "jujitsu",
      "jukebox",
      "july",
      "jumble",
      "jumbo",
      "jump",
      "junction",
      "juncture",
      "june",
      "junior",
      "juniper",
      "junkie",
      "junkman",
      "junkyard",
      "jurist",
      "juror",
      "jury",
      "justice",
      "justifier",
      "justify",
      "justly",
      "justness",
      "juvenile",
      "kabob",
      "kangaroo",
      "karaoke",
      "karate",
      "karma",
      "kebab",
      "keenly",
      "keenness",
      "keep",
      "keg",
      "kelp",
      "kennel",
      "kept",
      "kerchief",
      "kerosene",
      "kettle",
      "kick",
      "kiln",
      "kilobyte",
      "kilogram",
      "kilometer",
      "kilowatt",
      "kilt",
      "kimono",
      "kindle",
      "kindling",
      "kindly",
      "kindness",
      "kindred",
      "kinetic",
      "kinfolk",
      "king",
      "kinship",
      "kinsman",
      "kinswoman",
      "kissable",
      "kisser",
      "kissing",
      "kitchen",
      "kite",
      "kitten",
      "kitty",
      "kiwi",
      "kleenex",
      "knapsack",
      "knee",
      "knelt",
      "knickers",
      "knoll",
      "koala",
      "kooky",
      "kosher",
      "krypton",
      "kudos",
      "kung",
      "labored",
      "laborer",
      "laboring",
      "laborious",
      "labrador",
      "ladder",
      "ladies",
      "ladle",
      "ladybug",
      "ladylike",
      "lagged",
      "lagging",
      "lagoon",
      "lair",
      "lake",
      "lance",
      "landed",
      "landfall",
      "landfill",
      "landing",
      "landlady",
      "landless",
      "landline",
      "landlord",
      "landmark",
      "landmass",
      "landmine",
      "landowner",
      "landscape",
      "landside",
      "landslide",
      "language",
      "lankiness",
      "lanky",
      "lantern",
      "lapdog",
      "lapel",
      "lapped",
      "lapping",
      "laptop",
      "lard",
      "large",
      "lark",
      "lash",
      "lasso",
      "last",
      "latch",
      "late",
      "lather",
      "latitude",
      "latrine",
      "latter",
      "latticed",
      "launch",
      "launder",
      "laundry",
      "laurel",
      "lavender",
      "lavish",
      "laxative",
      "lazily",
      "laziness",
      "lazy",
      "lecturer",
      "left",
      "legacy",
      "legal",
      "legend",
      "legged",
      "leggings",
      "legible",
      "legibly",
      "legislate",
      "lego",
      "legroom",
      "legume",
      "legwarmer",
      "legwork",
      "lemon",
      "lend",
      "length",
      "lens",
      "lent",
      "leotard",
      "lesser",
      "letdown",
      "lethargic",
      "lethargy",
      "letter",
      "lettuce",
      "level",
      "leverage",
      "levers",
      "levitate",
      "levitator",
      "liability",
      "liable",
      "liberty",
      "librarian",
      "library",
      "licking",
      "licorice",
      "lid",
      "life",
      "lifter",
      "lifting",
      "liftoff",
      "ligament",
      "likely",
      "likeness",
      "likewise",
      "liking",
      "lilac",
      "lilly",
      "lily",
      "limb",
      "limeade",
      "limelight",
      "limes",
      "limit",
      "limping",
      "limpness",
      "line",
      "lingo",
      "linguini",
      "linguist",
      "lining",
      "linked",
      "linoleum",
      "linseed",
      "lint",
      "lion",
      "lip",
      "liquefy",
      "liqueur",
      "liquid",
      "lisp",
      "list",
      "litigate",
      "litigator",
      "litmus",
      "litter",
      "little",
      "livable",
      "lived",
      "lively",
      "liver",
      "livestock",
      "lividly",
      "living",
      "lizard",
      "lubricant",
      "lubricate",
      "lucid",
      "luckily",
      "luckiness",
      "luckless",
      "lucrative",
      "ludicrous",
      "lugged",
      "lukewarm",
      "lullaby",
      "lumber",
      "luminance",
      "luminous",
      "lumpiness",
      "lumping",
      "lumpish",
      "lunacy",
      "lunar",
      "lunchbox",
      "luncheon",
      "lunchroom",
      "lunchtime",
      "lung",
      "lurch",
      "lure",
      "luridness",
      "lurk",
      "lushly",
      "lushness",
      "luster",
      "lustfully",
      "lustily",
      "lustiness",
      "lustrous",
      "lusty",
      "luxurious",
      "luxury",
      "lying",
      "lyrically",
      "lyricism",
      "lyricist",
      "lyrics",
      "macarena",
      "macaroni",
      "macaw",
      "mace",
      "machine",
      "machinist",
      "magazine",
      "magenta",
      "maggot",
      "magical",
      "magician",
      "magma",
      "magnesium",
      "magnetic",
      "magnetism",
      "magnetize",
      "magnifier",
      "magnify",
      "magnitude",
      "magnolia",
      "mahogany",
      "maimed",
      "majestic",
      "majesty",
      "majorette",
      "majority",
      "makeover",
      "maker",
      "makeshift",
      "making",
      "malformed",
      "malt",
      "mama",
      "mammal",
      "mammary",
      "mammogram",
      "manager",
      "managing",
      "manatee",
      "mandarin",
      "mandate",
      "mandatory",
      "mandolin",
      "manger",
      "mangle",
      "mango",
      "mangy",
      "manhandle",
      "manhole",
      "manhood",
      "manhunt",
      "manicotti",
      "manicure",
      "manifesto",
      "manila",
      "mankind",
      "manlike",
      "manliness",
      "manly",
      "manmade",
      "manned",
      "mannish",
      "manor",
      "manpower",
      "mantis",
      "mantra",
      "manual",
      "many",
      "map",
      "marathon",
      "marauding",
      "marbled",
      "marbles",
      "marbling",
      "march",
      "mardi",
      "margarine",
      "margarita",
      "margin",
      "marigold",
      "marina",
      "marine",
      "marital",
      "maritime",
      "marlin",
      "marmalade",
      "maroon",
      "married",
      "marrow",
      "marry",
      "marshland",
      "marshy",
      "marsupial",
      "marvelous",
      "marxism",
      "mascot",
      "masculine",
      "mashed",
      "mashing",
      "massager",
      "masses",
      "massive",
      "mastiff",
      "matador",
      "matchbook",
      "matchbox",
      "matcher",
      "matching",
      "matchless",
      "material",
      "maternal",
      "maternity",
      "math",
      "mating",
      "matriarch",
      "matrimony",
      "matrix",
      "matron",
      "matted",
      "matter",
      "maturely",
      "maturing",
      "maturity",
      "mauve",
      "maverick",
      "maximize",
      "maximum",
      "maybe",
      "mayday",
      "mayflower",
      "moaner",
      "moaning",
      "mobile",
      "mobility",
      "mobilize",
      "mobster",
      "mocha",
      "mocker",
      "mockup",
      "modified",
      "modify",
      "modular",
      "modulator",
      "module",
      "moisten",
      "moistness",
      "moisture",
      "molar",
      "molasses",
      "mold",
      "molecular",
      "molecule",
      "molehill",
      "mollusk",
      "mom",
      "monastery",
      "monday",
      "monetary",
      "monetize",
      "moneybags",
      "moneyless",
      "moneywise",
      "mongoose",
      "mongrel",
      "monitor",
      "monkhood",
      "monogamy",
      "monogram",
      "monologue",
      "monopoly",
      "monorail",
      "monotone",
      "monotype",
      "monoxide",
      "monsieur",
      "monsoon",
      "monstrous",
      "monthly",
      "monument",
      "moocher",
      "moodiness",
      "moody",
      "mooing",
      "moonbeam",
      "mooned",
      "moonlight",
      "moonlike",
      "moonlit",
      "moonrise",
      "moonscape",
      "moonshine",
      "moonstone",
      "moonwalk",
      "mop",
      "morale",
      "morality",
      "morally",
      "morbidity",
      "morbidly",
      "morphine",
      "morphing",
      "morse",
      "mortality",
      "mortally",
      "mortician",
      "mortified",
      "mortify",
      "mortuary",
      "mosaic",
      "mossy",
      "most",
      "mothball",
      "mothproof",
      "motion",
      "motivate",
      "motivator",
      "motive",
      "motocross",
      "motor",
      "motto",
      "mountable",
      "mountain",
      "mounted",
      "mounting",
      "mourner",
      "mournful",
      "mouse",
      "mousiness",
      "moustache",
      "mousy",
      "mouth",
      "movable",
      "move",
      "movie",
      "moving",
      "mower",
      "mowing",
      "much",
      "muck",
      "mud",
      "mug",
      "mulberry",
      "mulch",
      "mule",
      "mulled",
      "mullets",
      "multiple",
      "multiply",
      "multitask",
      "multitude",
      "mumble",
      "mumbling",
      "mumbo",
      "mummified",
      "mummify",
      "mummy",
      "mumps",
      "munchkin",
      "mundane",
      "municipal",
      "muppet",
      "mural",
      "murkiness",
      "murky",
      "murmuring",
      "muscular",
      "museum",
      "mushily",
      "mushiness",
      "mushroom",
      "mushy",
      "music",
      "musket",
      "muskiness",
      "musky",
      "mustang",
      "mustard",
      "muster",
      "mustiness",
      "musty",
      "mutable",
      "mutate",
      "mutation",
      "mute",
      "mutilated",
      "mutilator",
      "mutiny",
      "mutt",
      "mutual",
      "muzzle",
      "myself",
      "myspace",
      "mystified",
      "mystify",
      "myth",
      "nacho",
      "nag",
      "nail",
      "name",
      "naming",
      "nanny",
      "nanometer",
      "nape",
      "napkin",
      "napped",
      "napping",
      "nappy",
      "narrow",
      "nastily",
      "nastiness",
      "national",
      "native",
      "nativity",
      "natural",
      "nature",
      "naturist",
      "nautical",
      "navigate",
      "navigator",
      "navy",
      "nearby",
      "nearest",
      "nearly",
      "nearness",
      "neatly",
      "neatness",
      "nebula",
      "nebulizer",
      "nectar",
      "negate",
      "negation",
      "negative",
      "neglector",
      "negligee",
      "negligent",
      "negotiate",
      "nemeses",
      "nemesis",
      "neon",
      "nephew",
      "nerd",
      "nervous",
      "nervy",
      "nest",
      "net",
      "neurology",
      "neuron",
      "neurosis",
      "neurotic",
      "neuter",
      "neutron",
      "never",
      "next",
      "nibble",
      "nickname",
      "nicotine",
      "niece",
      "nifty",
      "nimble",
      "nimbly",
      "nineteen",
      "ninetieth",
      "ninja",
      "nintendo",
      "ninth",
      "nuclear",
      "nuclei",
      "nucleus",
      "nugget",
      "nullify",
      "number",
      "numbing",
      "numbly",
      "numbness",
      "numeral",
      "numerate",
      "numerator",
      "numeric",
      "numerous",
      "nuptials",
      "nursery",
      "nursing",
      "nurture",
      "nutcase",
      "nutlike",
      "nutmeg",
      "nutrient",
      "nutshell",
      "nuttiness",
      "nutty",
      "nuzzle",
      "nylon",
      "oaf",
      "oak",
      "oasis",
      "oat",
      "obedience",
      "obedient",
      "obituary",
      "object",
      "obligate",
      "obliged",
      "oblivion",
      "oblivious",
      "oblong",
      "obnoxious",
      "oboe",
      "obscure",
      "obscurity",
      "observant",
      "observer",
      "observing",
      "obsessed",
      "obsession",
      "obsessive",
      "obsolete",
      "obstacle",
      "obstinate",
      "obstruct",
      "obtain",
      "obtrusive",
      "obtuse",
      "obvious",
      "occultist",
      "occupancy",
      "occupant",
      "occupier",
      "occupy",
      "ocean",
      "ocelot",
      "octagon",
      "octane",
      "october",
      "octopus",
      "ogle",
      "oil",
      "oink",
      "ointment",
      "okay",
      "old",
      "olive",
      "olympics",
      "omega",
      "omen",
      "ominous",
      "omission",
      "omit",
      "omnivore",
      "onboard",
      "oncoming",
      "ongoing",
      "onion",
      "online",
      "onlooker",
      "only",
      "onscreen",
      "onset",
      "onshore",
      "onslaught",
      "onstage",
      "onto",
      "onward",
      "onyx",
      "oops",
      "ooze",
      "oozy",
      "opacity",
      "opal",
      "open",
      "operable",
      "operate",
      "operating",
      "operation",
      "operative",
      "operator",
      "opium",
      "opossum",
      "opponent",
      "oppose",
      "opposing",
      "opposite",
      "oppressed",
      "oppressor",
      "opt",
      "opulently",
      "osmosis",
      "other",
      "otter",
      "ouch",
      "ought",
      "ounce",
      "outage",
      "outback",
      "outbid",
      "outboard",
      "outbound",
      "outbreak",
      "outburst",
      "outcast",
      "outclass",
      "outcome",
      "outdated",
      "outdoors",
      "outer",
      "outfield",
      "outfit",
      "outflank",
      "outgoing",
      "outgrow",
      "outhouse",
      "outing",
      "outlast",
      "outlet",
      "outline",
      "outlook",
      "outlying",
      "outmatch",
      "outmost",
      "outnumber",
      "outplayed",
      "outpost",
      "outpour",
      "output",
      "outrage",
      "outrank",
      "outreach",
      "outright",
      "outscore",
      "outsell",
      "outshine",
      "outshoot",
      "outsider",
      "outskirts",
      "outsmart",
      "outsource",
      "outspoken",
      "outtakes",
      "outthink",
      "outward",
      "outweigh",
      "outwit",
      "oval",
      "ovary",
      "oven",
      "overact",
      "overall",
      "overarch",
      "overbid",
      "overbill",
      "overbite",
      "overblown",
      "overboard",
      "overbook",
      "overbuilt",
      "overcast",
      "overcoat",
      "overcome",
      "overcook",
      "overcrowd",
      "overdraft",
      "overdrawn",
      "overdress",
      "overdrive",
      "overdue",
      "overeager",
      "overeater",
      "overexert",
      "overfed",
      "overfeed",
      "overfill",
      "overflow",
      "overfull",
      "overgrown",
      "overhand",
      "overhang",
      "overhaul",
      "overhead",
      "overhear",
      "overheat",
      "overhung",
      "overjoyed",
      "overkill",
      "overlabor",
      "overlaid",
      "overlap",
      "overlay",
      "overload",
      "overlook",
      "overlord",
      "overlying",
      "overnight",
      "overpass",
      "overpay",
      "overplant",
      "overplay",
      "overpower",
      "overprice",
      "overrate",
      "overreach",
      "overreact",
      "override",
      "overripe",
      "overrule",
      "overrun",
      "overshoot",
      "overshot",
      "oversight",
      "oversized",
      "oversleep",
      "oversold",
      "overspend",
      "overstate",
      "overstay",
      "overstep",
      "overstock",
      "overstuff",
      "oversweet",
      "overtake",
      "overthrow",
      "overtime",
      "overtly",
      "overtone",
      "overture",
      "overturn",
      "overuse",
      "overvalue",
      "overview",
      "overwrite",
      "owl",
      "oxford",
      "oxidant",
      "oxidation",
      "oxidize",
      "oxidizing",
      "oxygen",
      "oxymoron",
      "oyster",
      "ozone",
      "paced",
      "pacemaker",
      "pacific",
      "pacifier",
      "pacifism",
      "pacifist",
      "pacify",
      "padded",
      "padding",
      "paddle",
      "paddling",
      "padlock",
      "pagan",
      "pager",
      "paging",
      "pajamas",
      "palace",
      "palatable",
      "palm",
      "palpable",
      "palpitate",
      "paltry",
      "pampered",
      "pamperer",
      "pampers",
      "pamphlet",
      "panama",
      "pancake",
      "pancreas",
      "panda",
      "pandemic",
      "pang",
      "panhandle",
      "panic",
      "panning",
      "panorama",
      "panoramic",
      "panther",
      "pantomime",
      "pantry",
      "pants",
      "pantyhose",
      "paparazzi",
      "papaya",
      "paper",
      "paprika",
      "papyrus",
      "parabola",
      "parachute",
      "parade",
      "paradox",
      "paragraph",
      "parakeet",
      "paralegal",
      "paralyses",
      "paralysis",
      "paralyze",
      "paramedic",
      "parameter",
      "paramount",
      "parasail",
      "parasite",
      "parasitic",
      "parcel",
      "parched",
      "parchment",
      "pardon",
      "parish",
      "parka",
      "parking",
      "parkway",
      "parlor",
      "parmesan",
      "parole",
      "parrot",
      "parsley",
      "parsnip",
      "partake",
      "parted",
      "parting",
      "partition",
      "partly",
      "partner",
      "partridge",
      "party",
      "passable",
      "passably",
      "passage",
      "passcode",
      "passenger",
      "passerby",
      "passing",
      "passion",
      "passive",
      "passivism",
      "passover",
      "passport",
      "password",
      "pasta",
      "pasted",
      "pastel",
      "pastime",
      "pastor",
      "pastrami",
      "pasture",
      "pasty",
      "patchwork",
      "patchy",
      "paternal",
      "paternity",
      "path",
      "patience",
      "patient",
      "patio",
      "patriarch",
      "patriot",
      "patrol",
      "patronage",
      "patronize",
      "pauper",
      "pavement",
      "paver",
      "pavestone",
      "pavilion",
      "paving",
      "pawing",
      "payable",
      "payback",
      "paycheck",
      "payday",
      "payee",
      "payer",
      "paying",
      "payment",
      "payphone",
      "payroll",
      "pebble",
      "pebbly",
      "pecan",
      "pectin",
      "peculiar",
      "peddling",
      "pediatric",
      "pedicure",
      "pedigree",
      "pedometer",
      "pegboard",
      "pelican",
      "pellet",
      "pelt",
      "pelvis",
      "penalize",
      "penalty",
      "pencil",
      "pendant",
      "pending",
      "penholder",
      "penknife",
      "pennant",
      "penniless",
      "penny",
      "penpal",
      "pension",
      "pentagon",
      "pentagram",
      "pep",
      "perceive",
      "percent",
      "perch",
      "percolate",
      "perennial",
      "perfected",
      "perfectly",
      "perfume",
      "periscope",
      "perish",
      "perjurer",
      "perjury",
      "perkiness",
      "perky",
      "perm",
      "peroxide",
      "perpetual",
      "perplexed",
      "persecute",
      "persevere",
      "persuaded",
      "persuader",
      "pesky",
      "peso",
      "pessimism",
      "pessimist",
      "pester",
      "pesticide",
      "petal",
      "petite",
      "petition",
      "petri",
      "petroleum",
      "petted",
      "petticoat",
      "pettiness",
      "petty",
      "petunia",
      "phantom",
      "phobia",
      "phoenix",
      "phonebook",
      "phoney",
      "phonics",
      "phoniness",
      "phony",
      "phosphate",
      "photo",
      "phrase",
      "phrasing",
      "placard",
      "placate",
      "placidly",
      "plank",
      "planner",
      "plant",
      "plasma",
      "plaster",
      "plastic",
      "plated",
      "platform",
      "plating",
      "platinum",
      "platonic",
      "platter",
      "platypus",
      "plausible",
      "plausibly",
      "playable",
      "playback",
      "player",
      "playful",
      "playgroup",
      "playhouse",
      "playing",
      "playlist",
      "playmaker",
      "playmate",
      "playoff",
      "playpen",
      "playroom",
      "playset",
      "plaything",
      "playtime",
      "plaza",
      "pleading",
      "pleat",
      "pledge",
      "plentiful",
      "plenty",
      "plethora",
      "plexiglas",
      "pliable",
      "plod",
      "plop",
      "plot",
      "plow",
      "ploy",
      "pluck",
      "plug",
      "plunder",
      "plunging",
      "plural",
      "plus",
      "plutonium",
      "plywood",
      "poach",
      "pod",
      "poem",
      "poet",
      "pogo",
      "pointed",
      "pointer",
      "pointing",
      "pointless",
      "pointy",
      "poise",
      "poison",
      "poker",
      "poking",
      "polar",
      "police",
      "policy",
      "polio",
      "polish",
      "politely",
      "polka",
      "polo",
      "polyester",
      "polygon",
      "polygraph",
      "polymer",
      "poncho",
      "pond",
      "pony",
      "popcorn",
      "pope",
      "poplar",
      "popper",
      "poppy",
      "popsicle",
      "populace",
      "popular",
      "populate",
      "porcupine",
      "pork",
      "porous",
      "porridge",
      "portable",
      "portal",
      "portfolio",
      "porthole",
      "portion",
      "portly",
      "portside",
      "poser",
      "posh",
      "posing",
      "possible",
      "possibly",
      "possum",
      "postage",
      "postal",
      "postbox",
      "postcard",
      "posted",
      "poster",
      "posting",
      "postnasal",
      "posture",
      "postwar",
      "pouch",
      "pounce",
      "pouncing",
      "pound",
      "pouring",
      "pout",
      "powdered",
      "powdering",
      "powdery",
      "power",
      "powwow",
      "pox",
      "praising",
      "prance",
      "prancing",
      "pranker",
      "prankish",
      "prankster",
      "prayer",
      "praying",
      "preacher",
      "preaching",
      "preachy",
      "preamble",
      "precinct",
      "precise",
      "precision",
      "precook",
      "precut",
      "predator",
      "predefine",
      "predict",
      "preface",
      "prefix",
      "preflight",
      "preformed",
      "pregame",
      "pregnancy",
      "pregnant",
      "preheated",
      "prelaunch",
      "prelaw",
      "prelude",
      "premiere",
      "premises",
      "premium",
      "prenatal",
      "preoccupy",
      "preorder",
      "prepaid",
      "prepay",
      "preplan",
      "preppy",
      "preschool",
      "prescribe",
      "preseason",
      "preset",
      "preshow",
      "president",
      "presoak",
      "press",
      "presume",
      "presuming",
      "preteen",
      "pretended",
      "pretender",
      "pretense",
      "pretext",
      "pretty",
      "pretzel",
      "prevail",
      "prevalent",
      "prevent",
      "preview",
      "previous",
      "prewar",
      "prewashed",
      "prideful",
      "pried",
      "primal",
      "primarily",
      "primary",
      "primate",
      "primer",
      "primp",
      "princess",
      "print",
      "prior",
      "prism",
      "prison",
      "prissy",
      "pristine",
      "privacy",
      "private",
      "privatize",
      "prize",
      "proactive",
      "probable",
      "probably",
      "probation",
      "probe",
      "probing",
      "probiotic",
      "problem",
      "procedure",
      "process",
      "proclaim",
      "procreate",
      "procurer",
      "prodigal",
      "prodigy",
      "produce",
      "product",
      "profane",
      "profanity",
      "professed",
      "professor",
      "profile",
      "profound",
      "profusely",
      "progeny",
      "prognosis",
      "program",
      "progress",
      "projector",
      "prologue",
      "prolonged",
      "promenade",
      "prominent",
      "promoter",
      "promotion",
      "prompter",
      "promptly",
      "prone",
      "prong",
      "pronounce",
      "pronto",
      "proofing",
      "proofread",
      "proofs",
      "propeller",
      "properly",
      "property",
      "proponent",
      "proposal",
      "propose",
      "props",
      "prorate",
      "protector",
      "protegee",
      "proton",
      "prototype",
      "protozoan",
      "protract",
      "protrude",
      "proud",
      "provable",
      "proved",
      "proven",
      "provided",
      "provider",
      "providing",
      "province",
      "proving",
      "provoke",
      "provoking",
      "provolone",
      "prowess",
      "prowler",
      "prowling",
      "proximity",
      "proxy",
      "prozac",
      "prude",
      "prudishly",
      "prune",
      "pruning",
      "pry",
      "psychic",
      "public",
      "publisher",
      "pucker",
      "pueblo",
      "pug",
      "pull",
      "pulmonary",
      "pulp",
      "pulsate",
      "pulse",
      "pulverize",
      "puma",
      "pumice",
      "pummel",
      "punch",
      "punctual",
      "punctuate",
      "punctured",
      "pungent",
      "punisher",
      "punk",
      "pupil",
      "puppet",
      "puppy",
      "purchase",
      "pureblood",
      "purebred",
      "purely",
      "pureness",
      "purgatory",
      "purge",
      "purging",
      "purifier",
      "purify",
      "purist",
      "puritan",
      "purity",
      "purple",
      "purplish",
      "purposely",
      "purr",
      "purse",
      "pursuable",
      "pursuant",
      "pursuit",
      "purveyor",
      "pushcart",
      "pushchair",
      "pusher",
      "pushiness",
      "pushing",
      "pushover",
      "pushpin",
      "pushup",
      "pushy",
      "putdown",
      "putt",
      "puzzle",
      "puzzling",
      "pyramid",
      "pyromania",
      "python",
      "quack",
      "quadrant",
      "quail",
      "quaintly",
      "quake",
      "quaking",
      "qualified",
      "qualifier",
      "qualify",
      "quality",
      "qualm",
      "quantum",
      "quarrel",
      "quarry",
      "quartered",
      "quarterly",
      "quarters",
      "quartet",
      "quench",
      "query",
      "quicken",
      "quickly",
      "quickness",
      "quicksand",
      "quickstep",
      "quiet",
      "quill",
      "quilt",
      "quintet",
      "quintuple",
      "quirk",
      "quit",
      "quiver",
      "quizzical",
      "quotable",
      "quotation",
      "quote",
      "rabid",
      "race",
      "racing",
      "racism",
      "rack",
      "racoon",
      "radar",
      "radial",
      "radiance",
      "radiantly",
      "radiated",
      "radiation",
      "radiator",
      "radio",
      "radish",
      "raffle",
      "raft",
      "rage",
      "ragged",
      "raging",
      "ragweed",
      "raider",
      "railcar",
      "railing",
      "railroad",
      "railway",
      "raisin",
      "rake",
      "raking",
      "rally",
      "ramble",
      "rambling",
      "ramp",
      "ramrod",
      "ranch",
      "rancidity",
      "random",
      "ranged",
      "ranger",
      "ranging",
      "ranked",
      "ranking",
      "ransack",
      "ranting",
      "rants",
      "rare",
      "rarity",
      "rascal",
      "rash",
      "rasping",
      "ravage",
      "raven",
      "ravine",
      "raving",
      "ravioli",
      "ravishing",
      "reabsorb",
      "reach",
      "reacquire",
      "reaction",
      "reactive",
      "reactor",
      "reaffirm",
      "ream",
      "reanalyze",
      "reappear",
      "reapply",
      "reappoint",
      "reapprove",
      "rearrange",
      "rearview",
      "reason",
      "reassign",
      "reassure",
      "reattach",
      "reawake",
      "rebalance",
      "rebate",
      "rebel",
      "rebirth",
      "reboot",
      "reborn",
      "rebound",
      "rebuff",
      "rebuild",
      "rebuilt",
      "reburial",
      "rebuttal",
      "recall",
      "recant",
      "recapture",
      "recast",
      "recede",
      "recent",
      "recess",
      "recharger",
      "recipient",
      "recital",
      "recite",
      "reckless",
      "reclaim",
      "recliner",
      "reclining",
      "recluse",
      "reclusive",
      "recognize",
      "recoil",
      "recollect",
      "recolor",
      "reconcile",
      "reconfirm",
      "reconvene",
      "recopy",
      "record",
      "recount",
      "recoup",
      "recovery",
      "recreate",
      "rectal",
      "rectangle",
      "rectified",
      "rectify",
      "recycled",
      "recycler",
      "recycling",
      "reemerge",
      "reenact",
      "reenter",
      "reentry",
      "reexamine",
      "referable",
      "referee",
      "reference",
      "refill",
      "refinance",
      "refined",
      "refinery",
      "refining",
      "refinish",
      "reflected",
      "reflector",
      "reflex",
      "reflux",
      "refocus",
      "refold",
      "reforest",
      "reformat",
      "reformed",
      "reformer",
      "reformist",
      "refract",
      "refrain",
      "refreeze",
      "refresh",
      "refried",
      "refueling",
      "refund",
      "refurbish",
      "refurnish",
      "refusal",
      "refuse",
      "refusing",
      "refutable",
      "refute",
      "regain",
      "regalia",
      "regally",
      "reggae",
      "regime",
      "region",
      "register",
      "registrar",
      "registry",
      "regress",
      "regretful",
      "regroup",
      "regular",
      "regulate",
      "regulator",
      "rehab",
      "reheat",
      "rehire",
      "rehydrate",
      "reimburse",
      "reissue",
      "reiterate",
      "rejoice",
      "rejoicing",
      "rejoin",
      "rekindle",
      "relapse",
      "relapsing",
      "relatable",
      "related",
      "relation",
      "relative",
      "relax",
      "relay",
      "relearn",
      "release",
      "relenting",
      "reliable",
      "reliably",
      "reliance",
      "reliant",
      "relic",
      "relieve",
      "relieving",
      "relight",
      "relish",
      "relive",
      "reload",
      "relocate",
      "relock",
      "reluctant",
      "rely",
      "remake",
      "remark",
      "remarry",
      "rematch",
      "remedial",
      "remedy",
      "remember",
      "reminder",
      "remindful",
      "remission",
      "remix",
      "remnant",
      "remodeler",
      "remold",
      "remorse",
      "remote",
      "removable",
      "removal",
      "removed",
      "remover",
      "removing",
      "rename",
      "renderer",
      "rendering",
      "rendition",
      "renegade",
      "renewable",
      "renewably",
      "renewal",
      "renewed",
      "renounce",
      "renovate",
      "renovator",
      "rentable",
      "rental",
      "rented",
      "renter",
      "reoccupy",
      "reoccur",
      "reopen",
      "reorder",
      "repackage",
      "repacking",
      "repaint",
      "repair",
      "repave",
      "repaying",
      "repayment",
      "repeal",
      "repeated",
      "repeater",
      "repent",
      "rephrase",
      "replace",
      "replay",
      "replica",
      "reply",
      "reporter",
      "repose",
      "repossess",
      "repost",
      "repressed",
      "reprimand",
      "reprint",
      "reprise",
      "reproach",
      "reprocess",
      "reproduce",
      "reprogram",
      "reps",
      "reptile",
      "reptilian",
      "repugnant",
      "repulsion",
      "repulsive",
      "repurpose",
      "reputable",
      "reputably",
      "request",
      "require",
      "requisite",
      "reroute",
      "rerun",
      "resale",
      "resample",
      "rescuer",
      "reseal",
      "research",
      "reselect",
      "reseller",
      "resemble",
      "resend",
      "resent",
      "reset",
      "reshape",
      "reshoot",
      "reshuffle",
      "residence",
      "residency",
      "resident",
      "residual",
      "residue",
      "resigned",
      "resilient",
      "resistant",
      "resisting",
      "resize",
      "resolute",
      "resolved",
      "resonant",
      "resonate",
      "resort",
      "resource",
      "respect",
      "resubmit",
      "result",
      "resume",
      "resupply",
      "resurface",
      "resurrect",
      "retail",
      "retainer",
      "retaining",
      "retake",
      "retaliate",
      "retention",
      "rethink",
      "retinal",
      "retired",
      "retiree",
      "retiring",
      "retold",
      "retool",
      "retorted",
      "retouch",
      "retrace",
      "retract",
      "retrain",
      "retread",
      "retreat",
      "retrial",
      "retrieval",
      "retriever",
      "retry",
      "return",
      "retying",
      "retype",
      "reunion",
      "reunite",
      "reusable",
      "reuse",
      "reveal",
      "reveler",
      "revenge",
      "revenue",
      "reverb",
      "revered",
      "reverence",
      "reverend",
      "reversal",
      "reverse",
      "reversing",
      "reversion",
      "revert",
      "revisable",
      "revise",
      "revision",
      "revisit",
      "revivable",
      "revival",
      "reviver",
      "reviving",
      "revocable",
      "revoke",
      "revolt",
      "revolver",
      "revolving",
      "reward",
      "rewash",
      "rewind",
      "rewire",
      "reword",
      "rework",
      "rewrap",
      "rewrite",
      "rhyme",
      "ribbon",
      "ribcage",
      "rice",
      "riches",
      "richly",
      "richness",
      "rickety",
      "ricotta",
      "riddance",
      "ridden",
      "ride",
      "riding",
      "rifling",
      "rift",
      "rigging",
      "rigid",
      "rigor",
      "rimless",
      "rimmed",
      "rind",
      "rink",
      "rinse",
      "rinsing",
      "riot",
      "ripcord",
      "ripeness",
      "ripening",
      "ripping",
      "ripple",
      "rippling",
      "riptide",
      "rise",
      "rising",
      "risk",
      "risotto",
      "ritalin",
      "ritzy",
      "rival",
      "riverbank",
      "riverbed",
      "riverboat",
      "riverside",
      "riveter",
      "riveting",
      "roamer",
      "roaming",
      "roast",
      "robbing",
      "robe",
      "robin",
      "robotics",
      "robust",
      "rockband",
      "rocker",
      "rocket",
      "rockfish",
      "rockiness",
      "rocking",
      "rocklike",
      "rockslide",
      "rockstar",
      "rocky",
      "rogue",
      "roman",
      "romp",
      "rope",
      "roping",
      "roster",
      "rosy",
      "rotten",
      "rotting",
      "rotunda",
      "roulette",
      "rounding",
      "roundish",
      "roundness",
      "roundup",
      "roundworm",
      "routine",
      "routing",
      "rover",
      "roving",
      "royal",
      "rubbed",
      "rubber",
      "rubbing",
      "rubble",
      "rubdown",
      "ruby",
      "ruckus",
      "rudder",
      "rug",
      "ruined",
      "rule",
      "rumble",
      "rumbling",
      "rummage",
      "rumor",
      "runaround",
      "rundown",
      "runner",
      "running",
      "runny",
      "runt",
      "runway",
      "rupture",
      "rural",
      "ruse",
      "rush",
      "rust",
      "rut",
      "sabbath",
      "sabotage",
      "sacrament",
      "sacred",
      "sacrifice",
      "sadden",
      "saddlebag",
      "saddled",
      "saddling",
      "sadly",
      "sadness",
      "safari",
      "safeguard",
      "safehouse",
      "safely",
      "safeness",
      "saffron",
      "saga",
      "sage",
      "sagging",
      "saggy",
      "said",
      "saint",
      "sake",
      "salad",
      "salami",
      "salaried",
      "salary",
      "saline",
      "salon",
      "saloon",
      "salsa",
      "salt",
      "salutary",
      "salute",
      "salvage",
      "salvaging",
      "salvation",
      "same",
      "sample",
      "sampling",
      "sanction",
      "sanctity",
      "sanctuary",
      "sandal",
      "sandbag",
      "sandbank",
      "sandbar",
      "sandblast",
      "sandbox",
      "sanded",
      "sandfish",
      "sanding",
      "sandlot",
      "sandpaper",
      "sandpit",
      "sandstone",
      "sandstorm",
      "sandworm",
      "sandy",
      "sanitary",
      "sanitizer",
      "sank",
      "santa",
      "sapling",
      "sappiness",
      "sappy",
      "sarcasm",
      "sarcastic",
      "sardine",
      "sash",
      "sasquatch",
      "sassy",
      "satchel",
      "satiable",
      "satin",
      "satirical",
      "satisfied",
      "satisfy",
      "saturate",
      "saturday",
      "sauciness",
      "saucy",
      "sauna",
      "savage",
      "savanna",
      "saved",
      "savings",
      "savior",
      "savor",
      "saxophone",
      "say",
      "scabbed",
      "scabby",
      "scalded",
      "scalding",
      "scale",
      "scaling",
      "scallion",
      "scallop",
      "scalping",
      "scam",
      "scandal",
      "scanner",
      "scanning",
      "scant",
      "scapegoat",
      "scarce",
      "scarcity",
      "scarecrow",
      "scared",
      "scarf",
      "scarily",
      "scariness",
      "scarring",
      "scary",
      "scavenger",
      "scenic",
      "schedule",
      "schematic",
      "scheme",
      "scheming",
      "schilling",
      "schnapps",
      "scholar",
      "science",
      "scientist",
      "scion",
      "scoff",
      "scolding",
      "scone",
      "scoop",
      "scooter",
      "scope",
      "scorch",
      "scorebook",
      "scorecard",
      "scored",
      "scoreless",
      "scorer",
      "scoring",
      "scorn",
      "scorpion",
      "scotch",
      "scoundrel",
      "scoured",
      "scouring",
      "scouting",
      "scouts",
      "scowling",
      "scrabble",
      "scraggly",
      "scrambled",
      "scrambler",
      "scrap",
      "scratch",
      "scrawny",
      "screen",
      "scribble",
      "scribe",
      "scribing",
      "scrimmage",
      "script",
      "scroll",
      "scrooge",
      "scrounger",
      "scrubbed",
      "scrubber",
      "scruffy",
      "scrunch",
      "scrutiny",
      "scuba",
      "scuff",
      "sculptor",
      "sculpture",
      "scurvy",
      "scuttle",
      "secluded",
      "secluding",
      "seclusion",
      "second",
      "secrecy",
      "secret",
      "sectional",
      "sector",
      "secular",
      "securely",
      "security",
      "sedan",
      "sedate",
      "sedation",
      "sedative",
      "sediment",
      "seduce",
      "seducing",
      "segment",
      "seismic",
      "seizing",
      "seldom",
      "selected",
      "selection",
      "selective",
      "selector",
      "self",
      "seltzer",
      "semantic",
      "semester",
      "semicolon",
      "semifinal",
      "seminar",
      "semisoft",
      "semisweet",
      "senate",
      "senator",
      "send",
      "senior",
      "senorita",
      "sensation",
      "sensitive",
      "sensitize",
      "sensually",
      "sensuous",
      "sepia",
      "september",
      "septic",
      "septum",
      "sequel",
      "sequence",
      "sequester",
      "series",
      "sermon",
      "serotonin",
      "serpent",
      "serrated",
      "serve",
      "service",
      "serving",
      "sesame",
      "sessions",
      "setback",
      "setting",
      "settle",
      "settling",
      "setup",
      "sevenfold",
      "seventeen",
      "seventh",
      "seventy",
      "severity",
      "shabby",
      "shack",
      "shaded",
      "shadily",
      "shadiness",
      "shading",
      "shadow",
      "shady",
      "shaft",
      "shakable",
      "shakily",
      "shakiness",
      "shaking",
      "shaky",
      "shale",
      "shallot",
      "shallow",
      "shame",
      "shampoo",
      "shamrock",
      "shank",
      "shanty",
      "shape",
      "shaping",
      "share",
      "sharpener",
      "sharper",
      "sharpie",
      "sharply",
      "sharpness",
      "shawl",
      "sheath",
      "shed",
      "sheep",
      "sheet",
      "shelf",
      "shell",
      "shelter",
      "shelve",
      "shelving",
      "sherry",
      "shield",
      "shifter",
      "shifting",
      "shiftless",
      "shifty",
      "shimmer",
      "shimmy",
      "shindig",
      "shine",
      "shingle",
      "shininess",
      "shining",
      "shiny",
      "ship",
      "shirt",
      "shivering",
      "shock",
      "shone",
      "shoplift",
      "shopper",
      "shopping",
      "shoptalk",
      "shore",
      "shortage",
      "shortcake",
      "shortcut",
      "shorten",
      "shorter",
      "shorthand",
      "shortlist",
      "shortly",
      "shortness",
      "shorts",
      "shortwave",
      "shorty",
      "shout",
      "shove",
      "showbiz",
      "showcase",
      "showdown",
      "shower",
      "showgirl",
      "showing",
      "showman",
      "shown",
      "showoff",
      "showpiece",
      "showplace",
      "showroom",
      "showy",
      "shrank",
      "shrapnel",
      "shredder",
      "shredding",
      "shrewdly",
      "shriek",
      "shrill",
      "shrimp",
      "shrine",
      "shrink",
      "shrivel",
      "shrouded",
      "shrubbery",
      "shrubs",
      "shrug",
      "shrunk",
      "shucking",
      "shudder",
      "shuffle",
      "shuffling",
      "shun",
      "shush",
      "shut",
      "shy",
      "siamese",
      "siberian",
      "sibling",
      "siding",
      "sierra",
      "siesta",
      "sift",
      "sighing",
      "silenced",
      "silencer",
      "silent",
      "silica",
      "silicon",
      "silk",
      "silliness",
      "silly",
      "silo",
      "silt",
      "silver",
      "similarly",
      "simile",
      "simmering",
      "simple",
      "simplify",
      "simply",
      "sincere",
      "sincerity",
      "singer",
      "singing",
      "single",
      "singular",
      "sinister",
      "sinless",
      "sinner",
      "sinuous",
      "sip",
      "siren",
      "sister",
      "sitcom",
      "sitter",
      "sitting",
      "situated",
      "situation",
      "sixfold",
      "sixteen",
      "sixth",
      "sixties",
      "sixtieth",
      "sixtyfold",
      "sizable",
      "sizably",
      "size",
      "sizing",
      "sizzle",
      "sizzling",
      "skater",
      "skating",
      "skedaddle",
      "skeletal",
      "skeleton",
      "skeptic",
      "sketch",
      "skewed",
      "skewer",
      "skid",
      "skied",
      "skier",
      "skies",
      "skiing",
      "skilled",
      "skillet",
      "skillful",
      "skimmed",
      "skimmer",
      "skimming",
      "skimpily",
      "skincare",
      "skinhead",
      "skinless",
      "skinning",
      "skinny",
      "skintight",
      "skipper",
      "skipping",
      "skirmish",
      "skirt",
      "skittle",
      "skydiver",
      "skylight",
      "skyline",
      "skype",
      "skyrocket",
      "skyward",
      "slab",
      "slacked",
      "slacker",
      "slacking",
      "slackness",
      "slacks",
      "slain",
      "slam",
      "slander",
      "slang",
      "slapping",
      "slapstick",
      "slashed",
      "slashing",
      "slate",
      "slather",
      "slaw",
      "sled",
      "sleek",
      "sleep",
      "sleet",
      "sleeve",
      "slept",
      "sliceable",
      "sliced",
      "slicer",
      "slicing",
      "slick",
      "slider",
      "slideshow",
      "sliding",
      "slighted",
      "slighting",
      "slightly",
      "slimness",
      "slimy",
      "slinging",
      "slingshot",
      "slinky",
      "slip",
      "slit",
      "sliver",
      "slobbery",
      "slogan",
      "sloped",
      "sloping",
      "sloppily",
      "sloppy",
      "slot",
      "slouching",
      "slouchy",
      "sludge",
      "slug",
      "slum",
      "slurp",
      "slush",
      "sly",
      "small",
      "smartly",
      "smartness",
      "smasher",
      "smashing",
      "smashup",
      "smell",
      "smelting",
      "smile",
      "smilingly",
      "smirk",
      "smite",
      "smith",
      "smitten",
      "smock",
      "smog",
      "smoked",
      "smokeless",
      "smokiness",
      "smoking",
      "smoky",
      "smolder",
      "smooth",
      "smother",
      "smudge",
      "smudgy",
      "smuggler",
      "smuggling",
      "smugly",
      "smugness",
      "snack",
      "snagged",
      "snaking",
      "snap",
      "snare",
      "snarl",
      "snazzy",
      "sneak",
      "sneer",
      "sneeze",
      "sneezing",
      "snide",
      "sniff",
      "snippet",
      "snipping",
      "snitch",
      "snooper",
      "snooze",
      "snore",
      "snoring",
      "snorkel",
      "snort",
      "snout",
      "snowbird",
      "snowboard",
      "snowbound",
      "snowcap",
      "snowdrift",
      "snowdrop",
      "snowfall",
      "snowfield",
      "snowflake",
      "snowiness",
      "snowless",
      "snowman",
      "snowplow",
      "snowshoe",
      "snowstorm",
      "snowsuit",
      "snowy",
      "snub",
      "snuff",
      "snuggle",
      "snugly",
      "snugness",
      "speak",
      "spearfish",
      "spearhead",
      "spearman",
      "spearmint",
      "species",
      "specimen",
      "specked",
      "speckled",
      "specks",
      "spectacle",
      "spectator",
      "spectrum",
      "speculate",
      "speech",
      "speed",
      "spellbind",
      "speller",
      "spelling",
      "spendable",
      "spender",
      "spending",
      "spent",
      "spew",
      "sphere",
      "spherical",
      "sphinx",
      "spider",
      "spied",
      "spiffy",
      "spill",
      "spilt",
      "spinach",
      "spinal",
      "spindle",
      "spinner",
      "spinning",
      "spinout",
      "spinster",
      "spiny",
      "spiral",
      "spirited",
      "spiritism",
      "spirits",
      "spiritual",
      "splashed",
      "splashing",
      "splashy",
      "splatter",
      "spleen",
      "splendid",
      "splendor",
      "splice",
      "splicing",
      "splinter",
      "splotchy",
      "splurge",
      "spoilage",
      "spoiled",
      "spoiler",
      "spoiling",
      "spoils",
      "spoken",
      "spokesman",
      "sponge",
      "spongy",
      "sponsor",
      "spoof",
      "spookily",
      "spooky",
      "spool",
      "spoon",
      "spore",
      "sporting",
      "sports",
      "sporty",
      "spotless",
      "spotlight",
      "spotted",
      "spotter",
      "spotting",
      "spotty",
      "spousal",
      "spouse",
      "spout",
      "sprain",
      "sprang",
      "sprawl",
      "spray",
      "spree",
      "sprig",
      "spring",
      "sprinkled",
      "sprinkler",
      "sprint",
      "sprite",
      "sprout",
      "spruce",
      "sprung",
      "spry",
      "spud",
      "spur",
      "sputter",
      "spyglass",
      "squabble",
      "squad",
      "squall",
      "squander",
      "squash",
      "squatted",
      "squatter",
      "squatting",
      "squeak",
      "squealer",
      "squealing",
      "squeamish",
      "squeegee",
      "squeeze",
      "squeezing",
      "squid",
      "squiggle",
      "squiggly",
      "squint",
      "squire",
      "squirt",
      "squishier",
      "squishy",
      "stability",
      "stabilize",
      "stable",
      "stack",
      "stadium",
      "staff",
      "stage",
      "staging",
      "stagnant",
      "stagnate",
      "stainable",
      "stained",
      "staining",
      "stainless",
      "stalemate",
      "staleness",
      "stalling",
      "stallion",
      "stamina",
      "stammer",
      "stamp",
      "stand",
      "stank",
      "staple",
      "stapling",
      "starboard",
      "starch",
      "stardom",
      "stardust",
      "starfish",
      "stargazer",
      "staring",
      "stark",
      "starless",
      "starlet",
      "starlight",
      "starlit",
      "starring",
      "starry",
      "starship",
      "starter",
      "starting",
      "startle",
      "startling",
      "startup",
      "starved",
      "starving",
      "stash",
      "state",
      "static",
      "statistic",
      "statue",
      "stature",
      "status",
      "statute",
      "statutory",
      "staunch",
      "stays",
      "steadfast",
      "steadier",
      "steadily",
      "steadying",
      "steam",
      "steed",
      "steep",
      "steerable",
      "steering",
      "steersman",
      "stegosaur",
      "stellar",
      "stem",
      "stench",
      "stencil",
      "step",
      "stereo",
      "sterile",
      "sterility",
      "sterilize",
      "sterling",
      "sternness",
      "sternum",
      "stew",
      "stick",
      "stiffen",
      "stiffly",
      "stiffness",
      "stifle",
      "stifling",
      "stillness",
      "stilt",
      "stimulant",
      "stimulate",
      "stimuli",
      "stimulus",
      "stinger",
      "stingily",
      "stinging",
      "stingray",
      "stingy",
      "stinking",
      "stinky",
      "stipend",
      "stipulate",
      "stir",
      "stitch",
      "stock",
      "stoic",
      "stoke",
      "stole",
      "stomp",
      "stonewall",
      "stoneware",
      "stonework",
      "stoning",
      "stony",
      "stood",
      "stooge",
      "stool",
      "stoop",
      "stoplight",
      "stoppable",
      "stoppage",
      "stopped",
      "stopper",
      "stopping",
      "stopwatch",
      "storable",
      "storage",
      "storeroom",
      "storewide",
      "storm",
      "stout",
      "stove",
      "stowaway",
      "stowing",
      "straddle",
      "straggler",
      "strained",
      "strainer",
      "straining",
      "strangely",
      "stranger",
      "strangle",
      "strategic",
      "strategy",
      "stratus",
      "straw",
      "stray",
      "streak",
      "stream",
      "street",
      "strength",
      "strenuous",
      "strep",
      "stress",
      "stretch",
      "strewn",
      "stricken",
      "strict",
      "stride",
      "strife",
      "strike",
      "striking",
      "strive",
      "striving",
      "strobe",
      "strode",
      "stroller",
      "strongbox",
      "strongly",
      "strongman",
      "struck",
      "structure",
      "strudel",
      "struggle",
      "strum",
      "strung",
      "strut",
      "stubbed",
      "stubble",
      "stubbly",
      "stubborn",
      "stucco",
      "stuck",
      "student",
      "studied",
      "studio",
      "study",
      "stuffed",
      "stuffing",
      "stuffy",
      "stumble",
      "stumbling",
      "stump",
      "stung",
      "stunned",
      "stunner",
      "stunning",
      "stunt",
      "stupor",
      "sturdily",
      "sturdy",
      "styling",
      "stylishly",
      "stylist",
      "stylized",
      "stylus",
      "suave",
      "subarctic",
      "subatomic",
      "subdivide",
      "subdued",
      "subduing",
      "subfloor",
      "subgroup",
      "subheader",
      "subject",
      "sublease",
      "sublet",
      "sublevel",
      "sublime",
      "submarine",
      "submerge",
      "submersed",
      "submitter",
      "subpanel",
      "subpar",
      "subplot",
      "subprime",
      "subscribe",
      "subscript",
      "subsector",
      "subside",
      "subsiding",
      "subsidize",
      "subsidy",
      "subsoil",
      "subsonic",
      "substance",
      "subsystem",
      "subtext",
      "subtitle",
      "subtly",
      "subtotal",
      "subtract",
      "subtype",
      "suburb",
      "subway",
      "subwoofer",
      "subzero",
      "succulent",
      "such",
      "suction",
      "sudden",
      "sudoku",
      "suds",
      "sufferer",
      "suffering",
      "suffice",
      "suffix",
      "suffocate",
      "suffrage",
      "sugar",
      "suggest",
      "suing",
      "suitable",
      "suitably",
      "suitcase",
      "suitor",
      "sulfate",
      "sulfide",
      "sulfite",
      "sulfur",
      "sulk",
      "sullen",
      "sulphate",
      "sulphuric",
      "sultry",
      "superbowl",
      "superglue",
      "superhero",
      "superior",
      "superjet",
      "superman",
      "supermom",
      "supernova",
      "supervise",
      "supper",
      "supplier",
      "supply",
      "support",
      "supremacy",
      "supreme",
      "surcharge",
      "surely",
      "sureness",
      "surface",
      "surfacing",
      "surfboard",
      "surfer",
      "surgery",
      "surgical",
      "surging",
      "surname",
      "surpass",
      "surplus",
      "surprise",
      "surreal",
      "surrender",
      "surrogate",
      "surround",
      "survey",
      "survival",
      "survive",
      "surviving",
      "survivor",
      "sushi",
      "suspect",
      "suspend",
      "suspense",
      "sustained",
      "sustainer",
      "swab",
      "swaddling",
      "swagger",
      "swampland",
      "swan",
      "swapping",
      "swarm",
      "sway",
      "swear",
      "sweat",
      "sweep",
      "swell",
      "swept",
      "swerve",
      "swifter",
      "swiftly",
      "swiftness",
      "swimmable",
      "swimmer",
      "swimming",
      "swimsuit",
      "swimwear",
      "swinger",
      "swinging",
      "swipe",
      "swirl",
      "switch",
      "swivel",
      "swizzle",
      "swooned",
      "swoop",
      "swoosh",
      "swore",
      "sworn",
      "swung",
      "sycamore",
      "sympathy",
      "symphonic",
      "symphony",
      "symptom",
      "synapse",
      "syndrome",
      "synergy",
      "synopses",
      "synopsis",
      "synthesis",
      "synthetic",
      "syrup",
      "system",
      "t-shirt",
      "tabasco",
      "tabby",
      "tableful",
      "tables",
      "tablet",
      "tableware",
      "tabloid",
      "tackiness",
      "tacking",
      "tackle",
      "tackling",
      "tacky",
      "taco",
      "tactful",
      "tactical",
      "tactics",
      "tactile",
      "tactless",
      "tadpole",
      "taekwondo",
      "tag",
      "tainted",
      "take",
      "taking",
      "talcum",
      "talisman",
      "tall",
      "talon",
      "tamale",
      "tameness",
      "tamer",
      "tamper",
      "tank",
      "tanned",
      "tannery",
      "tanning",
      "tantrum",
      "tapeless",
      "tapered",
      "tapering",
      "tapestry",
      "tapioca",
      "tapping",
      "taps",
      "tarantula",
      "target",
      "tarmac",
      "tarnish",
      "tarot",
      "tartar",
      "tartly",
      "tartness",
      "task",
      "tassel",
      "taste",
      "tastiness",
      "tasting",
      "tasty",
      "tattered",
      "tattle",
      "tattling",
      "tattoo",
      "taunt",
      "tavern",
      "thank",
      "that",
      "thaw",
      "theater",
      "theatrics",
      "thee",
      "theft",
      "theme",
      "theology",
      "theorize",
      "thermal",
      "thermos",
      "thesaurus",
      "these",
      "thesis",
      "thespian",
      "thicken",
      "thicket",
      "thickness",
      "thieving",
      "thievish",
      "thigh",
      "thimble",
      "thing",
      "think",
      "thinly",
      "thinner",
      "thinness",
      "thinning",
      "thirstily",
      "thirsting",
      "thirsty",
      "thirteen",
      "thirty",
      "thong",
      "thorn",
      "those",
      "thousand",
      "thrash",
      "thread",
      "threaten",
      "threefold",
      "thrift",
      "thrill",
      "thrive",
      "thriving",
      "throat",
      "throbbing",
      "throng",
      "throttle",
      "throwaway",
      "throwback",
      "thrower",
      "throwing",
      "thud",
      "thumb",
      "thumping",
      "thursday",
      "thus",
      "thwarting",
      "thyself",
      "tiara",
      "tibia",
      "tidal",
      "tidbit",
      "tidiness",
      "tidings",
      "tidy",
      "tiger",
      "tighten",
      "tightly",
      "tightness",
      "tightrope",
      "tightwad",
      "tigress",
      "tile",
      "tiling",
      "till",
      "tilt",
      "timid",
      "timing",
      "timothy",
      "tinderbox",
      "tinfoil",
      "tingle",
      "tingling",
      "tingly",
      "tinker",
      "tinkling",
      "tinsel",
      "tinsmith",
      "tint",
      "tinwork",
      "tiny",
      "tipoff",
      "tipped",
      "tipper",
      "tipping",
      "tiptoeing",
      "tiptop",
      "tiring",
      "tissue",
      "trace",
      "tracing",
      "track",
      "traction",
      "tractor",
      "trade",
      "trading",
      "tradition",
      "traffic",
      "tragedy",
      "trailing",
      "trailside",
      "train",
      "traitor",
      "trance",
      "tranquil",
      "transfer",
      "transform",
      "translate",
      "transpire",
      "transport",
      "transpose",
      "trapdoor",
      "trapeze",
      "trapezoid",
      "trapped",
      "trapper",
      "trapping",
      "traps",
      "trash",
      "travel",
      "traverse",
      "travesty",
      "tray",
      "treachery",
      "treading",
      "treadmill",
      "treason",
      "treat",
      "treble",
      "tree",
      "trekker",
      "tremble",
      "trembling",
      "tremor",
      "trench",
      "trend",
      "trespass",
      "triage",
      "trial",
      "triangle",
      "tribesman",
      "tribunal",
      "tribune",
      "tributary",
      "tribute",
      "triceps",
      "trickery",
      "trickily",
      "tricking",
      "trickle",
      "trickster",
      "tricky",
      "tricolor",
      "tricycle",
      "trident",
      "tried",
      "trifle",
      "trifocals",
      "trillion",
      "trilogy",
      "trimester",
      "trimmer",
      "trimming",
      "trimness",
      "trinity",
      "trio",
      "tripod",
      "tripping",
      "triumph",
      "trivial",
      "trodden",
      "trolling",
      "trombone",
      "trophy",
      "tropical",
      "tropics",
      "trouble",
      "troubling",
      "trough",
      "trousers",
      "trout",
      "trowel",
      "truce",
      "truck",
      "truffle",
      "trump",
      "trunks",
      "trustable",
      "trustee",
      "trustful",
      "trusting",
      "trustless",
      "truth",
      "try",
      "tubby",
      "tubeless",
      "tubular",
      "tucking",
      "tuesday",
      "tug",
      "tuition",
      "tulip",
      "tumble",
      "tumbling",
      "tummy",
      "turban",
      "turbine",
      "turbofan",
      "turbojet",
      "turbulent",
      "turf",
      "turkey",
      "turmoil",
      "turret",
      "turtle",
      "tusk",
      "tutor",
      "tutu",
      "tux",
      "tweak",
      "tweed",
      "tweet",
      "tweezers",
      "twelve",
      "twentieth",
      "twenty",
      "twerp",
      "twice",
      "twiddle",
      "twiddling",
      "twig",
      "twilight",
      "twine",
      "twins",
      "twirl",
      "twistable",
      "twisted",
      "twister",
      "twisting",
      "twisty",
      "twitch",
      "twitter",
      "tycoon",
      "tying",
      "tyke",
      "udder",
      "ultimate",
      "ultimatum",
      "ultra",
      "umbilical",
      "umbrella",
      "umpire",
      "unabashed",
      "unable",
      "unadorned",
      "unadvised",
      "unafraid",
      "unaired",
      "unaligned",
      "unaltered",
      "unarmored",
      "unashamed",
      "unaudited",
      "unawake",
      "unaware",
      "unbaked",
      "unbalance",
      "unbeaten",
      "unbend",
      "unbent",
      "unbiased",
      "unbitten",
      "unblended",
      "unblessed",
      "unblock",
      "unbolted",
      "unbounded",
      "unboxed",
      "unbraided",
      "unbridle",
      "unbroken",
      "unbuckled",
      "unbundle",
      "unburned",
      "unbutton",
      "uncanny",
      "uncapped",
      "uncaring",
      "uncertain",
      "unchain",
      "unchanged",
      "uncharted",
      "uncheck",
      "uncivil",
      "unclad",
      "unclaimed",
      "unclamped",
      "unclasp",
      "uncle",
      "unclip",
      "uncloak",
      "unclog",
      "unclothed",
      "uncoated",
      "uncoiled",
      "uncolored",
      "uncombed",
      "uncommon",
      "uncooked",
      "uncork",
      "uncorrupt",
      "uncounted",
      "uncouple",
      "uncouth",
      "uncover",
      "uncross",
      "uncrown",
      "uncrushed",
      "uncured",
      "uncurious",
      "uncurled",
      "uncut",
      "undamaged",
      "undated",
      "undaunted",
      "undead",
      "undecided",
      "undefined",
      "underage",
      "underarm",
      "undercoat",
      "undercook",
      "undercut",
      "underdog",
      "underdone",
      "underfed",
      "underfeed",
      "underfoot",
      "undergo",
      "undergrad",
      "underhand",
      "underline",
      "underling",
      "undermine",
      "undermost",
      "underpaid",
      "underpass",
      "underpay",
      "underrate",
      "undertake",
      "undertone",
      "undertook",
      "undertow",
      "underuse",
      "underwear",
      "underwent",
      "underwire",
      "undesired",
      "undiluted",
      "undivided",
      "undocked",
      "undoing",
      "undone",
      "undrafted",
      "undress",
      "undrilled",
      "undusted",
      "undying",
      "unearned",
      "unearth",
      "unease",
      "uneasily",
      "uneasy",
      "uneatable",
      "uneaten",
      "unedited",
      "unelected",
      "unending",
      "unengaged",
      "unenvied",
      "unequal",
      "unethical",
      "uneven",
      "unexpired",
      "unexposed",
      "unfailing",
      "unfair",
      "unfasten",
      "unfazed",
      "unfeeling",
      "unfiled",
      "unfilled",
      "unfitted",
      "unfitting",
      "unfixable",
      "unfixed",
      "unflawed",
      "unfocused",
      "unfold",
      "unfounded",
      "unframed",
      "unfreeze",
      "unfrosted",
      "unfrozen",
      "unfunded",
      "unglazed",
      "ungloved",
      "unglue",
      "ungodly",
      "ungraded",
      "ungreased",
      "unguarded",
      "unguided",
      "unhappily",
      "unhappy",
      "unharmed",
      "unhealthy",
      "unheard",
      "unhearing",
      "unheated",
      "unhelpful",
      "unhidden",
      "unhinge",
      "unhitched",
      "unholy",
      "unhook",
      "unicorn",
      "unicycle",
      "unified",
      "unifier",
      "uniformed",
      "uniformly",
      "unify",
      "unimpeded",
      "uninjured",
      "uninstall",
      "uninsured",
      "uninvited",
      "union",
      "uniquely",
      "unisexual",
      "unison",
      "unissued",
      "unit",
      "universal",
      "universe",
      "unjustly",
      "unkempt",
      "unkind",
      "unknotted",
      "unknowing",
      "unknown",
      "unlaced",
      "unlatch",
      "unlawful",
      "unleaded",
      "unlearned",
      "unleash",
      "unless",
      "unleveled",
      "unlighted",
      "unlikable",
      "unlimited",
      "unlined",
      "unlinked",
      "unlisted",
      "unlit",
      "unlivable",
      "unloaded",
      "unloader",
      "unlocked",
      "unlocking",
      "unlovable",
      "unloved",
      "unlovely",
      "unloving",
      "unluckily",
      "unlucky",
      "unmade",
      "unmanaged",
      "unmanned",
      "unmapped",
      "unmarked",
      "unmasked",
      "unmasking",
      "unmatched",
      "unmindful",
      "unmixable",
      "unmixed",
      "unmolded",
      "unmoral",
      "unmovable",
      "unmoved",
      "unmoving",
      "unnamable",
      "unnamed",
      "unnatural",
      "unneeded",
      "unnerve",
      "unnerving",
      "unnoticed",
      "unopened",
      "unopposed",
      "unpack",
      "unpadded",
      "unpaid",
      "unpainted",
      "unpaired",
      "unpaved",
      "unpeeled",
      "unpicked",
      "unpiloted",
      "unpinned",
      "unplanned",
      "unplanted",
      "unpleased",
      "unpledged",
      "unplowed",
      "unplug",
      "unpopular",
      "unproven",
      "unquote",
      "unranked",
      "unrated",
      "unraveled",
      "unreached",
      "unread",
      "unreal",
      "unreeling",
      "unrefined",
      "unrelated",
      "unrented",
      "unrest",
      "unretired",
      "unrevised",
      "unrigged",
      "unripe",
      "unrivaled",
      "unroasted",
      "unrobed",
      "unroll",
      "unruffled",
      "unruly",
      "unrushed",
      "unsaddle",
      "unsafe",
      "unsaid",
      "unsalted",
      "unsaved",
      "unsavory",
      "unscathed",
      "unscented",
      "unscrew",
      "unsealed",
      "unseated",
      "unsecured",
      "unseeing",
      "unseemly",
      "unseen",
      "unselect",
      "unselfish",
      "unsent",
      "unsettled",
      "unshackle",
      "unshaken",
      "unshaved",
      "unshaven",
      "unsheathe",
      "unshipped",
      "unsightly",
      "unsigned",
      "unskilled",
      "unsliced",
      "unsmooth",
      "unsnap",
      "unsocial",
      "unsoiled",
      "unsold",
      "unsolved",
      "unsorted",
      "unspoiled",
      "unspoken",
      "unstable",
      "unstaffed",
      "unstamped",
      "unsteady",
      "unsterile",
      "unstirred",
      "unstitch",
      "unstopped",
      "unstuck",
      "unstuffed",
      "unstylish",
      "unsubtle",
      "unsubtly",
      "unsuited",
      "unsure",
      "unsworn",
      "untagged",
      "untainted",
      "untaken",
      "untamed",
      "untangled",
      "untapped",
      "untaxed",
      "unthawed",
      "unthread",
      "untidy",
      "untie",
      "until",
      "untimed",
      "untimely",
      "untitled",
      "untoasted",
      "untold",
      "untouched",
      "untracked",
      "untrained",
      "untreated",
      "untried",
      "untrimmed",
      "untrue",
      "untruth",
      "unturned",
      "untwist",
      "untying",
      "unusable",
      "unused",
      "unusual",
      "unvalued",
      "unvaried",
      "unvarying",
      "unveiled",
      "unveiling",
      "unvented",
      "unviable",
      "unvisited",
      "unvocal",
      "unwanted",
      "unwarlike",
      "unwary",
      "unwashed",
      "unwatched",
      "unweave",
      "unwed",
      "unwelcome",
      "unwell",
      "unwieldy",
      "unwilling",
      "unwind",
      "unwired",
      "unwitting",
      "unwomanly",
      "unworldly",
      "unworn",
      "unworried",
      "unworthy",
      "unwound",
      "unwoven",
      "unwrapped",
      "unwritten",
      "unzip",
      "upbeat",
      "upchuck",
      "upcoming",
      "upcountry",
      "update",
      "upfront",
      "upgrade",
      "upheaval",
      "upheld",
      "uphill",
      "uphold",
      "uplifted",
      "uplifting",
      "upload",
      "upon",
      "upper",
      "upright",
      "uprising",
      "upriver",
      "uproar",
      "uproot",
      "upscale",
      "upside",
      "upstage",
      "upstairs",
      "upstart",
      "upstate",
      "upstream",
      "upstroke",
      "upswing",
      "uptake",
      "uptight",
      "uptown",
      "upturned",
      "upward",
      "upwind",
      "uranium",
      "urban",
      "urchin",
      "urethane",
      "urgency",
      "urgent",
      "urging",
      "urologist",
      "urology",
      "usable",
      "usage",
      "useable",
      "used",
      "uselessly",
      "user",
      "usher",
      "usual",
      "utensil",
      "utility",
      "utilize",
      "utmost",
      "utopia",
      "utter",
      "vacancy",
      "vacant",
      "vacate",
      "vacation",
      "vagabond",
      "vagrancy",
      "vagrantly",
      "vaguely",
      "vagueness",
      "valiant",
      "valid",
      "valium",
      "valley",
      "valuables",
      "value",
      "vanilla",
      "vanish",
      "vanity",
      "vanquish",
      "vantage",
      "vaporizer",
      "variable",
      "variably",
      "varied",
      "variety",
      "various",
      "varmint",
      "varnish",
      "varsity",
      "varying",
      "vascular",
      "vaseline",
      "vastly",
      "vastness",
      "veal",
      "vegan",
      "veggie",
      "vehicular",
      "velcro",
      "velocity",
      "velvet",
      "vendetta",
      "vending",
      "vendor",
      "veneering",
      "vengeful",
      "venomous",
      "ventricle",
      "venture",
      "venue",
      "venus",
      "verbalize",
      "verbally",
      "verbose",
      "verdict",
      "verify",
      "verse",
      "version",
      "versus",
      "vertebrae",
      "vertical",
      "vertigo",
      "very",
      "vessel",
      "vest",
      "veteran",
      "veto",
      "vexingly",
      "viability",
      "viable",
      "vibes",
      "vice",
      "vicinity",
      "victory",
      "video",
      "viewable",
      "viewer",
      "viewing",
      "viewless",
      "viewpoint",
      "vigorous",
      "village",
      "villain",
      "vindicate",
      "vineyard",
      "vintage",
      "violate",
      "violation",
      "violator",
      "violet",
      "violin",
      "viper",
      "viral",
      "virtual",
      "virtuous",
      "virus",
      "visa",
      "viscosity",
      "viscous",
      "viselike",
      "visible",
      "visibly",
      "vision",
      "visiting",
      "visitor",
      "visor",
      "vista",
      "vitality",
      "vitalize",
      "vitally",
      "vitamins",
      "vivacious",
      "vividly",
      "vividness",
      "vixen",
      "vocalist",
      "vocalize",
      "vocally",
      "vocation",
      "voice",
      "voicing",
      "void",
      "volatile",
      "volley",
      "voltage",
      "volumes",
      "voter",
      "voting",
      "voucher",
      "vowed",
      "vowel",
      "voyage",
      "wackiness",
      "wad",
      "wafer",
      "waffle",
      "waged",
      "wager",
      "wages",
      "waggle",
      "wagon",
      "wake",
      "waking",
      "walk",
      "walmart",
      "walnut",
      "walrus",
      "waltz",
      "wand",
      "wannabe",
      "wanted",
      "wanting",
      "wasabi",
      "washable",
      "washbasin",
      "washboard",
      "washbowl",
      "washcloth",
      "washday",
      "washed",
      "washer",
      "washhouse",
      "washing",
      "washout",
      "washroom",
      "washstand",
      "washtub",
      "wasp",
      "wasting",
      "watch",
      "water",
      "waviness",
      "waving",
      "wavy",
      "whacking",
      "whacky",
      "wham",
      "wharf",
      "wheat",
      "whenever",
      "whiff",
      "whimsical",
      "whinny",
      "whiny",
      "whisking",
      "whoever",
      "whole",
      "whomever",
      "whoopee",
      "whooping",
      "whoops",
      "why",
      "wick",
      "widely",
      "widen",
      "widget",
      "widow",
      "width",
      "wieldable",
      "wielder",
      "wife",
      "wifi",
      "wikipedia",
      "wildcard",
      "wildcat",
      "wilder",
      "wildfire",
      "wildfowl",
      "wildland",
      "wildlife",
      "wildly",
      "wildness",
      "willed",
      "willfully",
      "willing",
      "willow",
      "willpower",
      "wilt",
      "wimp",
      "wince",
      "wincing",
      "wind",
      "wing",
      "winking",
      "winner",
      "winnings",
      "winter",
      "wipe",
      "wired",
      "wireless",
      "wiring",
      "wiry",
      "wisdom",
      "wise",
      "wish",
      "wisplike",
      "wispy",
      "wistful",
      "wizard",
      "wobble",
      "wobbling",
      "wobbly",
      "wok",
      "wolf",
      "wolverine",
      "womanhood",
      "womankind",
      "womanless",
      "womanlike",
      "womanly",
      "womb",
      "woof",
      "wooing",
      "wool",
      "woozy",
      "word",
      "work",
      "worried",
      "worrier",
      "worrisome",
      "worry",
      "worsening",
      "worshiper",
      "worst",
      "wound",
      "woven",
      "wow",
      "wrangle",
      "wrath",
      "wreath",
      "wreckage",
      "wrecker",
      "wrecking",
      "wrench",
      "wriggle",
      "wriggly",
      "wrinkle",
      "wrinkly",
      "wrist",
      "writing",
      "written",
      "wrongdoer",
      "wronged",
      "wrongful",
      "wrongly",
      "wrongness",
      "wrought",
      "xbox",
      "xerox",
      "yahoo",
      "yam",
      "yanking",
      "yapping",
      "yard",
      "yarn",
      "yeah",
      "yearbook",
      "yearling",
      "yearly",
      "yearning",
      "yeast",
      "yelling",
      "yelp",
      "yen",
      "yesterday",
      "yiddish",
      "yield",
      "yin",
      "yippee",
      "yo-yo",
      "yodel",
      "yoga",
      "yogurt",
      "yonder",
      "yoyo",
      "yummy",
      "zap",
      "zealous",
      "zebra",
      "zen",
      "zeppelin",
      "zero",
      "zestfully",
      "zesty",
      "zigzagged",
      "zipfile",
      "zipping",
      "zippy",
      "zips",
      "zit",
      "zodiac",
      "zombie",
      "zone",
      "zoning",
      "zookeeper",
      "zoologist",
      "zoology",
      "zoom"
    ];
  }
});

// node_modules/ton-crypto/dist/passwords/newSecureWords.js
var require_newSecureWords = __commonJS({
  "node_modules/ton-crypto/dist/passwords/newSecureWords.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newSecureWords = void 0;
    var getSecureRandom_1 = require_getSecureRandom2();
    var wordlist_1 = require_wordlist();
    async function newSecureWords(size = 6) {
      let words = [];
      for (let i = 0; i < size; i++) {
        words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
      }
      return words;
    }
    exports.newSecureWords = newSecureWords;
  }
});

// node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js
var require_newSecurePassphrase = __commonJS({
  "node_modules/ton-crypto/dist/passwords/newSecurePassphrase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newSecurePassphrase = void 0;
    var __1 = require_dist();
    async function newSecurePassphrase(size = 6) {
      return (await (0, __1.newSecureWords)(size)).join("-");
    }
    exports.newSecurePassphrase = newSecurePassphrase;
  }
});

// node_modules/ton-crypto/dist/utils/binary.js
var require_binary = __commonJS({
  "node_modules/ton-crypto/dist/utils/binary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsToBytes = exports.bytesToBits = exports.lpad = void 0;
    function lpad(str, padString, length) {
      while (str.length < length) {
        str = padString + str;
      }
      return str;
    }
    exports.lpad = lpad;
    function bytesToBits(bytes) {
      let res = "";
      for (let i = 0; i < bytes.length; i++) {
        let x = bytes.at(i);
        res += lpad(x.toString(2), "0", 8);
      }
      return res;
    }
    exports.bytesToBits = bytesToBits;
    function bitsToBytes(src) {
      if (src.length % 8 !== 0) {
        throw Error("Uneven bits");
      }
      let res = [];
      while (src.length > 0) {
        res.push(parseInt(src.slice(0, 8), 2));
        src = src.slice(8);
      }
      return import_buffer.Buffer.from(res);
    }
    exports.bitsToBytes = bitsToBytes;
  }
});

// node_modules/ton-crypto/dist/mnemonic/wordlist.js
var require_wordlist2 = __commonJS({
  "node_modules/ton-crypto/dist/mnemonic/wordlist.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    var EN = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
    exports.wordlist = EN;
  }
});

// node_modules/ton-crypto/dist/mnemonic/mnemonic.js
var require_mnemonic = __commonJS({
  "node_modules/ton-crypto/dist/mnemonic/mnemonic.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicFromRandomSeed = exports.mnemonicIndexesToBytes = exports.bytesToMnemonics = exports.bytesToMnemonicIndexes = exports.mnemonicNew = exports.mnemonicValidate = exports.mnemonicToHDSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicToSeed = exports.mnemonicToEntropy = void 0;
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    var getSecureRandom_1 = require_getSecureRandom2();
    var hmac_sha512_1 = require_hmac_sha5122();
    var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
    var binary_1 = require_binary();
    var wordlist_1 = require_wordlist2();
    var PBKDF_ITERATIONS = 1e5;
    async function isPasswordNeeded(mnemonicArray) {
      const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
      return await isPasswordSeed(passlessEntropy) && !await isBasicSeed(passlessEntropy);
    }
    function normalizeMnemonic(src) {
      return src.map((v) => v.toLowerCase().trim());
    }
    async function isBasicSeed(entropy) {
      const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
      return seed[0] == 0;
    }
    async function isPasswordSeed(entropy) {
      const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, "TON fast seed version", 1, 64);
      return seed[0] == 1;
    }
    async function mnemonicToEntropy(mnemonicArray, password) {
      return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(" "), password && password.length > 0 ? password : "");
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    async function mnemonicToSeed(mnemonicArray, seed, password) {
      const entropy = await mnemonicToEntropy(mnemonicArray, password);
      return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    async function mnemonicToPrivateKey(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      const seed = await mnemonicToSeed(mnemonicArray, "TON default seed", password);
      let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
      return {
        publicKey: import_buffer.Buffer.from(keyPair.publicKey),
        secretKey: import_buffer.Buffer.from(keyPair.secretKey)
      };
    }
    exports.mnemonicToPrivateKey = mnemonicToPrivateKey;
    async function mnemonicToWalletKey(mnemonicArray, password) {
      let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
      let seedSecret = seedPk.secretKey.slice(0, 32);
      const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
      return {
        publicKey: import_buffer.Buffer.from(keyPair.publicKey),
        secretKey: import_buffer.Buffer.from(keyPair.secretKey)
      };
    }
    exports.mnemonicToWalletKey = mnemonicToWalletKey;
    async function mnemonicToHDSeed(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      return await mnemonicToSeed(mnemonicArray, "TON HD Keys seed", password);
    }
    exports.mnemonicToHDSeed = mnemonicToHDSeed;
    async function mnemonicValidate(mnemonicArray, password) {
      mnemonicArray = normalizeMnemonic(mnemonicArray);
      for (let word of mnemonicArray) {
        if (wordlist_1.wordlist.indexOf(word) < 0) {
          return false;
        }
      }
      if (password && password.length > 0) {
        if (!await isPasswordNeeded(mnemonicArray)) {
          return false;
        }
      }
      return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
    }
    exports.mnemonicValidate = mnemonicValidate;
    async function mnemonicNew(wordsCount = 24, password) {
      let mnemonicArray = [];
      while (true) {
        mnemonicArray = [];
        for (let i = 0; i < wordsCount; i++) {
          let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
          mnemonicArray.push(wordlist_1.wordlist[ind]);
        }
        if (password && password.length > 0) {
          if (!await isPasswordNeeded(mnemonicArray)) {
            continue;
          }
        }
        if (!await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password))) {
          continue;
        }
        break;
      }
      return mnemonicArray;
    }
    exports.mnemonicNew = mnemonicNew;
    function bytesToMnemonicIndexes(src, wordsCount) {
      let bits = (0, binary_1.bytesToBits)(src);
      let indexes = [];
      for (let i = 0; i < wordsCount; i++) {
        let sl = bits.slice(i * 11, i * 11 + 11);
        indexes.push(parseInt(sl, 2));
      }
      return indexes;
    }
    exports.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
    function bytesToMnemonics(src, wordsCount) {
      let mnemonics = bytesToMnemonicIndexes(src, wordsCount);
      let res = [];
      for (let m of mnemonics) {
        res.push(wordlist_1.wordlist[m]);
      }
      return res;
    }
    exports.bytesToMnemonics = bytesToMnemonics;
    function mnemonicIndexesToBytes(src) {
      let res = "";
      for (let s of src) {
        if (!Number.isSafeInteger(s)) {
          throw Error("Invalid input");
        }
        if (s < 0 || s >= 2028) {
          throw Error("Invalid input");
        }
        res += (0, binary_1.lpad)(s.toString(2), "0", 11);
      }
      while (res.length % 8 !== 0) {
        res = res + "0";
      }
      return (0, binary_1.bitsToBytes)(res);
    }
    exports.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
    async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
      const bytesLength = Math.ceil(wordsCount * 11 / 8);
      let currentSeed = seed;
      while (true) {
        let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
        let mnemonics = bytesToMnemonics(entropy, wordsCount);
        if (await mnemonicValidate(mnemonics, password)) {
          return mnemonics;
        }
        currentSeed = entropy;
      }
    }
    exports.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
  }
});

// node_modules/ton-crypto/dist/primitives/nacl.js
var require_nacl = __commonJS({
  "node_modules/ton-crypto/dist/primitives/nacl.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.openBox = exports.sealBox = exports.signVerify = exports.sign = exports.keyPairFromSeed = exports.keyPairFromSecretKey = void 0;
    var tweetnacl_1 = __importDefault(require_nacl_fast());
    function keyPairFromSecretKey(secretKey) {
      let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
      return {
        publicKey: import_buffer.Buffer.from(res.publicKey),
        secretKey: import_buffer.Buffer.from(res.secretKey)
      };
    }
    exports.keyPairFromSecretKey = keyPairFromSecretKey;
    function keyPairFromSeed(secretKey) {
      let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
      return {
        publicKey: import_buffer.Buffer.from(res.publicKey),
        secretKey: import_buffer.Buffer.from(res.secretKey)
      };
    }
    exports.keyPairFromSeed = keyPairFromSeed;
    function sign(data, secretKey) {
      return import_buffer.Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
    }
    exports.sign = sign;
    function signVerify(data, signature, publicKey) {
      return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
    }
    exports.signVerify = signVerify;
    function sealBox(data, nonce, key) {
      return import_buffer.Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key));
    }
    exports.sealBox = sealBox;
    function openBox(data, nonce, key) {
      let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
      if (!res) {
        return null;
      }
      return import_buffer.Buffer.from(res);
    }
    exports.openBox = openBox;
  }
});

// node_modules/ton-crypto/dist/hd/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/ton-crypto/dist/hd/ed25519.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = void 0;
    var hmac_sha512_1 = require_hmac_sha5122();
    var ED25519_CURVE = "ed25519 seed";
    var HARDENED_OFFSET = 2147483648;
    async function getED25519MasterKeyFromSeed(seed) {
      const I = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
    async function deriveED25519HardenedKey(parent, index) {
      if (index >= HARDENED_OFFSET) {
        throw Error("Key index must be less than offset");
      }
      const indexBuffer = import_buffer.Buffer.alloc(4);
      indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
      const data = import_buffer.Buffer.concat([import_buffer.Buffer.alloc(1, 0), parent.key, indexBuffer]);
      const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.deriveED25519HardenedKey = deriveED25519HardenedKey;
    async function deriveEd25519Path(seed, path) {
      let state = await getED25519MasterKeyFromSeed(seed);
      let remaining = [...path];
      while (remaining.length > 0) {
        let index = remaining[0];
        remaining = remaining.slice(1);
        state = await deriveED25519HardenedKey(state, index);
      }
      return state.key;
    }
    exports.deriveEd25519Path = deriveEd25519Path;
  }
});

// node_modules/ton-crypto/dist/hd/symmetric.js
var require_symmetric = __commonJS({
  "node_modules/ton-crypto/dist/hd/symmetric.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = void 0;
    var hmac_sha512_1 = require_hmac_sha5122();
    var SYMMETRIC_SEED = "Symmetric key seed";
    async function getSymmetricMasterKeyFromSeed(seed) {
      const I = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
      const IL = I.slice(32);
      const IR = I.slice(0, 32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
    async function deriveSymmetricHardenedKey(parent, offset) {
      const data = import_buffer.Buffer.concat([import_buffer.Buffer.alloc(1, 0), import_buffer.Buffer.from(offset)]);
      const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
      const IL = I.slice(32);
      const IR = I.slice(0, 32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
    async function deriveSymmetricPath(seed, path) {
      let state = await getSymmetricMasterKeyFromSeed(seed);
      let remaining = [...path];
      while (remaining.length > 0) {
        let index = remaining[0];
        remaining = remaining.slice(1);
        state = await deriveSymmetricHardenedKey(state, index);
      }
      return state.key;
    }
    exports.deriveSymmetricPath = deriveSymmetricPath;
  }
});

// node_modules/ton-crypto/dist/hd/mnemonics.js
var require_mnemonics = __commonJS({
  "node_modules/ton-crypto/dist/hd/mnemonics.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveMnemonicsPath = exports.deriveMnemonicHardenedKey = exports.getMnemonicsMasterKeyFromSeed = void 0;
    var mnemonic_1 = require_mnemonic();
    var hmac_sha512_1 = require_hmac_sha5122();
    var HARDENED_OFFSET = 2147483648;
    var MNEMONICS_SEED = "TON Mnemonics HD seed";
    async function getMnemonicsMasterKeyFromSeed(seed) {
      const I = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
    async function deriveMnemonicHardenedKey(parent, index) {
      if (index >= HARDENED_OFFSET) {
        throw Error("Key index must be less than offset");
      }
      const indexBuffer = import_buffer.Buffer.alloc(4);
      indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
      const data = import_buffer.Buffer.concat([import_buffer.Buffer.alloc(1, 0), parent.key, indexBuffer]);
      const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    }
    exports.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
    async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
      let state = await getMnemonicsMasterKeyFromSeed(seed);
      let remaining = [...path];
      while (remaining.length > 0) {
        let index = remaining[0];
        remaining = remaining.slice(1);
        state = await deriveMnemonicHardenedKey(state, index);
      }
      return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
    }
    exports.deriveMnemonicsPath = deriveMnemonicsPath;
  }
});

// node_modules/ton-crypto/dist/index.js
var require_dist = __commonJS({
  "node_modules/ton-crypto/dist/index.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
    var sha256_1 = require_sha2562();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_1.sha256;
    } });
    Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function() {
      return sha256_1.sha256_sync;
    } });
    var sha512_1 = require_sha5122();
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha512_1.sha512;
    } });
    Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function() {
      return sha512_1.sha512_sync;
    } });
    var pbkdf2_sha512_1 = require_pbkdf2_sha5122();
    Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function() {
      return pbkdf2_sha512_1.pbkdf2_sha512;
    } });
    var hmac_sha512_1 = require_hmac_sha5122();
    Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function() {
      return hmac_sha512_1.hmac_sha512;
    } });
    var getSecureRandom_1 = require_getSecureRandom2();
    Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomBytes;
    } });
    Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomWords;
    } });
    Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function() {
      return getSecureRandom_1.getSecureRandomNumber;
    } });
    var newSecureWords_1 = require_newSecureWords();
    Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function() {
      return newSecureWords_1.newSecureWords;
    } });
    var newSecurePassphrase_1 = require_newSecurePassphrase();
    Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function() {
      return newSecurePassphrase_1.newSecurePassphrase;
    } });
    var mnemonic_1 = require_mnemonic();
    Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicNew;
    } });
    Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicValidate;
    } });
    Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToPrivateKey;
    } });
    Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToWalletKey;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToSeed;
    } });
    Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function() {
      return mnemonic_1.mnemonicToHDSeed;
    } });
    var wordlist_1 = require_wordlist2();
    Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function() {
      return wordlist_1.wordlist;
    } });
    var nacl_1 = require_nacl();
    Object.defineProperty(exports, "sealBox", { enumerable: true, get: function() {
      return nacl_1.sealBox;
    } });
    Object.defineProperty(exports, "openBox", { enumerable: true, get: function() {
      return nacl_1.openBox;
    } });
    var nacl_2 = require_nacl();
    Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSeed;
    } });
    Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function() {
      return nacl_2.keyPairFromSecretKey;
    } });
    Object.defineProperty(exports, "sign", { enumerable: true, get: function() {
      return nacl_2.sign;
    } });
    Object.defineProperty(exports, "signVerify", { enumerable: true, get: function() {
      return nacl_2.signVerify;
    } });
    var ed25519_1 = require_ed25519();
    Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function() {
      return ed25519_1.getED25519MasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function() {
      return ed25519_1.deriveED25519HardenedKey;
    } });
    Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function() {
      return ed25519_1.deriveEd25519Path;
    } });
    var symmetric_1 = require_symmetric();
    Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function() {
      return symmetric_1.getSymmetricMasterKeyFromSeed;
    } });
    Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricHardenedKey;
    } });
    Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function() {
      return symmetric_1.deriveSymmetricPath;
    } });
    var mnemonics_1 = require_mnemonics();
    Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicsPath;
    } });
    Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function() {
      return mnemonics_1.deriveMnemonicHardenedKey;
    } });
    Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function() {
      return mnemonics_1.getMnemonicsMasterKeyFromSeed;
    } });
  }
});

// node_modules/ton-core/dist/boc/cell/wonderCalculator.js
var require_wonderCalculator = __commonJS({
  "node_modules/ton-core/dist/boc/cell/wonderCalculator.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wonderCalculator = void 0;
    var BitString_1 = require_BitString();
    var CellType_1 = require_CellType();
    var LevelMask_1 = require_LevelMask();
    var exoticPruned_1 = require_exoticPruned();
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    var descriptor_1 = require_descriptor();
    var ton_crypto_1 = require_dist();
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    var exoticLibrary_1 = require_exoticLibrary();
    function wonderCalculator(type, bits, refs) {
      let levelMask;
      let pruned = null;
      if (type === CellType_1.CellType.Ordinary) {
        let mask = 0;
        for (let r of refs) {
          mask = mask | r.mask.value;
        }
        levelMask = new LevelMask_1.LevelMask(mask);
      } else if (type === CellType_1.CellType.PrunedBranch) {
        pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
        levelMask = new LevelMask_1.LevelMask(pruned.mask);
      } else if (type === CellType_1.CellType.MerkleProof) {
        let loaded = (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
        levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
      } else if (type === CellType_1.CellType.MerkleUpdate) {
        let loaded = (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
        levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
      } else if (type === CellType_1.CellType.Library) {
        let loaded = (0, exoticLibrary_1.exoticLibrary)(bits, refs);
        levelMask = new LevelMask_1.LevelMask();
      } else {
        throw new Error("Unsupported exotic type");
      }
      let depths = [];
      let hashes = [];
      let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
      let totalHashCount = levelMask.hashCount;
      let hashIOffset = totalHashCount - hashCount;
      for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
        if (!levelMask.isSignificant(levelI)) {
          continue;
        }
        if (hashI < hashIOffset) {
          hashI++;
          continue;
        }
        let currentBits;
        if (hashI === hashIOffset) {
          if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
            throw Error("Invalid");
          }
          currentBits = bits;
        } else {
          if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
            throw Error("Invalid: " + levelI + ", " + type);
          }
          currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
        }
        let currentDepth = 0;
        for (let c of refs) {
          let childDepth;
          if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
            childDepth = c.depth(levelI + 1);
          } else {
            childDepth = c.depth(levelI);
          }
          currentDepth = Math.max(currentDepth, childDepth);
        }
        if (refs.length > 0) {
          currentDepth++;
        }
        let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, type);
        let hash = (0, ton_crypto_1.sha256_sync)(repr);
        let destI = hashI - hashIOffset;
        depths[destI] = currentDepth;
        hashes[destI] = hash;
        hashI++;
      }
      let resolvedHashes = [];
      let resolvedDepths = [];
      if (pruned) {
        for (let i = 0; i < 4; i++) {
          const { hashIndex } = levelMask.apply(i);
          const { hashIndex: thisHashIndex } = levelMask;
          if (hashIndex !== thisHashIndex) {
            resolvedHashes.push(pruned.pruned[hashIndex].hash);
            resolvedDepths.push(pruned.pruned[hashIndex].depth);
          } else {
            resolvedHashes.push(hashes[0]);
            resolvedDepths.push(depths[0]);
          }
        }
      } else {
        for (let i = 0; i < 4; i++) {
          resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
          resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
        }
      }
      return {
        mask: levelMask,
        hashes: resolvedHashes,
        depths: resolvedDepths
      };
    }
    exports.wonderCalculator = wonderCalculator;
  }
});

// node_modules/ton-core/dist/boc/cell/utils/topologicalSort.js
var require_topologicalSort = __commonJS({
  "node_modules/ton-core/dist/boc/cell/utils/topologicalSort.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.topologicalSort = void 0;
    function topologicalSort(src) {
      let pending = [src];
      let allCells = /* @__PURE__ */ new Map();
      let notPermCells = /* @__PURE__ */ new Set();
      let sorted = [];
      while (pending.length > 0) {
        const cells = [...pending];
        pending = [];
        for (let cell of cells) {
          const hash = cell.hash().toString("hex");
          if (allCells.has(hash)) {
            continue;
          }
          notPermCells.add(hash);
          allCells.set(hash, { cell, refs: cell.refs.map((v) => v.hash().toString("hex")) });
          for (let r of cell.refs) {
            pending.push(r);
          }
        }
      }
      let tempMark = /* @__PURE__ */ new Set();
      function visit(hash) {
        if (!notPermCells.has(hash)) {
          return;
        }
        if (tempMark.has(hash)) {
          throw Error("Not a DAG");
        }
        tempMark.add(hash);
        for (let c of allCells.get(hash).refs) {
          visit(c);
        }
        sorted.unshift(hash);
        tempMark.delete(hash);
        notPermCells.delete(hash);
      }
      while (notPermCells.size > 0) {
        const id = Array.from(notPermCells)[0];
        visit(id);
      }
      let indexes = /* @__PURE__ */ new Map();
      for (let i = 0; i < sorted.length; i++) {
        indexes.set(sorted[i], i);
      }
      let result = [];
      for (let ent of sorted) {
        const rrr = allCells.get(ent);
        result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });
      }
      return result;
    }
    exports.topologicalSort = topologicalSort;
  }
});

// node_modules/ton-core/dist/utils/bitsForNumber.js
var require_bitsForNumber = __commonJS({
  "node_modules/ton-core/dist/utils/bitsForNumber.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitsForNumber = void 0;
    function bitsForNumber(src, mode) {
      let v = BigInt(src);
      if (mode === "int") {
        if (v === 0n || v === -1n) {
          return 1;
        }
        let v2 = v > 0 ? v : -v;
        return v2.toString(2).length + 1;
      } else if (mode === "uint") {
        if (v < 0) {
          throw Error(`value is negative. Got ${src}`);
        }
        return v.toString(2).length;
      } else {
        throw Error(`invalid mode. Got ${mode}`);
      }
    }
    exports.bitsForNumber = bitsForNumber;
  }
});

// node_modules/ton-core/dist/utils/crc32c.js
var require_crc32c = __commonJS({
  "node_modules/ton-core/dist/utils/crc32c.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crc32c = void 0;
    var POLY = 2197175160;
    function crc32c(source) {
      let crc = 0 ^ 4294967295;
      for (let n = 0; n < source.length; n++) {
        crc ^= source[n];
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
      }
      crc = crc ^ 4294967295;
      let res = import_buffer.Buffer.alloc(4);
      res.writeInt32LE(crc);
      return res;
    }
    exports.crc32c = crc32c;
  }
});

// node_modules/ton-core/dist/boc/cell/serialization.js
var require_serialization = __commonJS({
  "node_modules/ton-core/dist/boc/cell/serialization.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeBoc = exports.deserializeBoc = exports.parseBoc = void 0;
    var BitReader_1 = require_BitReader();
    var BitString_1 = require_BitString();
    var Cell_1 = require_Cell();
    var topologicalSort_1 = require_topologicalSort();
    var bitsForNumber_1 = require_bitsForNumber();
    var BitBuilder_1 = require_BitBuilder();
    var descriptor_1 = require_descriptor();
    var paddedBits_1 = require_paddedBits();
    var crc32c_1 = require_crc32c();
    function getHashesCount(levelMask) {
      return getHashesCountFromMask(levelMask & 7);
    }
    function getHashesCountFromMask(mask) {
      let n = 0;
      for (let i = 0; i < 3; i++) {
        n += mask & 1;
        mask = mask >> 1;
      }
      return n + 1;
    }
    function readCell(reader, sizeBytes) {
      const d1 = reader.loadUint(8);
      const refsCount = d1 % 8;
      const exotic = !!(d1 & 8);
      const d2 = reader.loadUint(8);
      const dataBytesize = Math.ceil(d2 / 2);
      const paddingAdded = !!(d2 % 2);
      const levelMask = d1 >> 5;
      const hasHashes = (d1 & 16) != 0;
      const hash_bytes = 32;
      const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
      const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
      reader.skip(hashesSize * 8);
      reader.skip(depthSize * 8);
      let bits = BitString_1.BitString.EMPTY;
      if (dataBytesize > 0) {
        if (paddingAdded) {
          bits = reader.loadPaddedBits(dataBytesize * 8);
        } else {
          bits = reader.loadBits(dataBytesize * 8);
        }
      }
      let refs = [];
      for (let i = 0; i < refsCount; i++) {
        refs.push(reader.loadUint(sizeBytes * 8));
      }
      return {
        bits,
        refs,
        exotic
      };
    }
    function calcCellSize(cell, sizeBytes) {
      return 2 + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
    }
    function parseBoc(src) {
      let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
      let magic = reader.loadUint(32);
      if (magic === 1761568243) {
        let size = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8);
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        return {
          size,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root: [0]
        };
      } else if (magic === 2898503464) {
        let size = reader.loadUint(8);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8);
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let index = reader.loadBuffer(cells * offBytes);
        let cellData = reader.loadBuffer(totalCellSize);
        let crc32 = reader.loadBuffer(4);
        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
          throw Error("Invalid CRC32C");
        }
        return {
          size,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root: [0]
        };
      } else if (magic === 3052313714) {
        let hasIdx = reader.loadUint(1);
        let hasCrc32c = reader.loadUint(1);
        let hasCacheBits = reader.loadUint(1);
        let flags = reader.loadUint(2);
        let size = reader.loadUint(3);
        let offBytes = reader.loadUint(8);
        let cells = reader.loadUint(size * 8);
        let roots = reader.loadUint(size * 8);
        let absent = reader.loadUint(size * 8);
        let totalCellSize = reader.loadUint(offBytes * 8);
        let root = [];
        for (let i = 0; i < roots; i++) {
          root.push(reader.loadUint(size * 8));
        }
        let index = null;
        if (hasIdx) {
          index = reader.loadBuffer(cells * offBytes);
        }
        let cellData = reader.loadBuffer(totalCellSize);
        if (hasCrc32c) {
          let crc32 = reader.loadBuffer(4);
          if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
            throw Error("Invalid CRC32C");
          }
        }
        return {
          size,
          offBytes,
          cells,
          roots,
          absent,
          totalCellSize,
          index,
          cellData,
          root
        };
      } else {
        throw Error("Invalid magic");
      }
    }
    exports.parseBoc = parseBoc;
    function deserializeBoc(src) {
      let boc = parseBoc(src);
      let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
      let cells = [];
      for (let i = 0; i < boc.cells; i++) {
        let cll = readCell(reader, boc.size);
        cells.push({ ...cll, result: null });
      }
      for (let i = cells.length - 1; i >= 0; i--) {
        if (cells[i].result) {
          throw Error("Impossible");
        }
        let refs = [];
        for (let r of cells[i].refs) {
          if (!cells[r].result) {
            throw Error("Invalid BOC file");
          }
          refs.push(cells[r].result);
        }
        cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
      }
      let roots = [];
      for (let i = 0; i < boc.root.length; i++) {
        roots.push(cells[boc.root[i]].result);
      }
      return roots;
    }
    exports.deserializeBoc = deserializeBoc;
    function writeCellToBuilder(cell, refs, sizeBytes, to) {
      let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.level(), cell.type);
      let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
      to.writeUint(d1, 8);
      to.writeUint(d2, 8);
      to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
      for (let r of refs) {
        to.writeUint(r, sizeBytes * 8);
      }
    }
    function serializeBoc(root, opts) {
      let allCells = (0, topologicalSort_1.topologicalSort)(root);
      let cellsNum = allCells.length;
      let has_idx = opts.idx;
      let has_crc32c = opts.crc32;
      let has_cache_bits = false;
      let flags = 0;
      let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, "uint") / 8), 1);
      let totalCellSize = 0;
      let index = [];
      for (let c of allCells) {
        let sz = calcCellSize(c.cell, sizeBytes);
        index.push(totalCellSize);
        totalCellSize += sz;
      }
      let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, "uint") / 8), 1);
      let totalSize = (4 + // magic
      1 + // flags and s_bytes
      1 + // offset_bytes
      3 * sizeBytes + // cells_num, roots, complete
      offsetBytes + // full_size
      1 * sizeBytes + // root_idx
      (has_idx ? cellsNum * offsetBytes : 0) + totalCellSize + (has_crc32c ? 4 : 0)) * 8;
      let builder = new BitBuilder_1.BitBuilder(totalSize);
      builder.writeUint(3052313714, 32);
      builder.writeBit(has_idx);
      builder.writeBit(has_crc32c);
      builder.writeBit(has_cache_bits);
      builder.writeUint(flags, 2);
      builder.writeUint(sizeBytes, 3);
      builder.writeUint(offsetBytes, 8);
      builder.writeUint(cellsNum, sizeBytes * 8);
      builder.writeUint(1, sizeBytes * 8);
      builder.writeUint(0, sizeBytes * 8);
      builder.writeUint(totalCellSize, offsetBytes * 8);
      builder.writeUint(0, sizeBytes * 8);
      if (has_idx) {
        for (let i = 0; i < cellsNum; i++) {
          builder.writeUint(index[i], offsetBytes * 8);
        }
      }
      for (let i = 0; i < cellsNum; i++) {
        writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);
      }
      if (has_crc32c) {
        let crc32 = (0, crc32c_1.crc32c)(builder.buffer());
        builder.writeBuffer(crc32);
      }
      let res = builder.buffer();
      if (res.length !== totalSize / 8) {
        throw Error("Internal error");
      }
      return res;
    }
    exports.serializeBoc = serializeBoc;
  }
});

// node_modules/ton-core/dist/boc/Cell.js
var require_Cell = __commonJS({
  "node_modules/ton-core/dist/boc/Cell.js"(exports) {
    "use strict";
    init_shim();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cell = void 0;
    var symbol_inspect_1 = __importDefault(require_symbol());
    var BitString_1 = require_BitString();
    var CellType_1 = require_CellType();
    var Slice_1 = require_Slice();
    var resolveExotic_1 = require_resolveExotic();
    var wonderCalculator_1 = require_wonderCalculator();
    var serialization_1 = require_serialization();
    var BitReader_1 = require_BitReader();
    var Builder_1 = require_Builder();
    var Cell = class {
      /**
       * Deserialize cells from BOC
       * @param src source buffer
       * @returns array of cells
       */
      static fromBoc(src) {
        return (0, serialization_1.deserializeBoc)(src);
      }
      /**
       * Helper class that deserializes a single cell from BOC in base64
       * @param src source string
       */
      static fromBase64(src) {
        let parsed = Cell.fromBoc(import_buffer.Buffer.from(src, "base64"));
        if (parsed.length !== 1) {
          throw new Error("Deserialized more than one cell");
        }
        return parsed[0];
      }
      constructor(opts) {
        this._hashes = [];
        this._depths = [];
        this.beginParse = (allowExotic = false) => {
          if (this.isExotic && !allowExotic) {
            throw new Error("Exotic cells cannot be parsed");
          }
          return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
        };
        this.hash = (level = 3) => {
          return this._hashes[Math.min(this._hashes.length - 1, level)];
        };
        this.depth = (level = 3) => {
          return this._depths[Math.min(this._depths.length - 1, level)];
        };
        this.level = () => {
          return this.mask.level;
        };
        this.equals = (other) => {
          return this.hash().equals(other.hash());
        };
        this[_a] = () => this.toString();
        let bits = BitString_1.BitString.EMPTY;
        if (opts && opts.bits) {
          bits = opts.bits;
        }
        let refs = [];
        if (opts && opts.refs) {
          refs = [...opts.refs];
        }
        let hashes;
        let depths;
        let mask;
        let type = CellType_1.CellType.Ordinary;
        if (opts && opts.exotic) {
          let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
          let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
          mask = wonders.mask;
          depths = wonders.depths;
          hashes = wonders.hashes;
          type = resolved.type;
        } else {
          if (refs.length > 4) {
            throw new Error("Invalid number of references");
          }
          if (bits.length > 1023) {
            throw new Error(`Bits overflow: ${bits.length} > 1023`);
          }
          let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
          mask = wonders.mask;
          depths = wonders.depths;
          hashes = wonders.hashes;
          type = CellType_1.CellType.Ordinary;
        }
        this.type = type;
        this.bits = bits;
        this.refs = refs;
        this.mask = mask;
        this._depths = depths;
        this._hashes = hashes;
        Object.freeze(this);
        Object.freeze(this.refs);
        Object.freeze(this.bits);
        Object.freeze(this.mask);
        Object.freeze(this._depths);
        Object.freeze(this._hashes);
      }
      /**
       * Check if cell is exotic
       */
      get isExotic() {
        return this.type !== CellType_1.CellType.Ordinary;
      }
      /**
       * Serializes cell to BOC
       * @param opts options
       */
      toBoc(opts) {
        let idx = opts && opts.idx !== null && opts.idx !== void 0 ? opts.idx : false;
        let crc32 = opts && opts.crc32 !== null && opts.crc32 !== void 0 ? opts.crc32 : true;
        return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
      }
      /**
       * Format cell to string
       * @param indent indentation
       * @returns string representation
       */
      toString(indent) {
        let id = indent || "";
        let t = "x";
        if (this.isExotic) {
          if (this.type === CellType_1.CellType.MerkleProof) {
            t = "p";
          } else if (this.type === CellType_1.CellType.MerkleUpdate) {
            t = "u";
          } else if (this.type === CellType_1.CellType.PrunedBranch) {
            t = "p";
          }
        }
        let s = id + (this.isExotic ? t : "x") + "{" + this.bits.toString() + "}";
        for (let k in this.refs) {
          const i = this.refs[k];
          s += "\n" + i.toString(id + " ");
        }
        return s;
      }
      /**
       * Covnert cell to slice
       * @returns slice
       */
      asSlice() {
        return this.beginParse();
      }
      /**
       * Convert cell to a builder that has this cell stored
       * @returns builder
       */
      asBuilder() {
        return (0, Builder_1.beginCell)().storeSlice(this.asSlice());
      }
    };
    exports.Cell = Cell;
    _a = symbol_inspect_1.default;
    Cell.EMPTY = new Cell();
  }
});

// node_modules/ton-core/dist/boc/Builder.js
var require_Builder = __commonJS({
  "node_modules/ton-core/dist/boc/Builder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Builder = exports.beginCell = void 0;
    var BitBuilder_1 = require_BitBuilder();
    var Cell_1 = require_Cell();
    var strings_1 = require_strings();
    function beginCell() {
      return new Builder();
    }
    exports.beginCell = beginCell;
    var Builder = class {
      constructor() {
        this._bits = new BitBuilder_1.BitBuilder();
        this._refs = [];
      }
      /**
       * Bits written so far
       */
      get bits() {
        return this._bits.length;
      }
      /**
       * References written so far
       */
      get refs() {
        return this._refs.length;
      }
      /**
       * Available bits
       */
      get availableBits() {
        return 1023 - this.bits;
      }
      /**
       * Available references
       */
      get availableRefs() {
        return 4 - this.refs;
      }
      /**
       * Write a single bit
       * @param value bit to write, true or positive number for 1, false or zero or negative for 0
       * @returns this builder
       */
      storeBit(value) {
        this._bits.writeBit(value);
        return this;
      }
      /**
       * Write bits from BitString
       * @param src source bits
       * @returns this builder
       */
      storeBits(src) {
        this._bits.writeBits(src);
        return this;
      }
      /**
       * Store Buffer
       * @param src source buffer
       * @param bytes optional number of bytes to write
       * @returns this builder
       */
      storeBuffer(src, bytes) {
        if (bytes !== void 0 && bytes !== null) {
          if (src.length !== bytes) {
            throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
          }
        }
        this._bits.writeBuffer(src);
        return this;
      }
      /**
       * Store Maybe Buffer
       * @param src source buffer or null
       * @param bytes optional number of bytes to write
       * @returns this builder
       */
      storeMaybeBuffer(src, bytes) {
        if (src !== null) {
          this.storeBit(1);
          this.storeBuffer(src, bytes);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store uint value
       * @param value value as bigint or number
       * @param bits number of bits to write
       * @returns this builder
       */
      storeUint(value, bits) {
        this._bits.writeUint(value, bits);
        return this;
      }
      /**
       * Store maybe uint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write
       * @returns this builder
       */
      storeMaybeUint(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeUint(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store int value
       * @param value value as bigint or number
       * @param bits number of bits to write
       * @returns this builder
       */
      storeInt(value, bits) {
        this._bits.writeInt(value, bits);
        return this;
      }
      /**
       * Store maybe int value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write
       * @returns this builder
       */
      storeMaybeInt(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeInt(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store varuint value
       * @param value value as bigint or number
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeVarUint(value, bits) {
        this._bits.writeVarUint(value, bits);
        return this;
      }
      /**
       * Store maybe varuint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeMaybeVarUint(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeVarUint(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store varint value
       * @param value value as bigint or number
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeVarInt(value, bits) {
        this._bits.writeVarInt(value, bits);
        return this;
      }
      /**
       * Store maybe varint value
       * @param value value as bigint or number, null or undefined
       * @param bits number of bits to write to header
       * @returns this builder
       */
      storeMaybeVarInt(value, bits) {
        if (value !== null && value !== void 0) {
          this.storeBit(1);
          this.storeVarInt(value, bits);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store coins value
       * @param amount amount of coins
       * @returns this builder
       */
      storeCoins(amount) {
        this._bits.writeCoins(amount);
        return this;
      }
      /**
       * Store maybe coins value
       * @param amount amount of coins, null or undefined
       * @returns this builder
       */
      storeMaybeCoins(amount) {
        if (amount !== null && amount !== void 0) {
          this.storeBit(1);
          this.storeCoins(amount);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store address
       * @param addres address to store
       * @returns this builder
       */
      storeAddress(address) {
        this._bits.writeAddress(address);
        return this;
      }
      /**
       * Store reference
       * @param cell cell or builder to store
       * @returns this builder
       */
      storeRef(cell) {
        if (this._refs.length >= 4) {
          throw new Error("Too many references");
        }
        if (cell instanceof Cell_1.Cell) {
          this._refs.push(cell);
        } else if (cell instanceof Builder) {
          this._refs.push(cell.endCell());
        } else {
          throw new Error("Invalid argument");
        }
        return this;
      }
      /**
       * Store reference if not null
       * @param cell cell or builder to store
       * @returns this builder
       */
      storeMaybeRef(cell) {
        if (cell) {
          this.storeBit(1);
          this.storeRef(cell);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store slice it in this builder
       * @param src source slice
       */
      storeSlice(src) {
        let c = src.clone();
        if (c.remainingBits > 0) {
          this.storeBits(c.loadBits(c.remainingBits));
        }
        while (c.remainingRefs > 0) {
          this.storeRef(c.loadRef());
        }
        return this;
      }
      /**
       * Store slice in this builder if not null
       * @param src source slice
       */
      storeMaybeSlice(src) {
        if (src) {
          this.storeBit(1);
          this.storeSlice(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store builder
       * @param src builder to store
       * @returns this builder
       */
      storeBuilder(src) {
        return this.storeSlice(src.endCell().beginParse());
      }
      /**
       * Store builder if not null
       * @param src builder to store
       * @returns this builder
       */
      storeMaybeBuilder(src) {
        if (src) {
          this.storeBit(1);
          this.storeBuilder(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store writer or builder
       * @param writer writer or builder to store
       * @returns this builder
       */
      storeWritable(writer) {
        if (typeof writer === "object") {
          writer.writeTo(this);
        } else {
          writer(this);
        }
        return this;
      }
      /**
       * Store writer or builder if not null
       * @param writer writer or builder to store
       * @returns this builder
       */
      storeMaybeWritable(writer) {
        if (writer) {
          this.storeBit(1);
          this.storeWritable(writer);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store object in this builder
       * @param writer Writable or writer functuin
       */
      store(writer) {
        this.storeWritable(writer);
        return this;
      }
      /**
       * Store string tail
       * @param src source string
       * @returns this builder
       */
      storeStringTail(src) {
        (0, strings_1.writeString)(src, this);
        return this;
      }
      /**
       * Store string tail
       * @param src source string
       * @returns this builder
       */
      storeMaybeStringTail(src) {
        if (src !== null && src !== void 0) {
          this.storeBit(1);
          (0, strings_1.writeString)(src, this);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store string tail in ref
       * @param src source string
       * @returns this builder
       */
      storeStringRefTail(src) {
        this.storeRef(beginCell().storeStringTail(src));
        return this;
      }
      /**
       * Store maybe string tail in ref
       * @param src source string
       * @returns this builder
       */
      storeMaybeStringRefTail(src) {
        if (src !== null && src !== void 0) {
          this.storeBit(1);
          this.storeStringRefTail(src);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store dictionary in this builder
       * @param dict dictionary to store
       * @returns this builder
       */
      storeDict(dict, key, value) {
        if (dict) {
          dict.store(this, key, value);
        } else {
          this.storeBit(0);
        }
        return this;
      }
      /**
       * Store dictionary in this builder directly
       * @param dict dictionary to store
       * @returns this builder
       */
      storeDictDirect(dict, key, value) {
        dict.storeDirect(this, key, value);
        return this;
      }
      /**
       * Complete cell
       * @returns cell
       */
      endCell() {
        return new Cell_1.Cell({
          bits: this._bits.build(),
          refs: this._refs
        });
      }
      /**
       * Convert to cell
       * @returns cell
       */
      asCell() {
        return this.endCell();
      }
      /**
       * Convert to slice
       * @returns slice
       */
      asSlice() {
        return this.endCell().beginParse();
      }
    };
    exports.Builder = Builder;
  }
});

// node_modules/ton-core/dist/types/SimpleLibrary.js
var require_SimpleLibrary = __commonJS({
  "node_modules/ton-core/dist/types/SimpleLibrary.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleLibraryValue = exports.storeSimpleLibrary = exports.loadSimpleLibrary = void 0;
    function loadSimpleLibrary(slice) {
      return {
        public: slice.loadBit(),
        root: slice.loadRef()
      };
    }
    exports.loadSimpleLibrary = loadSimpleLibrary;
    function storeSimpleLibrary(src) {
      return (builder) => {
        builder.storeBit(src.public);
        builder.storeRef(src.root);
      };
    }
    exports.storeSimpleLibrary = storeSimpleLibrary;
    exports.SimpleLibraryValue = {
      serialize(src, builder) {
        storeSimpleLibrary(src)(builder);
      },
      parse(src) {
        return loadSimpleLibrary(src);
      }
    };
  }
});

// node_modules/ton-core/dist/types/TickTock.js
var require_TickTock = __commonJS({
  "node_modules/ton-core/dist/types/TickTock.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTickTock = exports.loadTickTock = void 0;
    function loadTickTock(slice) {
      return {
        tick: slice.loadBit(),
        tock: slice.loadBit()
      };
    }
    exports.loadTickTock = loadTickTock;
    function storeTickTock(src) {
      return (builder) => {
        builder.storeBit(src.tick);
        builder.storeBit(src.tock);
      };
    }
    exports.storeTickTock = storeTickTock;
  }
});

// node_modules/ton-core/dist/types/StateInit.js
var require_StateInit = __commonJS({
  "node_modules/ton-core/dist/types/StateInit.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStateInit = exports.loadStateInit = void 0;
    var Dictionary_1 = require_Dictionary();
    var SimpleLibrary_1 = require_SimpleLibrary();
    var TickTock_1 = require_TickTock();
    function loadStateInit(slice) {
      let splitDepth;
      if (slice.loadBit()) {
        splitDepth = slice.loadUint(5);
      }
      let special;
      if (slice.loadBit()) {
        special = (0, TickTock_1.loadTickTock)(slice);
      }
      let code = slice.loadMaybeRef();
      let data = slice.loadMaybeRef();
      let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
      if (libraries.size === 0) {
        libraries = void 0;
      }
      return {
        splitDepth,
        special,
        code,
        data,
        libraries
      };
    }
    exports.loadStateInit = loadStateInit;
    function storeStateInit(src) {
      return (builder) => {
        if (src.splitDepth !== null && src.splitDepth !== void 0) {
          builder.storeBit(true);
          builder.storeUint(src.splitDepth, 5);
        } else {
          builder.storeBit(false);
        }
        if (src.special !== null && src.special !== void 0) {
          builder.storeBit(true);
          builder.store((0, TickTock_1.storeTickTock)(src.special));
        } else {
          builder.storeBit(false);
        }
        builder.storeMaybeRef(src.code);
        builder.storeMaybeRef(src.data);
        builder.storeDict(src.libraries);
      };
    }
    exports.storeStateInit = storeStateInit;
  }
});

// node_modules/ton-core/dist/address/contractAddress.js
var require_contractAddress = __commonJS({
  "node_modules/ton-core/dist/address/contractAddress.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contractAddress = void 0;
    var Builder_1 = require_Builder();
    var StateInit_1 = require_StateInit();
    var Address_1 = require_Address();
    function contractAddress(workchain, init) {
      let hash = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(init)).endCell().hash();
      return new Address_1.Address(workchain, hash);
    }
    exports.contractAddress = contractAddress;
  }
});

// node_modules/ton-core/dist/tuple/tuple.js
var require_tuple = __commonJS({
  "node_modules/ton-core/dist/tuple/tuple.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTuple = exports.serializeTuple = void 0;
    var Builder_1 = require_Builder();
    var INT64_MIN = BigInt("-9223372036854775808");
    var INT64_MAX = BigInt("9223372036854775807");
    function serializeTupleItem(src, builder) {
      if (src.type === "null") {
        builder.storeUint(0, 8);
      } else if (src.type === "int") {
        if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
          builder.storeUint(1, 8);
          builder.storeInt(src.value, 64);
        } else {
          builder.storeUint(256, 15);
          builder.storeInt(src.value, 257);
        }
      } else if (src.type === "nan") {
        builder.storeInt(767, 16);
      } else if (src.type === "cell") {
        builder.storeUint(3, 8);
        builder.storeRef(src.cell);
      } else if (src.type === "slice") {
        builder.storeUint(4, 8);
        builder.storeUint(0, 10);
        builder.storeUint(src.cell.bits.length, 10);
        builder.storeUint(0, 3);
        builder.storeUint(src.cell.refs.length, 3);
        builder.storeRef(src.cell);
      } else if (src.type === "builder") {
        builder.storeUint(5, 8);
        builder.storeRef(src.cell);
      } else if (src.type === "tuple") {
        let head = null;
        let tail = null;
        for (let i = 0; i < src.items.length; i++) {
          let s = head;
          head = tail;
          tail = s;
          if (i > 1) {
            head = (0, Builder_1.beginCell)().storeRef(tail).storeRef(head).endCell();
          }
          let bc = (0, Builder_1.beginCell)();
          serializeTupleItem(src.items[i], bc);
          tail = bc.endCell();
        }
        builder.storeUint(7, 8);
        builder.storeUint(src.items.length, 16);
        if (head) {
          builder.storeRef(head);
        }
        if (tail) {
          builder.storeRef(tail);
        }
      } else {
        throw Error("Invalid value");
      }
    }
    function parseStackItem(cs) {
      let kind = cs.loadUint(8);
      if (kind === 0) {
        return { type: "null" };
      } else if (kind === 1) {
        return { type: "int", value: cs.loadIntBig(64) };
      } else if (kind === 2) {
        if (cs.loadUint(7) === 0) {
          return { type: "int", value: cs.loadIntBig(257) };
        } else {
          cs.loadBit();
          return { type: "nan" };
        }
      } else if (kind === 3) {
        return { type: "cell", cell: cs.loadRef() };
      } else if (kind === 4) {
        let startBits = cs.loadUint(10);
        let endBits = cs.loadUint(10);
        let startRefs = cs.loadUint(3);
        let endRefs = cs.loadUint(3);
        let rs = cs.loadRef().beginParse();
        rs.skip(startBits);
        let dt = rs.loadBits(endBits - startBits);
        let builder = (0, Builder_1.beginCell)().storeBits(dt);
        if (startRefs < endRefs) {
          for (let i = 0; i < startRefs; i++) {
            rs.loadRef();
          }
          for (let i = 0; i < endRefs - startRefs; i++) {
            builder.storeRef(rs.loadRef());
          }
        }
        return { type: "slice", cell: builder.endCell() };
      } else if (kind === 5) {
        return { type: "builder", cell: cs.loadRef() };
      } else if (kind === 7) {
        let length = cs.loadUint(16);
        let items = [];
        if (length > 1) {
          let head = cs.loadRef().beginParse();
          let tail = cs.loadRef().beginParse();
          items.unshift(parseStackItem(tail));
          for (let i = 0; i < length - 2; i++) {
            let ohead = head;
            head = ohead.loadRef().beginParse();
            tail = ohead.loadRef().beginParse();
            items.unshift(parseStackItem(tail));
          }
          items.unshift(parseStackItem(head));
        } else if (length === 1) {
          items.push(parseStackItem(cs.loadRef().beginParse()));
        }
        return { type: "tuple", items };
      } else {
        throw Error("Unsupported stack item");
      }
    }
    function serializeTupleTail(src, builder) {
      if (src.length > 0) {
        let tail = (0, Builder_1.beginCell)();
        serializeTupleTail(src.slice(0, src.length - 1), tail);
        builder.storeRef(tail.endCell());
        serializeTupleItem(src[src.length - 1], builder);
      }
    }
    function serializeTuple(src) {
      let builder = (0, Builder_1.beginCell)();
      builder.storeUint(src.length, 24);
      let r = [...src];
      serializeTupleTail(r, builder);
      return builder.endCell();
    }
    exports.serializeTuple = serializeTuple;
    function parseTuple(src) {
      let res = [];
      let cs = src.beginParse();
      let size = cs.loadUint(24);
      for (let i = 0; i < size; i++) {
        let next = cs.loadRef();
        res.unshift(parseStackItem(cs));
        cs = next.beginParse();
      }
      return res;
    }
    exports.parseTuple = parseTuple;
  }
});

// node_modules/ton-core/dist/tuple/reader.js
var require_reader = __commonJS({
  "node_modules/ton-core/dist/tuple/reader.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleReader = void 0;
    var TupleReader = class {
      constructor(items) {
        this.items = [...items];
      }
      get remaining() {
        return this.items.length;
      }
      peek() {
        if (this.items.length === 0) {
          throw Error("EOF");
        }
        return this.items[0];
      }
      pop() {
        if (this.items.length === 0) {
          throw Error("EOF");
        }
        let res = this.items[0];
        this.items.splice(0, 1);
        return res;
      }
      skip(num = 1) {
        for (let i = 0; i < num; i++) {
          this.pop();
        }
        return this;
      }
      readBigNumber() {
        let popped = this.pop();
        if (popped.type !== "int") {
          throw Error("Not a number");
        }
        return popped.value;
      }
      readBigNumberOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "int") {
          throw Error("Not a number");
        }
        return popped.value;
      }
      readNumber() {
        return Number(this.readBigNumber());
      }
      readNumberOpt() {
        let r = this.readBigNumberOpt();
        if (r !== null) {
          return Number(r);
        } else {
          return null;
        }
      }
      readBoolean() {
        let res = this.readNumber();
        return res === 0 ? false : true;
      }
      readBooleanOpt() {
        let res = this.readNumberOpt();
        if (res !== null) {
          return res === 0 ? false : true;
        } else {
          return null;
        }
      }
      readAddress() {
        let r = this.readCell().beginParse().loadAddress();
        if (r !== null) {
          return r;
        } else {
          throw Error("Not an address");
        }
      }
      readAddressOpt() {
        let r = this.readCellOpt();
        if (r !== null) {
          return r.beginParse().loadMaybeAddress();
        } else {
          return null;
        }
      }
      readCell() {
        let popped = this.pop();
        if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
          throw Error("Not a cell: " + popped.type);
        }
        return popped.cell;
      }
      readCellOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "cell" && popped.type !== "slice" && popped.type !== "builder") {
          throw Error("Not a cell");
        }
        return popped.cell;
      }
      readTuple() {
        let popped = this.pop();
        if (popped.type !== "tuple") {
          throw Error("Not a number");
        }
        return new TupleReader(popped.items);
      }
      readTupleOpt() {
        let popped = this.pop();
        if (popped.type === "null") {
          return null;
        }
        if (popped.type !== "tuple") {
          throw Error("Not a number");
        }
        return new TupleReader(popped.items);
      }
      readBuffer() {
        let s = this.readCell().beginParse();
        if (s.remainingRefs !== 0) {
          throw Error("Not a buffer");
        }
        if (s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      }
      readBufferOpt() {
        let popped = this.peek();
        if (popped.type === "null") {
          return null;
        }
        let s = this.readCell().beginParse();
        if (s.remainingRefs !== 0) {
          throw Error("Not a buffer");
        }
        if (s.remainingBits % 8 !== 0) {
          throw Error("Not a buffer");
        }
        return s.loadBuffer(s.remainingBits / 8);
      }
      readString() {
        let s = this.readCell().beginParse();
        return s.loadStringTail();
      }
      readStringOpt() {
        let popped = this.peek();
        if (popped.type === "null") {
          return null;
        }
        let s = this.readCell().beginParse();
        return s.loadStringTail();
      }
    };
    exports.TupleReader = TupleReader;
  }
});

// node_modules/ton-core/dist/tuple/builder.js
var require_builder = __commonJS({
  "node_modules/ton-core/dist/tuple/builder.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleBuilder = void 0;
    var Builder_1 = require_Builder();
    var Cell_1 = require_Cell();
    var Slice_1 = require_Slice();
    var TupleBuilder = class {
      constructor() {
        this._tuple = [];
      }
      writeNumber(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "int", value: BigInt(v) });
        }
      }
      writeBoolean(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "int", value: v ? -1n : 0n });
        }
      }
      writeBuffer(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeBuffer(v).endCell() });
        }
      }
      writeString(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeStringTail(v).endCell() });
        }
      }
      writeCell(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "cell", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "cell", cell: v.asCell() });
          }
        }
      }
      writeSlice(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "slice", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "slice", cell: v.asCell() });
          }
        }
      }
      writeBuilder(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          if (v instanceof Cell_1.Cell) {
            this._tuple.push({ type: "builder", cell: v });
          } else if (v instanceof Slice_1.Slice) {
            this._tuple.push({ type: "builder", cell: v.asCell() });
          }
        }
      }
      writeTuple(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "tuple", items: v });
        }
      }
      writeAddress(v) {
        if (v === null || v === void 0) {
          this._tuple.push({ type: "null" });
        } else {
          this._tuple.push({ type: "slice", cell: (0, Builder_1.beginCell)().storeAddress(v).endCell() });
        }
      }
      build() {
        return [...this._tuple];
      }
    };
    exports.TupleBuilder = TupleBuilder;
  }
});

// node_modules/ton-core/dist/utils/convert.js
var require_convert = __commonJS({
  "node_modules/ton-core/dist/utils/convert.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromNano = exports.toNano = void 0;
    function toNano(src) {
      if (typeof src === "bigint") {
        return src * 1000000000n;
      } else if (typeof src === "number") {
        return BigInt(src) * 1000000000n;
      } else {
        let neg = false;
        while (src.startsWith("-")) {
          neg = !neg;
          src = src.slice(1);
        }
        if (src === ".") {
          throw Error("Invalid number");
        }
        let parts = src.split(".");
        if (parts.length > 2) {
          throw Error("Invalid number");
        }
        let whole = parts[0];
        let frac = parts[1];
        if (!whole) {
          whole = "0";
        }
        if (!frac) {
          frac = "0";
        }
        if (frac.length > 9) {
          throw Error("Invalid number");
        }
        while (frac.length < 9) {
          frac += "0";
        }
        let r = BigInt(whole) * 1000000000n + BigInt(frac);
        if (neg) {
          r = -r;
        }
        return r;
      }
    }
    exports.toNano = toNano;
    function fromNano(src) {
      let v = BigInt(src);
      let neg = false;
      if (v < 0) {
        neg = true;
        v = -v;
      }
      let frac = v % 1000000000n;
      let facStr = frac.toString();
      while (facStr.length < 9) {
        facStr = "0" + facStr;
      }
      facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      let whole = v / 1000000000n;
      let wholeStr = whole.toString();
      let value = `${wholeStr}${facStr === "0" ? "" : `.${facStr}`}`;
      if (neg) {
        value = "-" + value;
      }
      return value;
    }
    exports.fromNano = fromNano;
  }
});

// node_modules/ton-core/dist/types/_helpers.js
var require_helpers = __commonJS({
  "node_modules/ton-core/dist/types/_helpers.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.comment = exports.external = exports.internal = void 0;
    var Address_1 = require_Address();
    var Cell_1 = require_Cell();
    var Builder_1 = require_Builder();
    var convert_1 = require_convert();
    function internal(src) {
      let bounce = true;
      if (src.bounce !== null && src.bounce !== void 0) {
        bounce = src.bounce;
      }
      let to;
      if (typeof src.to === "string") {
        to = Address_1.Address.parse(src.to);
      } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
      } else {
        throw new Error(`Invalid address ${src.to}`);
      }
      let value;
      if (typeof src.value === "string") {
        value = (0, convert_1.toNano)(src.value);
      } else {
        value = src.value;
      }
      let body = Cell_1.Cell.EMPTY;
      if (typeof src.body === "string") {
        body = (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
      } else if (src.body) {
        body = src.body;
      }
      return {
        info: {
          type: "internal",
          dest: to,
          value: { coins: value },
          bounce,
          ihrDisabled: true,
          bounced: false,
          ihrFee: 0n,
          forwardFee: 0n,
          createdAt: 0,
          createdLt: 0n
        },
        init: src.init ? { code: src.init.code, data: src.init.data } : void 0,
        body
      };
    }
    exports.internal = internal;
    function external(src) {
      let to;
      if (typeof src.to === "string") {
        to = Address_1.Address.parse(src.to);
      } else if (Address_1.Address.isAddress(src.to)) {
        to = src.to;
      } else {
        throw new Error(`Invalid address ${src.to}`);
      }
      return {
        info: {
          type: "external-in",
          dest: to,
          importFee: 0n
        },
        init: src.init ? { code: src.init.code, data: src.init.data } : void 0,
        body: src.body || Cell_1.Cell.EMPTY
      };
    }
    exports.external = external;
    function comment(src) {
      return (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src).endCell();
    }
    exports.comment = comment;
  }
});

// node_modules/ton-core/dist/types/AccountState.js
var require_AccountState = __commonJS({
  "node_modules/ton-core/dist/types/AccountState.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountState = exports.loadAccountState = void 0;
    var StateInit_1 = require_StateInit();
    function loadAccountState(cs) {
      if (cs.loadBit()) {
        return { type: "active", state: (0, StateInit_1.loadStateInit)(cs) };
      } else if (cs.loadBit()) {
        return { type: "frozen", stateHash: cs.loadUintBig(256) };
      } else {
        return { type: "uninit" };
      }
    }
    exports.loadAccountState = loadAccountState;
    function storeAccountState(src) {
      return (builder) => {
        if (src.type === "active") {
          builder.storeBit(true);
          builder.store((0, StateInit_1.storeStateInit)(src.state));
        } else if (src.type === "frozen") {
          builder.storeBit(false);
          builder.storeBit(true);
          builder.storeUint(src.stateHash, 256);
        } else if (src.type === "uninit") {
          builder.storeBit(false);
          builder.storeBit(false);
        }
      };
    }
    exports.storeAccountState = storeAccountState;
  }
});

// node_modules/ton-core/dist/types/CurrencyCollection.js
var require_CurrencyCollection = __commonJS({
  "node_modules/ton-core/dist/types/CurrencyCollection.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCurrencyCollection = exports.loadCurrencyCollection = void 0;
    var Dictionary_1 = require_Dictionary();
    function loadCurrencyCollection(slice) {
      const coins = slice.loadCoins();
      const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(
        5
        /* log2(32) */
      ));
      if (other.size === 0) {
        return { coins };
      } else {
        return { other, coins };
      }
    }
    exports.loadCurrencyCollection = loadCurrencyCollection;
    function storeCurrencyCollection(collection) {
      return (builder) => {
        builder.storeCoins(collection.coins);
        if (collection.other) {
          builder.storeDict(collection.other);
        } else {
          builder.storeBit(0);
        }
      };
    }
    exports.storeCurrencyCollection = storeCurrencyCollection;
  }
});

// node_modules/ton-core/dist/types/AccountStorage.js
var require_AccountStorage = __commonJS({
  "node_modules/ton-core/dist/types/AccountStorage.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStorage = exports.loadAccountStorage = void 0;
    var AccountState_1 = require_AccountState();
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadAccountStorage(slice) {
      return {
        lastTransLt: slice.loadUintBig(64),
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
        state: (0, AccountState_1.loadAccountState)(slice)
      };
    }
    exports.loadAccountStorage = loadAccountStorage;
    function storeAccountStorage(src) {
      return (builder) => {
        builder.storeUint(src.lastTransLt, 64);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
        builder.store((0, AccountState_1.storeAccountState)(src.state));
      };
    }
    exports.storeAccountStorage = storeAccountStorage;
  }
});

// node_modules/ton-core/dist/types/StorageUsed.js
var require_StorageUsed = __commonJS({
  "node_modules/ton-core/dist/types/StorageUsed.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageUsed = exports.loadStorageUsed = void 0;
    function loadStorageUsed(cs) {
      return {
        cells: cs.loadVarUintBig(3),
        bits: cs.loadVarUintBig(3),
        publicCells: cs.loadVarUintBig(3)
      };
    }
    exports.loadStorageUsed = loadStorageUsed;
    function storeStorageUsed(src) {
      return (builder) => {
        builder.storeVarUint(src.cells, 3);
        builder.storeVarUint(src.bits, 3);
        builder.storeVarUint(src.publicCells, 3);
      };
    }
    exports.storeStorageUsed = storeStorageUsed;
  }
});

// node_modules/ton-core/dist/types/StorageInto.js
var require_StorageInto = __commonJS({
  "node_modules/ton-core/dist/types/StorageInto.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageInfo = exports.loadStorageInfo = void 0;
    var StorageUsed_1 = require_StorageUsed();
    function loadStorageInfo(slice) {
      return {
        used: (0, StorageUsed_1.loadStorageUsed)(slice),
        lastPaid: slice.loadUint(32),
        duePayment: slice.loadMaybeCoins()
      };
    }
    exports.loadStorageInfo = loadStorageInfo;
    function storeStorageInfo(src) {
      return (builder) => {
        builder.store((0, StorageUsed_1.storeStorageUsed)(src.used));
        builder.storeUint(src.lastPaid, 32);
        builder.storeMaybeCoins(src.duePayment);
      };
    }
    exports.storeStorageInfo = storeStorageInfo;
  }
});

// node_modules/ton-core/dist/types/Account.js
var require_Account = __commonJS({
  "node_modules/ton-core/dist/types/Account.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccount = exports.loadAccount = void 0;
    var AccountStorage_1 = require_AccountStorage();
    var StorageInto_1 = require_StorageInto();
    function loadAccount(slice) {
      return {
        addr: slice.loadAddress(),
        storageStats: (0, StorageInto_1.loadStorageInfo)(slice),
        storage: (0, AccountStorage_1.loadAccountStorage)(slice)
      };
    }
    exports.loadAccount = loadAccount;
    function storeAccount(src) {
      return (builder) => {
        builder.storeAddress(src.addr);
        builder.store((0, StorageInto_1.storeStorageInfo)(src.storageStats));
        builder.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
      };
    }
    exports.storeAccount = storeAccount;
  }
});

// node_modules/ton-core/dist/types/AccountStatus.js
var require_AccountStatus = __commonJS({
  "node_modules/ton-core/dist/types/AccountStatus.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStatus = exports.loadAccountStatus = void 0;
    function loadAccountStatus(slice) {
      const status = slice.loadUint(2);
      if (status === 0) {
        return "uninitialized";
      }
      if (status === 1) {
        return "frozen";
      }
      if (status === 2) {
        return "active";
      }
      if (status === 3) {
        return "non-existing";
      }
      throw Error("Invalid data");
    }
    exports.loadAccountStatus = loadAccountStatus;
    function storeAccountStatus(src) {
      return (builder) => {
        if (src === "uninitialized") {
          builder.storeUint(0, 2);
        } else if (src === "frozen") {
          builder.storeUint(1, 2);
        } else if (src === "active") {
          builder.storeUint(2, 2);
        } else if (src === "non-existing") {
          builder.storeUint(3, 2);
        } else {
          throw Error("Invalid data");
        }
        return builder;
      };
    }
    exports.storeAccountStatus = storeAccountStatus;
  }
});

// node_modules/ton-core/dist/types/AccountStatusChange.js
var require_AccountStatusChange = __commonJS({
  "node_modules/ton-core/dist/types/AccountStatusChange.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeAccountStatusChange = exports.loadAccountStatusChange = void 0;
    function loadAccountStatusChange(slice) {
      if (!slice.loadBit()) {
        return "unchanged";
      }
      if (slice.loadBit()) {
        return "frozen";
      } else {
        return "deleted";
      }
    }
    exports.loadAccountStatusChange = loadAccountStatusChange;
    function storeAccountStatusChange(src) {
      return (builder) => {
        if (src == "unchanged") {
          builder.storeBit(0);
        } else if (src === "frozen") {
          builder.storeBit(1);
          builder.storeBit(0);
        } else if (src === "deleted") {
          builder.storeBit(1);
          builder.storeBit(1);
        } else {
          throw Error("Invalid account status change");
        }
      };
    }
    exports.storeAccountStatusChange = storeAccountStatusChange;
  }
});

// node_modules/ton-core/dist/types/CommonMessageInfo.js
var require_CommonMessageInfo = __commonJS({
  "node_modules/ton-core/dist/types/CommonMessageInfo.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadCommonMessageInfo(slice) {
      if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src2 = slice.loadAddress();
        const dest2 = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt2 = slice.loadUintBig(64);
        const createdAt2 = slice.loadUint(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src: src2,
          dest: dest2,
          value,
          ihrFee,
          forwardFee,
          createdLt: createdLt2,
          createdAt: createdAt2
        };
      }
      if (!slice.loadBit()) {
        const src2 = slice.loadMaybeExternalAddress();
        const dest2 = slice.loadAddress();
        const importFee = slice.loadCoins();
        return {
          type: "external-in",
          src: src2,
          dest: dest2,
          importFee
        };
      }
      const src = slice.loadAddress();
      const dest = slice.loadMaybeExternalAddress();
      const createdLt = slice.loadUintBig(64);
      const createdAt = slice.loadUint(32);
      return {
        type: "external-out",
        src,
        dest,
        createdLt,
        createdAt
      };
    }
    exports.loadCommonMessageInfo = loadCommonMessageInfo;
    function storeCommonMessageInfo(source) {
      return (builder) => {
        if (source.type === "internal") {
          builder.storeBit(0);
          builder.storeBit(source.ihrDisabled);
          builder.storeBit(source.bounce);
          builder.storeBit(source.bounced);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
          builder.storeCoins(source.ihrFee);
          builder.storeCoins(source.forwardFee);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else if (source.type === "external-in") {
          builder.storeBit(1);
          builder.storeBit(0);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeCoins(source.importFee);
        } else if (source.type === "external-out") {
          builder.storeBit(1);
          builder.storeBit(1);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else {
          throw new Error("Unknown CommonMessageInfo type");
        }
      };
    }
    exports.storeCommonMessageInfo = storeCommonMessageInfo;
  }
});

// node_modules/ton-core/dist/types/CommonMessageInfoRelaxed.js
var require_CommonMessageInfoRelaxed = __commonJS({
  "node_modules/ton-core/dist/types/CommonMessageInfoRelaxed.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadCommonMessageInfoRelaxed(slice) {
      if (!slice.loadBit()) {
        const ihrDisabled = slice.loadBit();
        const bounce = slice.loadBit();
        const bounced = slice.loadBit();
        const src2 = slice.loadMaybeAddress();
        const dest2 = slice.loadAddress();
        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
        const ihrFee = slice.loadCoins();
        const forwardFee = slice.loadCoins();
        const createdLt2 = slice.loadUintBig(64);
        const createdAt2 = slice.loadUint(32);
        return {
          type: "internal",
          ihrDisabled,
          bounce,
          bounced,
          src: src2,
          dest: dest2,
          value,
          ihrFee,
          forwardFee,
          createdLt: createdLt2,
          createdAt: createdAt2
        };
      }
      if (!slice.loadBit()) {
        throw Error("External In message is not possible for CommonMessageInfoRelaxed");
      }
      const src = slice.loadMaybeAddress();
      const dest = slice.loadMaybeExternalAddress();
      const createdLt = slice.loadUintBig(64);
      const createdAt = slice.loadUint(32);
      return {
        type: "external-out",
        src,
        dest,
        createdLt,
        createdAt
      };
    }
    exports.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
    function storeCommonMessageInfoRelaxed(source) {
      return (builder) => {
        if (source.type === "internal") {
          builder.storeBit(0);
          builder.storeBit(source.ihrDisabled);
          builder.storeBit(source.bounce);
          builder.storeBit(source.bounced);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
          builder.storeCoins(source.ihrFee);
          builder.storeCoins(source.forwardFee);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else if (source.type === "external-out") {
          builder.storeBit(1);
          builder.storeBit(1);
          builder.storeAddress(source.src);
          builder.storeAddress(source.dest);
          builder.storeUint(source.createdLt, 64);
          builder.storeUint(source.createdAt, 32);
        } else {
          throw new Error("Unknown CommonMessageInfo type");
        }
      };
    }
    exports.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
  }
});

// node_modules/ton-core/dist/types/ComputeSkipReason.js
var require_ComputeSkipReason = __commonJS({
  "node_modules/ton-core/dist/types/ComputeSkipReason.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeComputeSkipReason = exports.loadComputeSkipReason = void 0;
    function loadComputeSkipReason(slice) {
      let reason = slice.loadUint(2);
      if (reason === 0) {
        return "no-state";
      } else if (reason === 1) {
        return "bad-state";
      } else if (reason === 2) {
        return "no-gas";
      }
      throw new Error(`Unknown ComputeSkipReason: ${reason}`);
    }
    exports.loadComputeSkipReason = loadComputeSkipReason;
    function storeComputeSkipReason(src) {
      return (builder) => {
        if (src === "no-state") {
          builder.storeUint(0, 2);
        } else if (src === "bad-state") {
          builder.storeUint(1, 2);
        } else if (src === "no-gas") {
          builder.storeUint(2, 2);
        } else {
          throw new Error(`Unknown ComputeSkipReason: ${src}`);
        }
      };
    }
    exports.storeComputeSkipReason = storeComputeSkipReason;
  }
});

// node_modules/ton-core/dist/types/DepthBalanceInfo.js
var require_DepthBalanceInfo = __commonJS({
  "node_modules/ton-core/dist/types/DepthBalanceInfo.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadDepthBalanceInfo(slice) {
      let splitDepth = slice.loadUint(5);
      return {
        splitDepth,
        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
      };
    }
    exports.loadDepthBalanceInfo = loadDepthBalanceInfo;
    function storeDepthBalanceInfo(src) {
      return (builder) => {
        builder.storeUint(src.splitDepth, 5);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
      };
    }
    exports.storeDepthBalanceInfo = storeDepthBalanceInfo;
  }
});

// node_modules/ton-core/dist/types/HashUpdate.js
var require_HashUpdate = __commonJS({
  "node_modules/ton-core/dist/types/HashUpdate.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeHashUpdate = exports.loadHashUpdate = void 0;
    function loadHashUpdate(slice) {
      if (slice.loadUint(8) !== 114) {
        throw Error("Invalid data");
      }
      const oldHash = slice.loadBuffer(32);
      const newHash = slice.loadBuffer(32);
      return { oldHash, newHash };
    }
    exports.loadHashUpdate = loadHashUpdate;
    function storeHashUpdate(src) {
      return (builder) => {
        builder.storeUint(114, 8);
        builder.storeBuffer(src.oldHash);
        builder.storeBuffer(src.newHash);
      };
    }
    exports.storeHashUpdate = storeHashUpdate;
  }
});

// node_modules/ton-core/dist/types/MasterchainStateExtra.js
var require_MasterchainStateExtra = __commonJS({
  "node_modules/ton-core/dist/types/MasterchainStateExtra.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadMasterchainStateExtra = void 0;
    var Dictionary_1 = require_Dictionary();
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadMasterchainStateExtra(cs) {
      if (cs.loadUint(16) !== 52262) {
        throw Error("Invalid data");
      }
      if (cs.loadBit()) {
        cs.loadRef();
      }
      let configAddress = cs.loadUintBig(256);
      let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
      const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
      return {
        config,
        configAddress,
        globalBalance
      };
    }
    exports.loadMasterchainStateExtra = loadMasterchainStateExtra;
  }
});

// node_modules/ton-core/dist/types/Message.js
var require_Message = __commonJS({
  "node_modules/ton-core/dist/types/Message.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageValue = exports.storeMessage = exports.loadMessage = void 0;
    var Builder_1 = require_Builder();
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    var StateInit_1 = require_StateInit();
    function loadMessage(slice) {
      const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
      let init = null;
      if (slice.loadBit()) {
        if (!slice.loadBit()) {
          init = (0, StateInit_1.loadStateInit)(slice);
        } else {
          init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
      }
      const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
      return {
        info,
        init,
        body
      };
    }
    exports.loadMessage = loadMessage;
    function storeMessage(message, opts) {
      return (builder) => {
        builder.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
        if (message.init) {
          builder.storeBit(true);
          let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
          let needRef2 = false;
          if (opts && opts.forceRef) {
            needRef2 = true;
          } else if (builder.availableBits - 2 >= initCell.bits) {
            needRef2 = false;
          } else {
            needRef2 = true;
          }
          if (needRef2) {
            builder.storeBit(true);
            builder.storeRef(initCell);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(initCell);
          }
        } else {
          builder.storeBit(false);
        }
        let needRef = false;
        if (opts && opts.forceRef) {
          needRef = true;
        } else {
          if (builder.availableBits - 1 >= message.body.bits.length && builder.refs + message.body.refs.length <= 4) {
            needRef = false;
          } else {
            needRef = true;
          }
        }
        if (needRef) {
          builder.storeBit(true);
          builder.storeRef(message.body);
        } else {
          builder.storeBit(false);
          builder.storeBuilder(message.body.asBuilder());
        }
      };
    }
    exports.storeMessage = storeMessage;
    exports.MessageValue = {
      serialize(src, builder) {
        builder.storeRef((0, Builder_1.beginCell)().store(storeMessage(src)));
      },
      parse(slice) {
        return loadMessage(slice.loadRef().beginParse());
      }
    };
  }
});

// node_modules/ton-core/dist/types/MessageRelaxed.js
var require_MessageRelaxed = __commonJS({
  "node_modules/ton-core/dist/types/MessageRelaxed.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeMessageRelaxed = exports.loadMessageRelaxed = void 0;
    var Builder_1 = require_Builder();
    var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
    var StateInit_1 = require_StateInit();
    function loadMessageRelaxed(slice) {
      const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
      let init = null;
      if (slice.loadBit()) {
        if (!slice.loadBit()) {
          init = (0, StateInit_1.loadStateInit)(slice);
        } else {
          init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
        }
      }
      const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
      return {
        info,
        init,
        body
      };
    }
    exports.loadMessageRelaxed = loadMessageRelaxed;
    function storeMessageRelaxed(message, opts) {
      return (builder) => {
        builder.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
        if (message.init) {
          builder.storeBit(true);
          let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
          let needRef2 = false;
          if (opts && opts.forceRef) {
            needRef2 = true;
          } else {
            if (builder.availableBits - 2 >= initCell.bits) {
              needRef2 = false;
            } else {
              needRef2 = true;
            }
          }
          if (needRef2) {
            builder.storeBit(true);
            builder.storeRef(initCell);
          } else {
            builder.storeBit(false);
            builder.storeBuilder(initCell);
          }
        } else {
          builder.storeBit(false);
        }
        let needRef = false;
        if (opts && opts.forceRef) {
          needRef = true;
        } else {
          if (builder.availableBits - 1 >= message.body.bits.length && builder.refs + message.body.refs.length <= 4) {
            needRef = false;
          } else {
            needRef = true;
          }
        }
        if (needRef) {
          builder.storeBit(true);
          builder.storeRef(message.body);
        } else {
          builder.storeBit(false);
          builder.storeBuilder(message.body.asBuilder());
        }
      };
    }
    exports.storeMessageRelaxed = storeMessageRelaxed;
  }
});

// node_modules/ton-core/dist/types/SendMode.js
var require_SendMode = __commonJS({
  "node_modules/ton-core/dist/types/SendMode.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SendMode = void 0;
    var SendMode;
    (function(SendMode2) {
      SendMode2[SendMode2["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
      SendMode2[SendMode2["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
      SendMode2[SendMode2["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
      SendMode2[SendMode2["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
      SendMode2[SendMode2["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
      SendMode2[SendMode2["NONE"] = 0] = "NONE";
    })(SendMode = exports.SendMode || (exports.SendMode = {}));
  }
});

// node_modules/ton-core/dist/types/ShardAccount.js
var require_ShardAccount = __commonJS({
  "node_modules/ton-core/dist/types/ShardAccount.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccount = exports.loadShardAccount = void 0;
    var Builder_1 = require_Builder();
    var Account_1 = require_Account();
    function loadShardAccount(slice) {
      let accountRef = slice.loadRef();
      let account = void 0;
      if (!accountRef.isExotic) {
        let accountSlice = accountRef.beginParse();
        if (accountSlice.loadBit()) {
          account = (0, Account_1.loadAccount)(accountSlice);
        }
      }
      return {
        account,
        lastTransactionHash: slice.loadUintBig(256),
        lastTransactionLt: slice.loadUintBig(64)
      };
    }
    exports.loadShardAccount = loadShardAccount;
    function storeShardAccount(src) {
      return (builder) => {
        if (src.account) {
          builder.storeRef((0, Builder_1.beginCell)().storeBit(true).store((0, Account_1.storeAccount)(src.account)));
        } else {
          builder.storeRef((0, Builder_1.beginCell)().storeBit(false));
        }
        builder.storeUint(src.lastTransactionHash, 256);
        builder.storeUint(src.lastTransactionLt, 64);
      };
    }
    exports.storeShardAccount = storeShardAccount;
  }
});

// node_modules/ton-core/dist/types/ShardAccounts.js
var require_ShardAccounts = __commonJS({
  "node_modules/ton-core/dist/types/ShardAccounts.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
    var Dictionary_1 = require_Dictionary();
    var DepthBalanceInfo_1 = require_DepthBalanceInfo();
    var ShardAccount_1 = require_ShardAccount();
    exports.ShardAccountRefValue = {
      parse: (cs) => {
        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
        return {
          depthBalanceInfo,
          shardAccount
        };
      },
      serialize(src, builder) {
        builder.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
        builder.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
      }
    };
    function loadShardAccounts(cs) {
      return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
    }
    exports.loadShardAccounts = loadShardAccounts;
    function storeShardAccounts(src) {
      return (Builder) => {
        Builder.storeDict(src);
      };
    }
    exports.storeShardAccounts = storeShardAccounts;
  }
});

// node_modules/ton-core/dist/types/ShardIdent.js
var require_ShardIdent = __commonJS({
  "node_modules/ton-core/dist/types/ShardIdent.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeShardIdent = exports.loadShardIdent = void 0;
    function loadShardIdent(slice) {
      if (slice.loadUint(2) !== 0) {
        throw Error("Invalid data");
      }
      return {
        shardPrefixBits: slice.loadUint(6),
        workchainId: slice.loadInt(32),
        shardPrefix: slice.loadUintBig(64)
      };
    }
    exports.loadShardIdent = loadShardIdent;
    function storeShardIdent(src) {
      return (builder) => {
        builder.storeUint(0, 2);
        builder.storeUint(src.shardPrefixBits, 6);
        builder.storeInt(src.workchainId, 32);
        builder.storeUint(src.shardPrefix, 64);
      };
    }
    exports.storeShardIdent = storeShardIdent;
  }
});

// node_modules/ton-core/dist/types/ShardStateUnsplit.js
var require_ShardStateUnsplit = __commonJS({
  "node_modules/ton-core/dist/types/ShardStateUnsplit.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadShardStateUnsplit = void 0;
    var MasterchainStateExtra_1 = require_MasterchainStateExtra();
    var ShardAccounts_1 = require_ShardAccounts();
    var ShardIdent_1 = require_ShardIdent();
    function loadShardStateUnsplit(cs) {
      if (cs.loadUint(32) !== 2418257890) {
        throw Error("Invalid data");
      }
      let globalId = cs.loadInt(32);
      let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
      let seqno = cs.loadUint(32);
      let vertSeqNo = cs.loadUint(32);
      let genUtime = cs.loadUint(32);
      let genLt = cs.loadUintBig(64);
      let minRefMcSeqno = cs.loadUint(32);
      cs.loadRef();
      let beforeSplit = cs.loadBit();
      let shardAccountsRef = cs.loadRef();
      let accounts = void 0;
      if (!shardAccountsRef.isExotic) {
        accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
      }
      cs.loadRef();
      let mcStateExtra = cs.loadBit();
      let extras = null;
      if (mcStateExtra) {
        let cell = cs.loadRef();
        if (!cell.isExotic) {
          extras = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
        }
      }
      ;
      return {
        globalId,
        shardId,
        seqno,
        vertSeqNo,
        genUtime,
        genLt,
        minRefMcSeqno,
        beforeSplit,
        accounts,
        extras
      };
    }
    exports.loadShardStateUnsplit = loadShardStateUnsplit;
  }
});

// node_modules/ton-core/dist/types/SplitMergeInfo.js
var require_SplitMergeInfo = __commonJS({
  "node_modules/ton-core/dist/types/SplitMergeInfo.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = void 0;
    function loadSplitMergeInfo(slice) {
      let currentShardPrefixLength = slice.loadUint(6);
      let accountSplitDepth = slice.loadUint(6);
      let thisAddress = slice.loadUintBig(256);
      let siblingAddress = slice.loadUintBig(256);
      return {
        currentShardPrefixLength,
        accountSplitDepth,
        thisAddress,
        siblingAddress
      };
    }
    exports.loadSplitMergeInfo = loadSplitMergeInfo;
    function storeSplitMergeInfo(src) {
      return (builder) => {
        builder.storeUint(src.currentShardPrefixLength, 6);
        builder.storeUint(src.accountSplitDepth, 6);
        builder.storeUint(src.thisAddress, 256);
        builder.storeUint(src.siblingAddress, 256);
      };
    }
    exports.storeSplitMergeInfo = storeSplitMergeInfo;
  }
});

// node_modules/ton-core/dist/types/StorageUsedShort.js
var require_StorageUsedShort = __commonJS({
  "node_modules/ton-core/dist/types/StorageUsedShort.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeStorageUsedShort = exports.loadStorageUsedShort = void 0;
    function loadStorageUsedShort(slice) {
      let cells = slice.loadVarUintBig(3);
      let bits = slice.loadVarUintBig(3);
      return {
        cells,
        bits
      };
    }
    exports.loadStorageUsedShort = loadStorageUsedShort;
    function storeStorageUsedShort(src) {
      return (builder) => {
        builder.storeVarUint(src.cells, 3);
        builder.storeVarUint(src.bits, 3);
      };
    }
    exports.storeStorageUsedShort = storeStorageUsedShort;
  }
});

// node_modules/ton-core/dist/types/TransactionActionPhase.js
var require_TransactionActionPhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionActionPhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = void 0;
    var AccountStatusChange_1 = require_AccountStatusChange();
    var StorageUsedShort_1 = require_StorageUsedShort();
    function loadTransactionActionPhase(slice) {
      let success = slice.loadBit();
      let valid = slice.loadBit();
      let noFunds = slice.loadBit();
      let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
      let totalFwdFees = slice.loadBit() ? slice.loadCoins() : void 0;
      let totalActionFees = slice.loadBit() ? slice.loadCoins() : void 0;
      let resultCode = slice.loadInt(32);
      let resultArg = slice.loadBit() ? slice.loadInt(32) : void 0;
      let totalActions = slice.loadUint(16);
      let specActions = slice.loadUint(16);
      let skippedActions = slice.loadUint(16);
      let messagesCreated = slice.loadUint(16);
      let actionListHash = slice.loadUintBig(256);
      let totalMessageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
      return {
        success,
        valid,
        noFunds,
        statusChange,
        totalFwdFees,
        totalActionFees,
        resultCode,
        resultArg,
        totalActions,
        specActions,
        skippedActions,
        messagesCreated,
        actionListHash,
        totalMessageSize
      };
    }
    exports.loadTransactionActionPhase = loadTransactionActionPhase;
    function storeTransactionActionPhase(src) {
      return (builder) => {
        builder.storeBit(src.success);
        builder.storeBit(src.valid);
        builder.storeBit(src.noFunds);
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
        builder.storeMaybeCoins(src.totalFwdFees);
        builder.storeMaybeCoins(src.totalActionFees);
        builder.storeInt(src.resultCode, 32);
        builder.storeMaybeInt(src.resultArg, 32);
        builder.storeUint(src.totalActions, 16);
        builder.storeUint(src.specActions, 16);
        builder.storeUint(src.skippedActions, 16);
        builder.storeUint(src.messagesCreated, 16);
        builder.storeUint(src.actionListHash, 256);
        builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.totalMessageSize));
      };
    }
    exports.storeTransactionActionPhase = storeTransactionActionPhase;
  }
});

// node_modules/ton-core/dist/types/TransactionBouncePhase.js
var require_TransactionBouncePhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionBouncePhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = void 0;
    var StorageUsedShort_1 = require_StorageUsedShort();
    function loadTransactionBouncePhase(slice) {
      if (slice.loadBit()) {
        let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
        let messageFees = slice.loadCoins();
        let forwardFees = slice.loadCoins();
        return {
          type: "ok",
          messageSize,
          messageFees,
          forwardFees
        };
      }
      if (slice.loadBit()) {
        let messageSize = (0, StorageUsedShort_1.loadStorageUsedShort)(slice);
        let requiredForwardFees = slice.loadCoins();
        return {
          type: "no-funds",
          messageSize,
          requiredForwardFees
        };
      }
      return {
        type: "negative-funds"
      };
    }
    exports.loadTransactionBouncePhase = loadTransactionBouncePhase;
    function storeTransactionBouncePhase(src) {
      return (builder) => {
        if (src.type === "ok") {
          builder.storeBit(true);
          builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
          builder.storeCoins(src.messageFees);
          builder.storeCoins(src.forwardFees);
        } else if (src.type === "negative-funds") {
          builder.storeBit(false);
          builder.storeBit(false);
        } else if (src.type === "no-funds") {
          builder.storeBit(false);
          builder.storeBit(true);
          builder.store((0, StorageUsedShort_1.storeStorageUsedShort)(src.messageSize));
          builder.storeCoins(src.requiredForwardFees);
        } else {
          throw new Error("Invalid TransactionBouncePhase type");
        }
      };
    }
    exports.storeTransactionBouncePhase = storeTransactionBouncePhase;
  }
});

// node_modules/ton-core/dist/types/TransactionComputePhase.js
var require_TransactionComputePhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionComputePhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = void 0;
    var Builder_1 = require_Builder();
    var ComputeSkipReason_1 = require_ComputeSkipReason();
    function loadTransactionComputePhase(slice) {
      if (!slice.loadBit()) {
        let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
        return {
          type: "skipped",
          reason
        };
      }
      let success = slice.loadBit();
      let messageStateUsed = slice.loadBit();
      let accountActivated = slice.loadBit();
      let gasFees = slice.loadCoins();
      const vmState = slice.loadRef().beginParse();
      let gasUsed = vmState.loadVarUintBig(3);
      let gasLimit = vmState.loadVarUintBig(3);
      let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : void 0;
      let mode = vmState.loadUint(8);
      let exitCode = vmState.loadUint(32);
      let exitArg = vmState.loadBit() ? vmState.loadInt(32) : void 0;
      let vmSteps = vmState.loadUint(32);
      let vmInitStateHash = vmState.loadUintBig(256);
      let vmFinalStateHash = vmState.loadUintBig(256);
      return {
        type: "vm",
        success,
        messageStateUsed,
        accountActivated,
        gasFees,
        gasUsed,
        gasLimit,
        gasCredit,
        mode,
        exitCode,
        exitArg,
        vmSteps,
        vmInitStateHash,
        vmFinalStateHash
      };
    }
    exports.loadTransactionComputePhase = loadTransactionComputePhase;
    function storeTransactionComputePhase(src) {
      return (builder) => {
        if (src.type === "skipped") {
          builder.storeBit(0);
          builder.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
          return;
        }
        builder.storeBit(1);
        builder.storeBit(src.success);
        builder.storeBit(src.messageStateUsed);
        builder.storeBit(src.accountActivated);
        builder.storeCoins(src.gasFees);
        builder.storeRef((0, Builder_1.beginCell)().storeVarUint(src.gasUsed, 3).storeVarUint(src.gasLimit, 3).store((b) => src.gasCredit !== void 0 && src.gasCredit !== null ? b.storeBit(1).storeVarUint(src.gasCredit, 2) : b.storeBit(0)).storeUint(src.mode, 8).storeUint(src.exitCode, 32).store((b) => src.exitArg !== void 0 && src.exitArg !== null ? b.storeBit(1).storeInt(src.exitArg, 32) : b.storeBit(0)).storeUint(src.vmSteps, 32).storeUint(src.vmInitStateHash, 256).storeUint(src.vmFinalStateHash, 256).endCell());
      };
    }
    exports.storeTransactionComputePhase = storeTransactionComputePhase;
  }
});

// node_modules/ton-core/dist/types/TransactionCreditPhase.js
var require_TransactionCreditPhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionCreditPhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = void 0;
    var CurrencyCollection_1 = require_CurrencyCollection();
    function loadTransactionCreditPhase(slice) {
      const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : void 0;
      const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      return {
        dueFeesColelcted,
        credit
      };
    }
    exports.loadTransactionCreditPhase = loadTransactionCreditPhase;
    function storeTransactionCreditPhase(src) {
      return (builder) => {
        if (src.dueFeesColelcted === null || src.dueFeesColelcted === void 0) {
          builder.storeBit(false);
        } else {
          builder.storeBit(true);
          builder.storeCoins(src.dueFeesColelcted);
        }
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
      };
    }
    exports.storeTransactionCreditPhase = storeTransactionCreditPhase;
  }
});

// node_modules/ton-core/dist/types/TransactionStoragePhase.js
var require_TransactionStoragePhase = __commonJS({
  "node_modules/ton-core/dist/types/TransactionStoragePhase.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = void 0;
    var AccountStatusChange_1 = require_AccountStatusChange();
    function loadTransactionStoragePhase(slice) {
      const storageFeesCollected = slice.loadCoins();
      let storageFeesDue = void 0;
      if (slice.loadBit()) {
        storageFeesDue = slice.loadCoins();
      }
      const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
      return {
        storageFeesCollected,
        storageFeesDue,
        statusChange
      };
    }
    exports.loadTransactionStoragePhase = loadTransactionStoragePhase;
    function storeTransactionsStoragePhase(src) {
      return (builder) => {
        builder.storeCoins(src.storageFeesCollected);
        if (src.storageFeesDue === null || src.storageFeesDue === void 0) {
          builder.storeBit(false);
        } else {
          builder.storeBit(true);
          builder.storeCoins(src.storageFeesDue);
        }
        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
      };
    }
    exports.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
  }
});

// node_modules/ton-core/dist/types/TransactionDescription.js
var require_TransactionDescription = __commonJS({
  "node_modules/ton-core/dist/types/TransactionDescription.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransactionDescription = exports.loadTransactionDescription = void 0;
    var Builder_1 = require_Builder();
    var SplitMergeInfo_1 = require_SplitMergeInfo();
    var Transaction_1 = require_Transaction();
    var TransactionActionPhase_1 = require_TransactionActionPhase();
    var TransactionBouncePhase_1 = require_TransactionBouncePhase();
    var TransactionComputePhase_1 = require_TransactionComputePhase();
    var TransactionCreditPhase_1 = require_TransactionCreditPhase();
    var TransactionStoragePhase_1 = require_TransactionStoragePhase();
    function loadTransactionDescription(slice) {
      let type = slice.loadUint(4);
      if (type === 0) {
        const creditFirst = slice.loadBit();
        let storagePhase = void 0;
        if (slice.loadBit()) {
          storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let creditPhase = void 0;
        if (slice.loadBit()) {
          creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        let aborted = slice.loadBit();
        let bouncePhase = void 0;
        if (slice.loadBit()) {
          bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
        }
        const destroyed = slice.loadBit();
        return {
          type: "generic",
          creditFirst,
          storagePhase,
          creditPhase,
          computePhase,
          actionPhase,
          bouncePhase,
          aborted,
          destroyed
        };
      }
      if (type === 1) {
        return {
          type: "storage",
          storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
        };
      }
      if (type === 2 || type === 3) {
        const isTock = type === 3;
        let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
          type: "tick-tock",
          isTock,
          storagePhase,
          computePhase,
          actionPhase,
          aborted,
          destroyed
        };
      }
      if (type === 4) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let storagePhase = void 0;
        if (slice.loadBit()) {
          storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
        }
        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
        let actionPhase = void 0;
        if (slice.loadBit()) {
          actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
        }
        const aborted = slice.loadBit();
        const destroyed = slice.loadBit();
        return {
          type: "split-prepare",
          splitInfo,
          storagePhase,
          computePhase,
          actionPhase,
          aborted,
          destroyed
        };
      }
      if (type === 5) {
        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
        let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
        const installed = slice.loadBit();
        return {
          type: "split-install",
          splitInfo,
          prepareTransaction,
          installed
        };
      }
      throw Error(`Unsupported transaction description type ${type}`);
    }
    exports.loadTransactionDescription = loadTransactionDescription;
    function storeTransactionDescription(src) {
      return (builder) => {
        if (src.type === "generic") {
          builder.storeUint(0, 4);
          builder.storeBit(src.creditFirst);
          if (src.storagePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          } else {
            builder.storeBit(false);
          }
          if (src.creditPhase) {
            builder.storeBit(true);
            builder.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
          } else {
            builder.storeBit(false);
          }
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          if (src.bouncePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.destroyed);
        } else if (src.type === "storage") {
          builder.storeUint(1, 4);
          builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
        } else if (src.type === "tick-tock") {
          builder.storeUint(src.isTock ? 3 : 2, 4);
          builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          builder.storeBit(src.destroyed);
        } else if (src.type === "split-prepare") {
          builder.storeUint(4, 4);
          builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
          if (src.storagePhase) {
            builder.storeBit(true);
            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
          } else {
            builder.storeBit(false);
          }
          builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
          if (src.actionPhase) {
            builder.storeBit(true);
            builder.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
          } else {
            builder.storeBit(false);
          }
          builder.storeBit(src.aborted);
          builder.storeBit(src.destroyed);
        } else if (src.type === "split-install") {
          builder.storeUint(5, 4);
          builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
          builder.storeRef((0, Builder_1.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
          builder.storeBit(src.installed);
        } else {
          throw Error(`Unsupported transaction description type ${src.type}`);
        }
      };
    }
    exports.storeTransactionDescription = storeTransactionDescription;
  }
});

// node_modules/ton-core/dist/types/Transaction.js
var require_Transaction = __commonJS({
  "node_modules/ton-core/dist/types/Transaction.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.storeTransaction = exports.loadTransaction = void 0;
    var Builder_1 = require_Builder();
    var Dictionary_1 = require_Dictionary();
    var AccountStatus_1 = require_AccountStatus();
    var CurrencyCollection_1 = require_CurrencyCollection();
    var HashUpdate_1 = require_HashUpdate();
    var Message_1 = require_Message();
    var TransactionDescription_1 = require_TransactionDescription();
    function loadTransaction(slice) {
      if (slice.loadUint(4) !== 7) {
        throw Error("Invalid data");
      }
      let address = slice.loadUintBig(256);
      let lt = slice.loadUintBig(64);
      let prevTransactionHash = slice.loadUintBig(256);
      let prevTransactionLt = slice.loadUintBig(64);
      let now = slice.loadUint(32);
      let outMessagesCount = slice.loadUint(15);
      let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
      let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
      let msgRef = slice.loadRef();
      let msgSlice = msgRef.beginParse();
      let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : void 0;
      let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
      msgSlice.endParse();
      let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
      let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
      let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
      return {
        address,
        lt,
        prevTransactionHash,
        prevTransactionLt,
        now,
        outMessagesCount,
        oldStatus,
        endStatus,
        inMessage,
        outMessages,
        totalFees,
        stateUpdate,
        description
      };
    }
    exports.loadTransaction = loadTransaction;
    function storeTransaction(src) {
      return (builder) => {
        builder.storeUint(7, 4);
        builder.storeUint(src.address, 256);
        builder.storeUint(src.lt, 64);
        builder.storeUint(src.prevTransactionHash, 256);
        builder.storeUint(src.prevTransactionLt, 64);
        builder.storeUint(src.now, 32);
        builder.storeUint(src.outMessagesCount, 15);
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
        builder.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
        let msgBuilder = (0, Builder_1.beginCell)();
        if (src.inMessage) {
          msgBuilder.storeBit(true);
          msgBuilder.storeRef((0, Builder_1.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
        } else {
          msgBuilder.storeBit(false);
        }
        msgBuilder.storeDict(src.outMessages);
        builder.storeRef(msgBuilder);
        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
        builder.storeRef((0, Builder_1.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
        builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
      };
    }
    exports.storeTransaction = storeTransaction;
  }
});

// node_modules/ton-core/dist/types/_export.js
var require_export = __commonJS({
  "node_modules/ton-core/dist/types/_export.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadStorageUsedShort = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeSimpleLibrary = exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
    exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsedShort = void 0;
    var _helpers_1 = require_helpers();
    Object.defineProperty(exports, "internal", { enumerable: true, get: function() {
      return _helpers_1.internal;
    } });
    Object.defineProperty(exports, "external", { enumerable: true, get: function() {
      return _helpers_1.external;
    } });
    Object.defineProperty(exports, "comment", { enumerable: true, get: function() {
      return _helpers_1.comment;
    } });
    var Account_1 = require_Account();
    Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function() {
      return Account_1.loadAccount;
    } });
    Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function() {
      return Account_1.storeAccount;
    } });
    var AccountState_1 = require_AccountState();
    Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function() {
      return AccountState_1.loadAccountState;
    } });
    Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function() {
      return AccountState_1.storeAccountState;
    } });
    var AccountStatus_1 = require_AccountStatus();
    Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.loadAccountStatus;
    } });
    Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function() {
      return AccountStatus_1.storeAccountStatus;
    } });
    var AccountStatusChange_1 = require_AccountStatusChange();
    Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.loadAccountStatusChange;
    } });
    Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function() {
      return AccountStatusChange_1.storeAccountStatusChange;
    } });
    var AccountStorage_1 = require_AccountStorage();
    Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.loadAccountStorage;
    } });
    Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function() {
      return AccountStorage_1.storeAccountStorage;
    } });
    var CommonMessageInfo_1 = require_CommonMessageInfo();
    Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.loadCommonMessageInfo;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function() {
      return CommonMessageInfo_1.storeCommonMessageInfo;
    } });
    var CommonMessageInfoRelaxed_1 = require_CommonMessageInfoRelaxed();
    Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed;
    } });
    Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function() {
      return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed;
    } });
    var ComputeSkipReason_1 = require_ComputeSkipReason();
    Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.loadComputeSkipReason;
    } });
    Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function() {
      return ComputeSkipReason_1.storeComputeSkipReason;
    } });
    var CurrencyCollection_1 = require_CurrencyCollection();
    Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.loadCurrencyCollection;
    } });
    Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function() {
      return CurrencyCollection_1.storeCurrencyCollection;
    } });
    var DepthBalanceInfo_1 = require_DepthBalanceInfo();
    Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.loadDepthBalanceInfo;
    } });
    Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function() {
      return DepthBalanceInfo_1.storeDepthBalanceInfo;
    } });
    var HashUpdate_1 = require_HashUpdate();
    Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.loadHashUpdate;
    } });
    Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function() {
      return HashUpdate_1.storeHashUpdate;
    } });
    var MasterchainStateExtra_1 = require_MasterchainStateExtra();
    Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function() {
      return MasterchainStateExtra_1.loadMasterchainStateExtra;
    } });
    var Message_1 = require_Message();
    Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function() {
      return Message_1.loadMessage;
    } });
    Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function() {
      return Message_1.storeMessage;
    } });
    var MessageRelaxed_1 = require_MessageRelaxed();
    Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.loadMessageRelaxed;
    } });
    Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function() {
      return MessageRelaxed_1.storeMessageRelaxed;
    } });
    var SendMode_1 = require_SendMode();
    Object.defineProperty(exports, "SendMode", { enumerable: true, get: function() {
      return SendMode_1.SendMode;
    } });
    var ShardAccount_1 = require_ShardAccount();
    Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.loadShardAccount;
    } });
    Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function() {
      return ShardAccount_1.storeShardAccount;
    } });
    var ShardAccounts_1 = require_ShardAccounts();
    Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function() {
      return ShardAccounts_1.ShardAccountRefValue;
    } });
    Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.loadShardAccounts;
    } });
    Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function() {
      return ShardAccounts_1.storeShardAccounts;
    } });
    var ShardIdent_1 = require_ShardIdent();
    Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.loadShardIdent;
    } });
    Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function() {
      return ShardIdent_1.storeShardIdent;
    } });
    var ShardStateUnsplit_1 = require_ShardStateUnsplit();
    Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function() {
      return ShardStateUnsplit_1.loadShardStateUnsplit;
    } });
    var SimpleLibrary_1 = require_SimpleLibrary();
    Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.loadSimpleLibrary;
    } });
    Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function() {
      return SimpleLibrary_1.storeSimpleLibrary;
    } });
    var SplitMergeInfo_1 = require_SplitMergeInfo();
    Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.loadSplitMergeInfo;
    } });
    Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function() {
      return SplitMergeInfo_1.storeSplitMergeInfo;
    } });
    var StateInit_1 = require_StateInit();
    Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function() {
      return StateInit_1.loadStateInit;
    } });
    Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function() {
      return StateInit_1.storeStateInit;
    } });
    var StorageInto_1 = require_StorageInto();
    Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function() {
      return StorageInto_1.loadStorageInfo;
    } });
    Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function() {
      return StorageInto_1.storeStorageInfo;
    } });
    var StorageUsed_1 = require_StorageUsed();
    Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.loadStorageUsed;
    } });
    Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function() {
      return StorageUsed_1.storeStorageUsed;
    } });
    var StorageUsedShort_1 = require_StorageUsedShort();
    Object.defineProperty(exports, "loadStorageUsedShort", { enumerable: true, get: function() {
      return StorageUsedShort_1.loadStorageUsedShort;
    } });
    Object.defineProperty(exports, "storeStorageUsedShort", { enumerable: true, get: function() {
      return StorageUsedShort_1.storeStorageUsedShort;
    } });
    var TickTock_1 = require_TickTock();
    Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function() {
      return TickTock_1.loadTickTock;
    } });
    Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function() {
      return TickTock_1.storeTickTock;
    } });
    var Transaction_1 = require_Transaction();
    Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function() {
      return Transaction_1.loadTransaction;
    } });
    Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function() {
      return Transaction_1.storeTransaction;
    } });
    var TransactionActionPhase_1 = require_TransactionActionPhase();
    Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.loadTransactionActionPhase;
    } });
    Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function() {
      return TransactionActionPhase_1.storeTransactionActionPhase;
    } });
    var TransactionBouncePhase_1 = require_TransactionBouncePhase();
    Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.loadTransactionBouncePhase;
    } });
    Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function() {
      return TransactionBouncePhase_1.storeTransactionBouncePhase;
    } });
    var TransactionComputePhase_1 = require_TransactionComputePhase();
    Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.loadTransactionComputePhase;
    } });
    Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function() {
      return TransactionComputePhase_1.storeTransactionComputePhase;
    } });
    var TransactionCreditPhase_1 = require_TransactionCreditPhase();
    Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.loadTransactionCreditPhase;
    } });
    Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function() {
      return TransactionCreditPhase_1.storeTransactionCreditPhase;
    } });
    var TransactionDescription_1 = require_TransactionDescription();
    Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.loadTransactionDescription;
    } });
    Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function() {
      return TransactionDescription_1.storeTransactionDescription;
    } });
    var TransactionStoragePhase_1 = require_TransactionStoragePhase();
    Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.loadTransactionStoragePhase;
    } });
    Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function() {
      return TransactionStoragePhase_1.storeTransactionsStoragePhase;
    } });
  }
});

// node_modules/ton-core/dist/contract/openContract.js
var require_openContract = __commonJS({
  "node_modules/ton-core/dist/contract/openContract.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.openContract = void 0;
    var Address_1 = require_Address();
    var Cell_1 = require_Cell();
    function openContract(src, factory) {
      let address;
      let init = null;
      if (!Address_1.Address.isAddress(src.address)) {
        throw Error("Invalid address");
      }
      address = src.address;
      if (src.init) {
        if (!(src.init.code instanceof Cell_1.Cell)) {
          throw Error("Invalid init.code");
        }
        if (!(src.init.data instanceof Cell_1.Cell)) {
          throw Error("Invalid init.data");
        }
        init = src.init;
      }
      let executor = factory({ address, init });
      return new Proxy(src, {
        get(target, prop) {
          const value = target[prop];
          if (typeof prop === "string" && (prop.startsWith("get") || prop.startsWith("send"))) {
            if (typeof value === "function") {
              return (...args) => value.apply(target, [executor, ...args]);
            }
          }
          return value;
        }
      });
    }
    exports.openContract = openContract;
  }
});

// node_modules/ton-core/dist/contract/ComputeError.js
var require_ComputeError = __commonJS({
  "node_modules/ton-core/dist/contract/ComputeError.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComputeError = void 0;
    var ComputeError = class extends Error {
      constructor(message, exitCode, opts) {
        super(message);
        this.exitCode = exitCode;
        this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
        this.logs = opts && opts.logs ? opts.logs : null;
        Object.setPrototypeOf(this, ComputeError.prototype);
      }
    };
    exports.ComputeError = ComputeError;
  }
});

// node_modules/ton-core/dist/utils/getMethodId.js
var require_getMethodId = __commonJS({
  "node_modules/ton-core/dist/utils/getMethodId.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMethodId = void 0;
    var TABLE = new Int16Array([
      0,
      4129,
      8258,
      12387,
      16516,
      20645,
      24774,
      28903,
      33032,
      37161,
      41290,
      45419,
      49548,
      53677,
      57806,
      61935,
      4657,
      528,
      12915,
      8786,
      21173,
      17044,
      29431,
      25302,
      37689,
      33560,
      45947,
      41818,
      54205,
      50076,
      62463,
      58334,
      9314,
      13379,
      1056,
      5121,
      25830,
      29895,
      17572,
      21637,
      42346,
      46411,
      34088,
      38153,
      58862,
      62927,
      50604,
      54669,
      13907,
      9842,
      5649,
      1584,
      30423,
      26358,
      22165,
      18100,
      46939,
      42874,
      38681,
      34616,
      63455,
      59390,
      55197,
      51132,
      18628,
      22757,
      26758,
      30887,
      2112,
      6241,
      10242,
      14371,
      51660,
      55789,
      59790,
      63919,
      35144,
      39273,
      43274,
      47403,
      23285,
      19156,
      31415,
      27286,
      6769,
      2640,
      14899,
      10770,
      56317,
      52188,
      64447,
      60318,
      39801,
      35672,
      47931,
      43802,
      27814,
      31879,
      19684,
      23749,
      11298,
      15363,
      3168,
      7233,
      60846,
      64911,
      52716,
      56781,
      44330,
      48395,
      36200,
      40265,
      32407,
      28342,
      24277,
      20212,
      15891,
      11826,
      7761,
      3696,
      65439,
      61374,
      57309,
      53244,
      48923,
      44858,
      40793,
      36728,
      37256,
      33193,
      45514,
      41451,
      53516,
      49453,
      61774,
      57711,
      4224,
      161,
      12482,
      8419,
      20484,
      16421,
      28742,
      24679,
      33721,
      37784,
      41979,
      46042,
      49981,
      54044,
      58239,
      62302,
      689,
      4752,
      8947,
      13010,
      16949,
      21012,
      25207,
      29270,
      46570,
      42443,
      38312,
      34185,
      62830,
      58703,
      54572,
      50445,
      13538,
      9411,
      5280,
      1153,
      29798,
      25671,
      21540,
      17413,
      42971,
      47098,
      34713,
      38840,
      59231,
      63358,
      50973,
      55100,
      9939,
      14066,
      1681,
      5808,
      26199,
      30326,
      17941,
      22068,
      55628,
      51565,
      63758,
      59695,
      39368,
      35305,
      47498,
      43435,
      22596,
      18533,
      30726,
      26663,
      6336,
      2273,
      14466,
      10403,
      52093,
      56156,
      60223,
      64286,
      35833,
      39896,
      43963,
      48026,
      19061,
      23124,
      27191,
      31254,
      2801,
      6864,
      10931,
      14994,
      64814,
      60687,
      56684,
      52557,
      48554,
      44427,
      40424,
      36297,
      31782,
      27655,
      23652,
      19525,
      15522,
      11395,
      7392,
      3265,
      61215,
      65342,
      53085,
      57212,
      44955,
      49082,
      36825,
      40952,
      28183,
      32310,
      20053,
      24180,
      11923,
      16050,
      3793,
      7920
    ]);
    function crc16(data) {
      if (!(data instanceof import_buffer.Buffer)) {
        data = import_buffer.Buffer.from(data);
      }
      let crc = 0;
      for (let index = 0; index < data.length; index++) {
        const byte = data[index];
        crc = (TABLE[(crc >> 8 ^ byte) & 255] ^ crc << 8) & 65535;
      }
      return crc;
    }
    function getMethodId(name) {
      return crc16(name) & 65535 | 65536;
    }
    exports.getMethodId = getMethodId;
  }
});

// node_modules/ton-core/dist/crypto/safeSign.js
var require_safeSign = __commonJS({
  "node_modules/ton-core/dist/crypto/safeSign.js"(exports) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = void 0;
    var ton_crypto_1 = require_dist();
    var MIN_SEED_LENGTH = 8;
    var MAX_SEED_LENGTH = 64;
    function createSafeSignHash(cell, seed) {
      let seedData = import_buffer.Buffer.from(seed);
      if (seedData.length > MAX_SEED_LENGTH) {
        throw Error("Seed can	 be longer than 64 bytes");
      }
      if (seedData.length < MIN_SEED_LENGTH) {
        throw Error("Seed must be at least 8 bytes");
      }
      return (0, ton_crypto_1.sha256_sync)(import_buffer.Buffer.concat([import_buffer.Buffer.from([255, 255]), seedData, cell.hash()]));
    }
    function safeSign(cell, secretKey, seed = "ton-safe-sign-magic") {
      return (0, ton_crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
    }
    exports.safeSign = safeSign;
    function safeSignVerify(cell, signature, publicKey, seed = "ton-safe-sign-magic") {
      return (0, ton_crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
    }
    exports.safeSignVerify = safeSignVerify;
  }
});

// node_modules/ton-core/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ton-core/dist/index.js"(exports) {
    init_shim();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.exoticPruned = exports.exoticMerkleUpdate = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
    var Address_1 = require_Address();
    Object.defineProperty(exports, "Address", { enumerable: true, get: function() {
      return Address_1.Address;
    } });
    Object.defineProperty(exports, "address", { enumerable: true, get: function() {
      return Address_1.address;
    } });
    var ExternalAddress_1 = require_ExternalAddress();
    Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function() {
      return ExternalAddress_1.ExternalAddress;
    } });
    var ADNLAddress_1 = require_ADNLAddress();
    Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function() {
      return ADNLAddress_1.ADNLAddress;
    } });
    var contractAddress_1 = require_contractAddress();
    Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function() {
      return contractAddress_1.contractAddress;
    } });
    var BitString_1 = require_BitString();
    Object.defineProperty(exports, "BitString", { enumerable: true, get: function() {
      return BitString_1.BitString;
    } });
    var BitReader_1 = require_BitReader();
    Object.defineProperty(exports, "BitReader", { enumerable: true, get: function() {
      return BitReader_1.BitReader;
    } });
    var BitBuilder_1 = require_BitBuilder();
    Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function() {
      return BitBuilder_1.BitBuilder;
    } });
    var Builder_1 = require_Builder();
    Object.defineProperty(exports, "Builder", { enumerable: true, get: function() {
      return Builder_1.Builder;
    } });
    Object.defineProperty(exports, "beginCell", { enumerable: true, get: function() {
      return Builder_1.beginCell;
    } });
    var Slice_1 = require_Slice();
    Object.defineProperty(exports, "Slice", { enumerable: true, get: function() {
      return Slice_1.Slice;
    } });
    var CellType_1 = require_CellType();
    Object.defineProperty(exports, "CellType", { enumerable: true, get: function() {
      return CellType_1.CellType;
    } });
    var Cell_1 = require_Cell();
    Object.defineProperty(exports, "Cell", { enumerable: true, get: function() {
      return Cell_1.Cell;
    } });
    var Dictionary_1 = require_Dictionary();
    Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function() {
      return Dictionary_1.Dictionary;
    } });
    var exoticMerkleProof_1 = require_exoticMerkleProof();
    Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function() {
      return exoticMerkleProof_1.exoticMerkleProof;
    } });
    var exoticMerkleUpdate_1 = require_exoticMerkleUpdate();
    Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function() {
      return exoticMerkleUpdate_1.exoticMerkleUpdate;
    } });
    var exoticPruned_1 = require_exoticPruned();
    Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function() {
      return exoticPruned_1.exoticPruned;
    } });
    var tuple_1 = require_tuple();
    Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function() {
      return tuple_1.parseTuple;
    } });
    Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function() {
      return tuple_1.serializeTuple;
    } });
    var reader_1 = require_reader();
    Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function() {
      return reader_1.TupleReader;
    } });
    var builder_1 = require_builder();
    Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function() {
      return builder_1.TupleBuilder;
    } });
    __exportStar(require_export(), exports);
    var openContract_1 = require_openContract();
    Object.defineProperty(exports, "openContract", { enumerable: true, get: function() {
      return openContract_1.openContract;
    } });
    var ComputeError_1 = require_ComputeError();
    Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function() {
      return ComputeError_1.ComputeError;
    } });
    var convert_1 = require_convert();
    Object.defineProperty(exports, "toNano", { enumerable: true, get: function() {
      return convert_1.toNano;
    } });
    Object.defineProperty(exports, "fromNano", { enumerable: true, get: function() {
      return convert_1.fromNano;
    } });
    var crc16_1 = require_crc16();
    Object.defineProperty(exports, "crc16", { enumerable: true, get: function() {
      return crc16_1.crc16;
    } });
    var crc32c_1 = require_crc32c();
    Object.defineProperty(exports, "crc32c", { enumerable: true, get: function() {
      return crc32c_1.crc32c;
    } });
    var base32_1 = require_base32();
    Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function() {
      return base32_1.base32Decode;
    } });
    Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function() {
      return base32_1.base32Encode;
    } });
    var getMethodId_1 = require_getMethodId();
    Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function() {
      return getMethodId_1.getMethodId;
    } });
    var safeSign_1 = require_safeSign();
    Object.defineProperty(exports, "safeSign", { enumerable: true, get: function() {
      return safeSign_1.safeSign;
    } });
    Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function() {
      return safeSign_1.safeSignVerify;
    } });
  }
});

export {
  require_dist,
  require_dist2
};
//# sourceMappingURL=chunk-J53JS463.js.map
